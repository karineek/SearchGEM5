// source: 20000112-1.c
#include <string.h>

static int
special_format (fmt)
     const char *fmt;
{
  return (strchr (fmt, '*') != 0
          || strchr (fmt, 'V') != 0
          || strchr (fmt, 'S') != 0
          || strchr (fmt, 'n') != 0);
}

main()
{
  if (special_format ("ee"))
    abort ();
  if (!special_format ("*e"))
    abort ();
  exit (0);
}
// source: 20000113-1.c
struct x {
  unsigned x1:1;
  unsigned x2:2;
  unsigned x3:3;
};

foobar (int x, int y, int z)
{
  struct x a = {x, y, z};
  struct x b = {x, y, z};
  struct x *c = &b;

  c->x3 += (a.x2 - a.x1) * c->x2;
  if (a.x1 != 1 || c->x3 != 5)
    abort ();
  exit (0);
}

main()
{
  foobar (1, 2, 3);
}
// source: 20000121-1.c
void big(long long u) { }

void doit(unsigned int a,unsigned int b,char *id)
{
  big(*id);
  big(a);
  big(b);
}

int main(void)
{
  doit(1,1,"\n");
  return 0;
}
// source: 20000205-1.c
static int f (int a)
{
  if (a == 0)
    return 0;
  do
    if (a & 128)
      return 1;
  while (f (0));
  return 0;
}

int main(void)
{
  if (f (~128))
    abort ();
  exit (0);
}
// source: 20000217-1.c
unsigned short int showbug(unsigned short int *a, unsigned short int *b)
{
        *a += *b -8;
        return (*a >= 8);
}

int main()
{
        unsigned short int x = 0;
        unsigned short int y = 10;

        if (showbug(&x, &y) != 0)
	  abort ();

	exit (0);
}
// source: 20000223-1.c
/* Copyright (C) 2000 Free Software Foundation, Inc.
   Contributed by Nathan Sidwell 23 Feb 2000 <nathan@codesourcery.com> */

/* __alignof__ should never return a non-power of 2
   eg, sizeof(long double) might be 12, but that means it must be alignable
   on a 4 byte boundary. */

void check (char const *type, int align)
{
  if ((align & -align) != align)
    {
      abort ();
    }
}

#define QUOTE_(s) #s
#define QUOTE(s) QUOTE_(s)

#define check(t) check(QUOTE(t), __alignof__(t))

// This struct should have an alignment of the lcm of all the types. If one of
// the base alignments is not a power of two, then A cannot be power of two
// aligned.
struct A
{
  char c;
  signed short ss;
  unsigned short us;
  signed int si;
  unsigned int ui;
  signed long sl;
  unsigned long ul;
  signed long long sll;
  unsigned long long ull;
  float f;
  double d;
  long double ld;
  void *dp;
  void (*fp)();
};

int main ()
{
  check (void);
  check (char);
  check (signed short);
  check (unsigned short);
  check (signed int);
  check (unsigned int);
  check (signed long);
  check (unsigned long);
  check (signed long long);
  check (unsigned long long);
  check (float);
  check (double);
  check (long double);
  check (void *);
  check (void (*)());
  check (struct A);
  return 0;
}
// source: 20000224-1.c
int loop_1 = 100;
int loop_2 = 7;
int flag = 0;

int test (void)
{
    int i;
    int counter  = 0;

    while (loop_1 > counter) {
        if (flag & 1) {
            for (i = 0; i < loop_2; i++) {
                counter++;
            }
        }
        flag++;
    }
    return 1;
}

int main()
{
    if (test () != 1)
      abort ();

    exit (0);
}
// source: 20000225-1.c
int main ()
{
    int nResult;
    int b=0;
    int i = -1;

    do
    {
     if (b!=0) {
       abort ();
       nResult=1;
     } else {
      nResult=0;
     }
     i++;
     b=(i+2)*4;
    } while (i < 0);
    exit (0);
}
// source: 20000227-1.c
static const unsigned char f[] = "\0\377";
static const unsigned char g[] = "\0Ë‡";

int main(void)
{
  if (sizeof f != 3 || sizeof g != 3)
    abort ();
  if (f[0] != g[0])
    abort ();
  if (f[1] != g[1])
    abort ();
  if (f[2] != g[2])
    abort ();
  return 0;
}
// source: 20000313-1.c
unsigned int buggy (unsigned int *param)
{
  unsigned int accu, zero = 0, borrow;
  accu    = - *param;
  borrow  = - (accu > zero);
  *param += accu;
  return borrow;
}

int main (void)
{
  unsigned int param  = 1;
  unsigned int borrow = buggy (&param);

  if (param != 0)
    abort ();
  if (borrow + 1 != 0)
    abort ();
  return 0;
}
// source: 20000314-1.c
int main ()
{
  long winds = 0;

  while (winds != 0)
    {
      if (*(char *) winds)
	break;
    }

  if (winds == 0 || winds != 0 || *(char *) winds)
    exit (0);

  abort ();
}
// source: 20000314-2.c
typedef unsigned long long uint64;
const uint64 bigconst = 1ULL << 34;

int a = 1;

static
uint64 getmask(void)
{
    if (a)
      return bigconst;
    else
      return 0;
}

main()
{
    uint64 f = getmask();
    if (sizeof (long long) == 8
	&& f != bigconst) abort ();
    exit (0);
}
// source: 20000314-3.c
extern void abort (void);

static char arg0[] = "arg0";
static char arg1[] = "arg1";

static void attr_rtx		(char *, char *);
static char *attr_string        (char *);
static void attr_eq		(char *, char *);

static void
attr_rtx (char *varg0, char *varg1)
{
  if (varg0 != arg0)
    abort ();

  if (varg1 != arg1)
    abort ();

  return;
}

static void
attr_eq (name, value)
     char *name, *value;
{
  return attr_rtx (attr_string (name),
		   attr_string (value));
}

static char *
attr_string (str)
     char *str;
{
  return str;
}

int main()
{
  attr_eq (arg0, arg1);
  exit (0);
}
// source: 20000402-1.c
#include <limits.h>

#if ULONG_LONG_MAX != 18446744073709551615ull && ULONG_MAX != 18446744073709551615ull
int main(void) { exit (0); }
#else
#if ULONG_MAX != 18446744073709551615ull
typedef unsigned long long ull;
#else
typedef unsigned long ull;
#endif

#include <stdio.h>

void checkit(int);

main () {
    const ull a = 0x1400000000ULL;
    const ull b = 0x80000000ULL;
    const ull c = a/b;
    const ull d = 0x1400000000ULL / 0x80000000ULL;

    checkit ((int) c);
    checkit ((int) d);

    exit(0);
}

void checkit (int a)
{
  if (a != 40)
    abort();
}
#endif
// source: 20000403-1.c
extern unsigned long aa[], bb[];

int seqgt (unsigned long a, unsigned short win, unsigned long b);

int seqgt2 (unsigned long a, unsigned short win, unsigned long b);

main()
{
  if (! seqgt (*aa, 0x1000, *bb) || ! seqgt2 (*aa, 0x1000, *bb))
    abort ();

  exit (0);
}

int
seqgt (unsigned long a, unsigned short win, unsigned long b)
{
  return (long) ((a + win) - b) > 0;
}

int
seqgt2 (unsigned long a, unsigned short win, unsigned long b)
{
  long l = ((a + win) - b);
  return l > 0;
}

unsigned long aa[] = { (1UL << (sizeof (long) * 8 - 1)) - 0xfff };
unsigned long bb[] = { (1UL << (sizeof (long) * 8 - 1)) - 0xfff };
// source: 20000412-1.c
short int i = -1;
const char * const wordlist[207];

const char * const *
foo(void)
{
  register const char * const *wordptr = &wordlist[207u + i];
  return wordptr;
}

int
main()
{
  if (foo() != &wordlist[206])
    abort ();
  exit(0);
}
// source: 20000412-2.c
int f(int a,int *y)
{
  int x = a;

  if (a==0)
    return *y;

  return f(a-1,&x);
}

int main(int argc,char **argv)
{
  if (f (100, (int *) 0) != 1)
    abort ();
  exit (0);
}
// source: 20000412-3.c
typedef struct {
  char y;
  char x[32];
} X;

int z (void)
{
  X xxx;
  xxx.x[0] =
  xxx.x[31] = '0';
  xxx.y = 0xf;
  return f (xxx, xxx);
}

int main (void)
{
  int val;

  val = z ();
  if (val != 0x60)
    abort ();
  exit (0);
}

int f(X x, X y)
{
  if (x.y != y.y)
    return 'F';

  return x.x[0] + y.x[0];
}
// source: 20000412-4.c
  void f(int i, int j, int radius, int width, int N)
  {
    const int diff   = i-radius;
    const int lowk   = (diff>0 ? diff : 0 );
    int k;

    for(k=lowk; k<= 2; k++){
      int idx = ((k-i+radius)*width-j+radius);
      if (idx < 0)
	abort ();
    }

    for(k=lowk; k<= 2; k++);
  }


  int main(int argc, char **argv)
  {
    int exc_rad=2;
    int N=8;
    int i;
    for(i=1; i<4; i++)
      f(i,1,exc_rad,2*exc_rad + 1, N);
    exit (0);
  }
// source: 20000412-5.c
int main( void ) {
    struct {
	int node;
	int type;
    } lastglob[1] = { { 0   , 1  } };

    if (lastglob[0].node != 0 || lastglob[0].type != 1)
      abort ();
    exit (0);
}
// source: 20000412-6.c
unsigned bug (unsigned short value, unsigned short *buffer,
              unsigned short *bufend);

unsigned short buf[] = {1, 4, 16, 64, 256};
int main()
{
  if (bug (512, buf, buf + 3) != 491)
    abort ();

  exit (0);
}

unsigned
bug (unsigned short value, unsigned short *buffer, unsigned short *bufend)
{
  unsigned short *tmp;

  for (tmp = buffer; tmp < bufend; tmp++)
    value -= *tmp;

  return value;
}
// source: 20000419-1.c
struct foo { int a, b, c; };

void
brother (int a, int b, int c)
{
  if (a)
    abort ();
}

void
sister (struct foo f, int b, int c)
{
  brother ((f.b == b), b, c);
}

int
main ()
{
  struct foo f = { 7, 8, 9 };
  sister (f, 1, 2);
  exit (0);
}
// source: 20000422-1.c
int ops[13] =
{
  11, 12, 46, 3, 2, 2, 3, 2, 1, 3, 2, 1, 2
};

int correct[13] =
{
  46, 12, 11, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1
};

int num = 13;

int main()
{
  int i;

  for (i = 0; i < num; i++)
    {
      int j;

      for (j = num - 1; j > i; j--)
        {
          if (ops[j-1] < ops[j])
            {
              int op = ops[j];
              ops[j] = ops[j-1];
              ops[j-1] = op;
            }
        }
    }


  for (i = 0; i < num; i++)
    if (ops[i] != correct[i])
      abort ();

  exit (0);
}
// source: 20000503-1.c
unsigned long
sub (int a)
{
  return ((0 > a - 2) ? 0 : a - 2) * sizeof (long);
}

main ()
{
  if (sub (0) != 0)
    abort ();

  exit (0);
}
// source: 20000511-1.c
void f (int value, int expect)
{
  if (value != expect)
    abort ();
}

int main()
{
  int a = 7, b = 6, c = 4, d = 7, e = 2;

  f (a||b%c,   1);
  f (a?b%c:0,  2);
  f (a=b%c,    2);
  f (a*=b%c,   4);
  f (a/=b%c,   2);
  f (a%=b%c,   0);
  f (a+=b%c,   2);
  f (d||c&&e,  1);
  f (d?c&&e:0, 1);
  f (d=c&&e,   1);
  f (d*=c&&e,  1);
  f (d%=c&&e,  0);
  f (d+=c&&e,  1);
  f (d-=c&&e,  0);
  f (d||c||e,  1);
  f (d?c||e:0, 0);
  f (d=c||e,   1);
  f (d*=c||e,  1);
  f (d%=c||e,  0);
  f (d+=c||e,  1);
  f (d-=c||e,  0);
  exit (0);
}
// source: 20000519-1.c
#include <stdarg.h>

int
bar (int a, va_list ap)
{
  int b;

  do
    b = va_arg (ap, int);
  while (b > 10);

  return a + b;
}

int
foo (int a, ...)
{
  va_list ap;

  va_start (ap, a);
  return bar (a, ap);
}

int
main ()
{
  if (foo (1, 2, 3) != 3)
    abort ();
  return 0;
}
// source: 20000519-2.c
long x = -1L;

int main()
{
  long b = (x != -1L);

  if (b)
    abort();

  exit(0);
}
// source: 20000523-1.c
int
main (void)
{
  long long   x;
  int         n;

  if (sizeof (long long) < 8)
    exit (0);

  n = 9;
  x = (((long long) n) << 55) / 0xff;

  if (x == 0)
    abort ();

  x = (((long long) 9) << 55) / 0xff;

  if (x == 0)
    abort ();

  exit (0);
}
// source: 20000528-1.c
/* Copyright (C) 2000  Free Software Foundation  */
/* Contributed by Alexandre Oliva <aoliva@cygnus.com> */

unsigned long l = (unsigned long)-2;
unsigned short s;

int main () {
  long t = l;
  s = t;
  if (s != (unsigned short)-2)
    abort ();
  exit (0);
}
// source: 20000603-1.c
/* It is not clear whether this test is conforming.  See DR#236
   http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_236.htm.  However,
   there seems to be consensus that the presence of a union to aggregate
   struct s1 and struct s2 should make it conforming.  */
struct s1 { double d; };
struct s2 { double d; };
union u { struct s1 x; struct s2 y; };

double f(struct s1 *a, struct s2 *b)
{
  a->d = 1.0;
  return b->d + 1.0;
}

int main()
{
  union u a;
  a.x.d = 0.0;
  if (f (&a.x, &a.y) != 2.0)
    abort ();
  return 0;
}
// source: 20000605-1.c
typedef struct _RenderInfo RenderInfo;
struct _RenderInfo
{
    int y;
    float scaley;
    int src_y;
};

static void bar(void) { }

static int
render_image_rgb_a (RenderInfo * info)
{
  int y, ye;
  float error;
  float step;

  y = info->y;
  ye = 256;

  step = 1.0 / info->scaley;

  error = y * step;
  error -= ((int) error) - step;

  for (; y < ye; y++) {
      if (error >= 1.0) {
	  info->src_y += (int) error;
	  error -= (int) error;
	  bar();
      }
      error += step;
  }
  return info->src_y;
}

int main (void)
{
    RenderInfo info;

    info.y = 0;
    info.src_y = 0;
    info.scaley = 1.0;

    if (render_image_rgb_a(&info) != 256)
       abort ();
    exit(0);
}
// source: 20000605-2.c
struct F { int i; };

void f1(struct F *x, struct F *y)
{
  int timeout = 0;
  for (; ((const struct F*)x)->i < y->i ; x->i++)
    if (++timeout > 5)
      abort ();
}

main()
{
  struct F x, y;
  x.i = 0;
  y.i = 1;
  f1 (&x, &y);
  exit (0);
}
// source: 20000605-3.c
struct F { int x; int y; };

int main()
{
  int timeout = 0;
  int x = 0;
  while (1)
    {
      const struct F i = { x++, };
      if (i.x > 0)
	break;
      if (++timeout > 5)
	goto die;
    }
  return 0;
 die:
  abort ();
}
// source: 20000622-1.c
long foo(long a, long b, long c)
{
  if (a != 12 || b != 1 || c != 11)
    abort();
  return 0;
}
long bar (long a, long b)
{
  return b;
}
void baz (long a, long b, void *c)
{
  long d;
  d = (long)c;
  foo(d, bar (a, 1), b);
}
int main()
{
  baz (10, 11, (void *)12);
  exit(0);
}
// source: 20000703-1.c
void abort(void);
void exit(int);
struct baz
{
  char a[17];
  char b[3];
  unsigned int c;
  unsigned int d;
};

void foo(struct baz *p, unsigned int c, unsigned int d)
{
  __builtin_memcpy (p->b, "abc", 3);
  p->c = c;
  p->d = d;
}

void bar(struct baz *p, unsigned int c, unsigned int d)
{
  ({ void *s = (p);
     __builtin_memset (s, '\0', sizeof (struct baz));
     s; });
  __builtin_memcpy (p->a, "01234567890123456", 17);
  __builtin_memcpy (p->b, "abc", 3);
  p->c = c;
  p->d = d;
}

int main()
{
  struct baz p;
  foo(&p, 71, 18);
  if (p.c != 71 || p.d != 18)
    abort();
  bar(&p, 59, 26);
  if (p.c != 59 || p.d != 26)
    abort();
  exit(0);
}
// source: 20000706-1.c
extern void abort(void);
extern void exit(int);

struct baz {
  int a, b, c, d, e;
};

void bar(struct baz *x, int f, int g, int h, int i, int j)
{
  if (x->a != 1 || x->b != 2 || x->c != 3 || x->d != 4 || x->e != 5 ||
      f != 6 || g != 7 || h != 8 || i != 9 || j != 10)
    abort();
}

void foo(struct baz x, char **y)
{
  bar(&x,6,7,8,9,10);
}

int main()
{
  struct baz x;

  x.a = 1;
  x.b = 2;
  x.c = 3;
  x.d = 4;
  x.e = 5;
  foo(x,(char **)0);
  exit(0);
}
// source: 20000706-2.c
extern void abort(void);
extern void exit(int);

struct baz {
  int a, b, c, d, e;
};

void bar(struct baz *x, int f, int g, int h, int i, int j)
{
  if (x->a != 1 || x->b != 2 || x->c != 3 || x->d != 4 || x->e != 5 ||
      f != 6 || g != 7 || h != 8 || i != 9 || j != 10)
    abort();
}

void foo(char *z, struct baz x, char *y)
{
  bar(&x,6,7,8,9,10);
}

int main()
{
  struct baz x;

  x.a = 1;
  x.b = 2;
  x.c = 3;
  x.d = 4;
  x.e = 5;
  foo((char *)0,x,(char *)0);
  exit(0);
}
// source: 20000706-3.c
extern void abort(void);
extern void exit(int);

int c;

void baz(int *p)
{
  c = *p;
}

void bar(int b)
{
  if (c != 1 || b != 2)
    abort();
}

void foo(int a, int b)
{
  baz(&a);
  bar(b);
}

int main()
{
  foo(1, 2);
  exit(0);
}
// source: 20000706-4.c
extern void abort(void);
extern void exit(int);

int *c;

void bar(int b)
{
  if (*c != 1 || b != 2)
    abort();
}

void foo(int a, int b)
{
  c = &a;
  bar(b);
}

int main()
{
  foo(1, 2);
  exit(0);
}
// source: 20000706-5.c
extern void abort(void);
extern void exit(int);

struct baz { int a, b, c; };

struct baz *c;

void bar(int b)
{
  if (c->a != 1 || c->b != 2 || c->c != 3 || b != 4)
    abort();
}

void foo(struct baz a, int b)
{
  c = &a;
  bar(b);
}

int main()
{
  struct baz a;
  a.a = 1;
  a.b = 2;
  a.c = 3;
  foo(a, 4);
  exit(0);
}
// source: 20000707-1.c
extern void abort(void);
extern void exit(int);

struct baz {
  int a, b, c;
};

void
foo (int a, int b, int c)
{
  if (a != 4)
    abort ();
}

void
bar (struct baz x, int b, int c)
{
  foo (x.b, b, c);
}

int
main ()
{
  struct baz x = { 3, 4, 5 };
  bar (x, 1, 2);
  exit (0);
}
// source: 20000715-1.c
void abort(void);
void exit(int);

void
test1(void)
{
  int x = 3, y = 2;

  if ((x < y ? x++ : y++) != 2)
    abort ();

  if (x != 3)
    abort ();

  if (y != 3)
    abort ();
}

void
test2(void)
{
  int x = 3, y = 2, z;

  z = (x < y) ? x++ : y++;
  if (z != 2)
    abort ();

  if (x != 3)
    abort ();

  if (y != 3)
    abort ();
}

void
test3(void)
{
  int x = 3, y = 2;
  int xx = 3, yy = 2;

  if ((xx < yy ? x++ : y++) != 2)
    abort ();

  if (x != 3)
    abort ();

  if (y != 3)
    abort ();
}

int x, y;

static void
init_xy(void)
{
  x = 3;
  y = 2;
}

void
test4(void)
{
  init_xy();
  if ((x < y ? x++ : y++) != 2)
    abort ();

  if (x != 3)
    abort ();

  if (y != 3)
    abort ();
}

void
test5(void)
{
  int z;

  init_xy();
  z = (x < y) ? x++ : y++;
  if (z != 2)
    abort ();

  if (x != 3)
    abort ();

  if (y != 3)
    abort ();
}

void
test6(void)
{
  int xx = 3, yy = 2;
  int z;

  init_xy();
  z = (xx < y) ? x++ : y++;
  if (z != 2)
    abort ();

  if (x != 3)
    abort ();

  if (y != 3)
    abort ();
}

int
main(){
  test1 ();
  test2 ();
  test3 ();
  test4 ();
  test5 ();
  test6 ();
  exit (0);
}
// source: 20000715-2.c
extern void abort(void);
extern void exit(int);

unsigned int foo(unsigned int a)
{
  return ((unsigned char)(a + 1)) * 4;
}

int main(void)
{
  if (foo((unsigned char)~0))
    abort ();
  exit(0);
}
// source: 20000717-1.c
typedef struct trio { int a, b, c; } trio;

int
bar (int i, trio t)
{
  if (t.a == t.b || t.a == t.c)
    abort ();
}

int
foo (trio t, int i)
{
  return bar (i, t);
}

main ()
{
  trio t = { 1, 2, 3 };

  foo (t, 4);
  exit (0);
}
// source: 20000717-2.c
static void
compare (long long foo)
{
  if (foo < 4294967297LL)
    abort();
}
int main(void)
{
  compare (8589934591LL);
  exit (0);
}
// source: 20000717-3.c
int c = -1;

foo (p)
     int *p;
{
  int x;
  int a;

  a = p[0];
  x = a + 5;
  a = c;
  p[0] = x - 15;
  return a;
}

int main()
{
   int b = 1;
   int a = foo(&b);

   if (a != -1 || b != (1 + 5 - 15))
     abort ();

   exit (0);
}
// source: 20000717-4.c
/* Extracted from gas.  Incorrectly generated non-pic code at -O0 for
   IA-64, which produces linker errors on some operating systems.  */

struct
{
  int offset;
  struct slot
  {
    int field[6];
  }
  slot[4];
} s;

int
x ()
{
  int toggle = 0;
  int r = s.slot[0].field[!toggle];
  return r;
}

int
main ()
{
  return 0;
}
// source: 20000717-5.c
typedef struct trio { int a, b, c; } trio;

int
bar (int i, int j, int k, trio t)
{
  if (t.a != 1 || t.b != 2 || t.c != 3 ||
      i != 4 || j != 5 || k != 6)
    abort ();
}

int
foo (trio t, int i, int j, int k)
{
  return bar (i, j, k, t);
}

main ()
{
  trio t = { 1, 2, 3 };

  foo (t, 4, 5, 6);
  exit (0);
}
// source: 20000722-1.c
struct s { char *p; int t; };

extern void bar (void);
extern void foo (struct s *);

int main(void)
{
  bar ();
  bar ();
  exit (0);
}

void
bar (void)
{
  foo (& (struct s) { "hi", 1 });
}

void foo (struct s *p)
{
  if (p->t != 1)
    abort();
  p->t = 2;
}
// source: 20000726-1.c
void adjust_xy (short *, short *);

struct adjust_template
{
  short kx_x;
  short kx_y;
  short kx;
  short kz;
};

static struct adjust_template adjust = {0, 0, 1, 1};

main ()
{
  short x = 1, y = 1;

  adjust_xy (&x, &y);

  if (x != 1)
    abort ();

  exit (0);
}

void
adjust_xy (x, y)
     short  *x;
     short  *y;
{
  *x = adjust.kx_x * *x + adjust.kx_y * *y + adjust.kx;
}
// source: 20000731-1.c
double
foo (void)
{
  return 0.0;
}

void
do_sibcall (void)
{
  (void) foo ();
}

int
main (void)
{
   double x;

   for (x = 0; x < 20; x++)
      do_sibcall ();
   if (!(x >= 10))
      abort ();
   exit (0);
}
// source: 20000731-2.c
int
main()
{
    int i = 1;
    int j = 0;

    while (i != 1024 || j <= 0) {
        i *= 2;
        ++ j;
    }

    if (j != 10)
      abort ();

    exit (0);
}
// source: 20000801-1.c
extern void abort(void);
extern void exit(int);

void
foo (char *bp, unsigned n)
{
  register char c;
  register char *ep = bp + n;
  register char *sp;

  while (bp < ep)
    {
      sp = bp + 3;
      c = *sp;
      *sp = *bp;
      *bp++ = c;
      sp = bp + 1;
      c = *sp;
      *sp = *bp;
      *bp++ = c;
      bp += 2;
    }
}

int main(void)
{
  int one = 1;

  if (sizeof(int) != 4 * sizeof(char))
    exit(0);

  foo((char *)&one, sizeof(one));
  foo((char *)&one, sizeof(one));

  if (one != 1)
    abort();

  exit(0);
}
// source: 20000801-2.c
extern void abort(void);
extern void exit(int);
int bar(void);
int baz(void);

struct foo {
  struct foo *next;
};

struct foo *test(struct foo *node)
{
  while (node) {
    if (bar() && !baz())
      break;
    node = node->next;
  }
  return node;
}

int bar (void)
{
  return 0;
}

int baz (void)
{
  return 0;
}

int main(void)
{
  struct foo a, b, *c;

  a.next = &b;
  b.next = (struct foo *)0;
  c = test(&a);
  if (c)
    abort();
  exit (0);
}
// source: 20000801-3.c
/* Origin: PR c/92 from Simon Marlow <t-simonm@microsoft.com>, adapted
   to a testcase by Joseph Myers <jsm28@cam.ac.uk>.
*/

typedef struct { } empty;

typedef struct {
  int i;
  empty e;
  int i2;
} st;

st s = { .i = 0, .i2 = 1 };

extern void abort (void);

int
main (void)
{
  if (s.i2 == 1)
    exit (0);
  else
    abort ();
}
// source: 20000801-4.c
/* Origin: PR c/128 from Martin Sebor <sebor@roguewave.com>, adapted
   as a testcase by Joseph Myers <jsm28@cam.ac.uk>.
*/
/* Character arrays initialized by a string literal must have
   uninitialized elements zeroed.  This isn't clear in the 1990
   standard, but was fixed in TC2 and C99; see DRs #060, #092.
*/
extern void abort (void);

int
foo (void)
{
  char s[2] = "";
  return 0 == s[1];
}

char *t;

int
main (void)
{
  {
    char s[] = "x";
    t = s;
  }
  if (foo ())
    exit (0);
  else
    abort ();
}
// source: 20000808-1.c
typedef struct {
  long int p_x, p_y;
} Point;

void
bar ()
{
}

void
f (p0, p1, p2, p3, p4, p5)
     Point p0, p1, p2, p3, p4, p5;
{
  if (p0.p_x != 0 || p0.p_y != 1
      || p1.p_x != -1 || p1.p_y != 0
      || p2.p_x != 1 || p2.p_y != -1
      || p3.p_x != -1 || p3.p_y != 1
      || p4.p_x != 0 || p4.p_y != -1
      || p5.p_x != 1 || p5.p_y != 0)
    abort ();
}

void
foo ()
{
  Point p0, p1, p2, p3, p4, p5;

  bar();

  p0.p_x = 0;
  p0.p_y = 1;

  p1.p_x = -1;
  p1.p_y = 0;

  p2.p_x = 1;
  p2.p_y = -1;

  p3.p_x = -1;
  p3.p_y = 1;

  p4.p_x = 0;
  p4.p_y = -1;

  p5.p_x = 1;
  p5.p_y = 0;

  f (p0, p1, p2, p3, p4, p5);
}

int
main()
{
  foo();
  exit(0);
}
// source: 20000815-1.c
struct table_elt
{
  void *exp;
  struct table_elt *next_same_hash;
  struct table_elt *prev_same_hash;
  struct table_elt *next_same_value;
  struct table_elt *prev_same_value;
  struct table_elt *first_same_value;
  struct table_elt *related_value;
  int cost;
  int mode;
  char in_memory;
  char in_struct;
  char is_const;
  char flag;
};

struct write_data
{
  int sp : 1;
  int var : 1;
  int nonscalar : 1;
  int all : 1;
};

int cse_rtx_addr_varies_p(void *);
void remove_from_table(struct table_elt *, int);
static struct table_elt *table[32];

void
invalidate_memory (writes)
     struct write_data *writes;
{
  register int i;
  register struct table_elt *p, *next;
  int all = writes->all;
  int nonscalar = writes->nonscalar;

  for (i = 0; i < 31; i++)
    for (p = table[i]; p; p = next)
      {
	next = p->next_same_hash;
	if (p->in_memory
	    && (all
		|| (nonscalar && p->in_struct)
		|| cse_rtx_addr_varies_p (p->exp)))
	  remove_from_table (p, i);
      }
}

int cse_rtx_addr_varies_p(void *x) { return 0; }
void remove_from_table(struct table_elt *x, int y) { abort (); }

int
main()
{
  struct write_data writes;
  struct table_elt elt;

  __builtin_memset(&elt, 0, sizeof(elt));
  elt.in_memory = 1;
  table[0] = &elt;

  __builtin_memset(&writes, 0, sizeof(writes));
  writes.var = 1;
  writes.nonscalar = 1;

  invalidate_memory(&writes);
  return 0;
}
// source: 20000818-1.c
/* Copyright (C) 2000  Free Software Foundation.

   by Manfred Hollstein <manfredh@redhat.com>  */

void *temporary_obstack;

static int input (void);
static int ISALNUM (int ch);
static void obstack_1grow (void **ptr, int ch);

int yylex (void);
int main (void);

int main (void)
{
  int ch = yylex ();

  exit (0);
}

int yylex (void)
{
  int ch;

#ifndef WORK_AROUND
  for (;;)
    {
      ch = input ();
      if (ISALNUM (ch))
        obstack_1grow (&temporary_obstack, ch);
      else if (ch != '_')
        break;
    }
#else
  do
    {
      ch = input ();
      if (ISALNUM (ch))
        obstack_1grow (&temporary_obstack, ch);
    } while (ch == '_');
#endif

  return ch;
}

static int input (void)
{
  return 0;
}

static int ISALNUM (int ch)
{
  return ((ch >= 'A' && ch <= 'Z')
	  || (ch >= 'a' && ch <= 'z')
	  || (ch >= '0' && ch <= '0'));
}

static void obstack_1grow (void **ptr, int ch)
{
}
// source: 20000819-1.c
int a[2] = { 2, 0 };

void foo(int *sp, int cnt)
{
  int *p, *top;

  top = sp; sp -= cnt;

  for(p = sp; p <= top; p++)
    if (*p < 2) exit(0);
}

int main()
{
  foo(a + 1, 1);
  abort();
}
// source: 20000822-1.c
/* { dg-require-effective-target trampolines } */

int f0(int (*fn)(int *), int *p)
{
  return (*fn) (p);
}

int f1(void)
{
  int i = 0;

  int f2(int *p)
  {
    i = 1;
    return *p + 1;
  }

  return f0(f2, &i);
}

int main()
{
  if (f1() != 2)
    abort ();

  return 0;
}
// source: 20000910-1.c
/* Copyright (C) 2000  Free Software Foundation  */
/* by Alexandre Oliva <aoliva@redhat.com> */

#include <stdlib.h>

void bar (int);
void foo (int *);

int main () {
  static int a[] = { 0, 1, 2 };
  int *i = &a[sizeof(a)/sizeof(*a)];

  while (i-- > a)
    foo (i);

  exit (0);
}

void baz (int, int);

void bar (int i) { baz (i, i); }
void foo (int *i) { bar (*i); }

void baz (int i, int j) {
  if (i != j)
    abort ();
}
// source: 20000910-2.c
/* Copyright (C) 2000  Free Software Foundation  */
/* by Alexandre Oliva <aoliva@redhat.com> */

#include <stdlib.h>
#include <string.h>

char *list[] = { "*", "e" };

static int bar (const char *fmt) {
  return (strchr (fmt, '*') != 0);
}

static void foo () {
  int i;
  for (i = 0; i < sizeof (list) / sizeof (*list); i++) {
    const char *fmt = list[i];
    if (bar (fmt))
      continue;
    if (i == 0)
      abort ();
    else
      exit (0);
  }
}

int main () {
  foo ();
}
// source: 20000914-1.c
extern void *malloc(__SIZE_TYPE__);

enum tree_code {
ERROR_MARK,
IDENTIFIER_NODE,
OP_IDENTIFIER,
TREE_LIST,
TREE_VEC,
BLOCK,
VOID_TYPE,
INTEGER_TYPE,
REAL_TYPE,
COMPLEX_TYPE,
VECTOR_TYPE,
ENUMERAL_TYPE,
BOOLEAN_TYPE,
CHAR_TYPE,
POINTER_TYPE,
OFFSET_TYPE,
REFERENCE_TYPE,
METHOD_TYPE,
FILE_TYPE,
ARRAY_TYPE,
SET_TYPE,
RECORD_TYPE,
UNION_TYPE,
QUAL_UNION_TYPE,
FUNCTION_TYPE,
LANG_TYPE,
INTEGER_CST,
REAL_CST,
COMPLEX_CST,
STRING_CST,
FUNCTION_DECL,
LABEL_DECL,
CONST_DECL,
TYPE_DECL,
VAR_DECL,
PARM_DECL,
RESULT_DECL,
FIELD_DECL,
NAMESPACE_DECL,
COMPONENT_REF,
BIT_FIELD_REF,
INDIRECT_REF,
BUFFER_REF,
ARRAY_REF,
CONSTRUCTOR,
COMPOUND_EXPR,
MODIFY_EXPR,
INIT_EXPR,
TARGET_EXPR,
COND_EXPR,
BIND_EXPR,
CALL_EXPR,
METHOD_CALL_EXPR,
WITH_CLEANUP_EXPR,
CLEANUP_POINT_EXPR,
PLACEHOLDER_EXPR,
WITH_RECORD_EXPR,
PLUS_EXPR,
MINUS_EXPR,
MULT_EXPR,
TRUNC_DIV_EXPR,
CEIL_DIV_EXPR,
FLOOR_DIV_EXPR,
ROUND_DIV_EXPR,
TRUNC_MOD_EXPR,
CEIL_MOD_EXPR,
FLOOR_MOD_EXPR,
ROUND_MOD_EXPR,
RDIV_EXPR,
EXACT_DIV_EXPR,
FIX_TRUNC_EXPR,
FIX_CEIL_EXPR,
FIX_FLOOR_EXPR,
FIX_ROUND_EXPR,
FLOAT_EXPR,
EXPON_EXPR,
NEGATE_EXPR,
MIN_EXPR,
MAX_EXPR,
ABS_EXPR,
FFS_EXPR,
LSHIFT_EXPR,
RSHIFT_EXPR,
LROTATE_EXPR,
RROTATE_EXPR,
BIT_IOR_EXPR,
BIT_XOR_EXPR,
BIT_AND_EXPR,
BIT_ANDTC_EXPR,
BIT_NOT_EXPR,
TRUTH_ANDIF_EXPR,
TRUTH_ORIF_EXPR,
TRUTH_AND_EXPR,
TRUTH_OR_EXPR,
TRUTH_XOR_EXPR,
TRUTH_NOT_EXPR,
LT_EXPR,
LE_EXPR,
GT_EXPR,
GE_EXPR,
EQ_EXPR,
NE_EXPR,
UNORDERED_EXPR,
ORDERED_EXPR,
UNLT_EXPR,
UNLE_EXPR,
UNGT_EXPR,
UNGE_EXPR,
UNEQ_EXPR,
IN_EXPR,
SET_LE_EXPR,
CARD_EXPR,
RANGE_EXPR,
CONVERT_EXPR,
NOP_EXPR,
NON_LVALUE_EXPR,
SAVE_EXPR,
UNSAVE_EXPR,
RTL_EXPR,
ADDR_EXPR,
REFERENCE_EXPR,
ENTRY_VALUE_EXPR,
COMPLEX_EXPR,
CONJ_EXPR,
REALPART_EXPR,
IMAGPART_EXPR,
PREDECREMENT_EXPR,
PREINCREMENT_EXPR,
POSTDECREMENT_EXPR,
POSTINCREMENT_EXPR,
VA_ARG_EXPR,
TRY_CATCH_EXPR,
TRY_FINALLY_EXPR,
GOTO_SUBROUTINE_EXPR,
POPDHC_EXPR,
POPDCC_EXPR,
LABEL_EXPR,
GOTO_EXPR,
RETURN_EXPR,
EXIT_EXPR,
LOOP_EXPR,
LABELED_BLOCK_EXPR,
EXIT_BLOCK_EXPR,
EXPR_WITH_FILE_LOCATION,
SWITCH_EXPR,
  LAST_AND_UNUSED_TREE_CODE
};
typedef union tree_node *tree;
struct tree_common
{
  union tree_node *chain;
  union tree_node *type;
  enum tree_code code : 8;
  unsigned side_effects_flag : 1;
  unsigned constant_flag : 1;
  unsigned permanent_flag : 1;
  unsigned addressable_flag : 1;
  unsigned volatile_flag : 1;
  unsigned readonly_flag : 1;
  unsigned unsigned_flag : 1;
  unsigned asm_written_flag: 1;
  unsigned used_flag : 1;
  unsigned nothrow_flag : 1;
  unsigned static_flag : 1;
  unsigned public_flag : 1;
  unsigned private_flag : 1;
  unsigned protected_flag : 1;
  unsigned bounded_flag : 1;
  unsigned lang_flag_0 : 1;
  unsigned lang_flag_1 : 1;
  unsigned lang_flag_2 : 1;
  unsigned lang_flag_3 : 1;
  unsigned lang_flag_4 : 1;
  unsigned lang_flag_5 : 1;
  unsigned lang_flag_6 : 1;
};
union tree_node
{
  struct tree_common common;
 };
enum c_tree_code {
  C_DUMMY_TREE_CODE = LAST_AND_UNUSED_TREE_CODE,
SRCLOC,
SIZEOF_EXPR,
ARROW_EXPR,
ALIGNOF_EXPR,
EXPR_STMT,
COMPOUND_STMT,
DECL_STMT,
IF_STMT,
FOR_STMT,
WHILE_STMT,
DO_STMT,
RETURN_STMT,
BREAK_STMT,
CONTINUE_STMT,
SWITCH_STMT,
GOTO_STMT,
LABEL_STMT,
ASM_STMT,
SCOPE_STMT,
CASE_LABEL,
STMT_EXPR,
  LAST_C_TREE_CODE
};
enum cplus_tree_code {
  CP_DUMMY_TREE_CODE = LAST_C_TREE_CODE,
OFFSET_REF,
PTRMEM_CST,
NEW_EXPR,
VEC_NEW_EXPR,
DELETE_EXPR,
VEC_DELETE_EXPR,
SCOPE_REF,
MEMBER_REF,
TYPE_EXPR,
AGGR_INIT_EXPR,
THROW_EXPR,
EMPTY_CLASS_EXPR,
TEMPLATE_DECL,
TEMPLATE_PARM_INDEX,
TEMPLATE_TYPE_PARM,
TEMPLATE_TEMPLATE_PARM,
BOUND_TEMPLATE_TEMPLATE_PARM,
TYPENAME_TYPE,
TYPEOF_TYPE,
USING_DECL,
DEFAULT_ARG,
TEMPLATE_ID_EXPR,
CPLUS_BINDING,
OVERLOAD,
WRAPPER,
LOOKUP_EXPR,
FUNCTION_NAME,
MODOP_EXPR,
CAST_EXPR,
REINTERPRET_CAST_EXPR,
CONST_CAST_EXPR,
STATIC_CAST_EXPR,
DYNAMIC_CAST_EXPR,
DOTSTAR_EXPR,
TYPEID_EXPR,
PSEUDO_DTOR_EXPR,
SUBOBJECT,
CTOR_STMT,
CLEANUP_STMT,
START_CATCH_STMT,
CTOR_INITIALIZER,
RETURN_INIT,
TRY_BLOCK,
HANDLER,
TAG_DEFN,
IDENTITY_CONV,
LVALUE_CONV,
QUAL_CONV,
STD_CONV,
PTR_CONV,
PMEM_CONV,
BASE_CONV,
REF_BIND,
USER_CONV,
AMBIG_CONV,
RVALUE_CONV,
  LAST_CPLUS_TREE_CODE
};

blah(){}

convert_like_real (convs)
     tree convs;
{
  switch (((enum tree_code) (convs)->common.code))
    {
    case AMBIG_CONV:
      return blah();
    default:
      break;
    };
   abort ();
}

main()
{
  tree convs = (void *)malloc (sizeof (struct tree_common));;

  convs->common.code = AMBIG_CONV;
  convert_like_real (convs);
  exit (0);
}
// source: 20000917-1.c
/* This bug exists in gcc-2.95, egcs-1.1.2, gcc-2.7.2 and probably
   every other version as well.  */

typedef struct int3 { int a, b, c; } int3;

int3
one (void)
{
  return (int3) { 1, 1, 1 };
}

int3
zero (void)
{
  return (int3) { 0, 0, 0 };
}

int
main (void)
{
  int3 a;

  /* gcc allocates a temporary for the inner expression statement
     to store the return value of `one'.

     gcc frees the temporaries for the inner expression statement.

     gcc realloates the same temporary slot to store the return
     value of `zero'.

     gcc expands the call to zero ahead of the expansion of the
     statement expressions.  The temporary gets the value of `zero'.

     gcc expands statement expressions and the stale temporary is
     clobbered with the value of `one'.  The bad value is copied from
     the temporary into *&a.  */

  *({ ({ one (); &a; }); }) = zero ();
  if (a.a && a.b && a.c)
    abort ();
  exit (0);
}
// source: 20001009-1.c
int a,b;
main()
{
  int c=-2;
  int d=0xfe;
  int e=a&1;
  int f=b&2;
  if ((char)(c|(e&f)) == (char)d)
    return 0;
  else
    abort();
}
// source: 20001009-2.c
int b=1;
int foo()
{
  int a;
  int c;
  a=0xff;
  for (;b;b--)
  {
    c=1;
    asm(""::"r"(c));
    c=(signed char)a;
  }
  if (c!=-1)
    abort();
  return c;
}
int main()
{
  foo();
  return 0;
}
// source: 20001011-1.c
extern void abort(void);
extern int strcmp(const char *, const char *);

int foo(const char *a)
{
    return strcmp(a, "main");
}

int main(void)
{
    if(foo(__FUNCTION__))
        abort();
    return 0;
}
// source: 20001013-1.c
struct x {
	int a, b;
} z = { -4028, 4096 };

int foo(struct x *p, int y)
{
  if ((y & 0xff) != y || -p->b >= p->a)
    return 1;
  return 0;
}

main()
{
  if (foo (&z, 10))
    abort ();
  exit (0);
}
// source: 20001017-1.c

void bug (double *Cref, char transb, int m, int n, int k,
	  double a, double *A, int fdA, double *B, int fdB,
	  double b, double *C, int fdC)
{
  if (C != Cref) abort ();
}

int main (void)
{
  double A[1], B[1], C[1];

  bug (C, 'B', 1, 2, 3, 4.0, A, 5, B, 6, 7.0, C, 8);

  return 0;
}
// source: 20001017-2.c
void
fn_4parms (unsigned char a, long *b, long *c, unsigned int *d)
{
  if (*b != 1 || *c != 2 || *d != 3)
    abort ();
}

int
main ()
{
  unsigned char a = 0;
  unsigned long b = 1, c = 2;
  unsigned int d = 3;

  fn_4parms (a, &b, &c, &d);
  return 0;
}
// source: 20001024-1.c
struct a;

extern int baz (struct a *__restrict x);

struct a {
  long v;
  long w;
};

struct b {
  struct a c;
  struct a d;
};

int bar (int x, const struct b *__restrict y, struct b *__restrict z)
{
  if (y->c.v || y->c.w != 250000 || y->d.v || y->d.w != 250000)
    abort();
}

void foo(void)
{
  struct b x;
  x.c.v = 0;
  x.c.w = 250000;
  x.d = x.c;
  bar(0, &x, ((void *)0));
}

int main()
{
  foo();
  exit(0);
}
// source: 20001026-1.c
extern void abort (void);

typedef struct {
  long r[(19 + sizeof (long))/(sizeof (long))];
} realvaluetype;

typedef void *tree;

static realvaluetype
real_value_from_int_cst (tree x, tree y)
{
  realvaluetype r;
  int i;
  for (i = 0; i < sizeof(r.r)/sizeof(long); ++i)
    r.r[i] = -1;
  return r;
}

struct brfic_args
{
  tree type;
  tree i;
  realvaluetype d;
};

static void
build_real_from_int_cst_1 (data)
     void * data;
{
  struct brfic_args *args = (struct brfic_args *) data;
  args->d = real_value_from_int_cst (args->type, args->i);
}

int main()
{
  struct brfic_args args;

  __builtin_memset (&args, 0, sizeof(args));
  build_real_from_int_cst_1 (&args);

  if (args.d.r[0] == 0)
    abort ();
  return 0;
}
// source: 20001027-1.c
int x,*p=&x;

int main()
{
  int i=0;
  x=1;
  p[i]=2;
  if (x != 2)
    abort ();
  exit (0);
}
// source: 20001031-1.c
extern void abort (void);
extern void exit (int);

void t1 (int x)
{
  if (x != 4100)
    abort ();
}

int t2 (void)
{
  int i;
  t1 ((i = 4096) + 4);
  return i;
}

void t3 (long long x)
{
  if (x != 0x80000fffULL)
    abort ();
}

long long t4 (void)
{
  long long i;
  t3 ((i = 4096) + 0x7fffffffULL);
  return i;
}

main ()
{
  if (t2 () != 4096)
    abort ();
  if (t4 () != 4096)
    abort ();
  exit (0);
}
// source: 20001101.c
/* { dg-require-effective-target untyped_assembly } */
extern void abort(void);

typedef struct
{
  unsigned int unchanging : 1;
} struc, *rtx;

rtx dummy ( int *a, rtx *b)
{
  *a = 1;
  *b = (rtx)7;
  return (rtx)1;
}

void bogus (insn, thread, delay_list)
     rtx insn;
     rtx thread;
     rtx delay_list;
{
  rtx new_thread;
  int must_annul;

  delay_list = dummy ( &must_annul, &new_thread);
  if (delay_list == 0 &&  new_thread )
    {
      thread = new_thread;
    }
  if (delay_list && must_annul)
    insn->unchanging = 1;
  if (new_thread != thread )
    abort();
}

int main()
{
  struc baz;
  bogus (&baz, (rtx)7, 0);
  exit(0);
  return 0;
}
// source: 20001108-1.c
long long
signed_poly (long long sum, long x)
{
  sum += (long long) (long) sum * (long long) x;
  return sum;
}

unsigned long long
unsigned_poly (unsigned long long sum, unsigned long x)
{
  sum += (unsigned long long) (unsigned long) sum * (unsigned long long) x;
  return sum;
}

int
main (void)
{
  if (signed_poly (2LL, -3) != -4LL)
    abort ();

  if (unsigned_poly (2ULL, 3) != 8ULL)
    abort ();

  exit (0);
}
// source: 20001111-1.c

static int next_buffer = 0;
void bar (void);

static int t = 1, u = 0;

long
foo (unsigned int offset)
{
  unsigned i, buffer;
  int x;
  char *data;

  i = u;
  if (i)
    return i * 0xce2f;

  buffer = next_buffer;
  data = buffer * 0xce2f;
  for (i = 0; i < 2; i++)
    bar ();
  buffer = next_buffer;
  return buffer * 0xce2f + offset;

}

void
bar (void)
{
}

int
main ()
{
  if (foo (3) != 3)
    abort ();
  next_buffer = 1;
  if (foo (2) != 0xce2f + 2)
    abort ();
  exit (0);
}
// source: 20001112-1.c
int main ()
{
  long long i = 1;

  i = i * 2 + 1;

  if (i != 3)
    abort ();
  exit (0);
}
// source: 20001121-1.c
/* { dg-options "-fgnu89-inline" } */

extern void abort (void);
extern void exit (int);

double d;

__inline__ double foo (void)
{
  return d;
}

__inline__ int bar (void)
{
  foo();
  return 0;
}

int main (void)
{
  if (bar ())
    abort ();
  exit (0);
}
// source: 20001124-1.c

struct inode {
	long long		i_size;
	struct super_block	*i_sb;
};

struct file {
	long long		f_pos;
};

struct super_block {
	int			s_blocksize;
	unsigned char		s_blocksize_bits;
	int			s_hs;
};

static char *
isofs_bread(unsigned int block)
{
	if (block)
	  abort ();
	exit(0);
}

static int
do_isofs_readdir(struct inode *inode, struct file *filp)
{
	int bufsize = inode->i_sb->s_blocksize;
	unsigned char bufbits = inode->i_sb->s_blocksize_bits;
	unsigned int block, offset;
	char *bh = 0;
	int hs;

	if (filp->f_pos >= inode->i_size)
		return 0;

	offset = filp->f_pos & (bufsize - 1);
	block = filp->f_pos >> bufbits;
	hs = inode->i_sb->s_hs;

	while (filp->f_pos < inode->i_size) {
		if (!bh)
			bh = isofs_bread(block);

		hs += block << bufbits;

		if (hs == 0)
			filp->f_pos++;

		if (offset >= bufsize)
			offset &= bufsize - 1;

		if (*bh)
			filp->f_pos++;

		filp->f_pos++;
	}
	return 0;
}

struct super_block s;
struct inode i;
struct file f;

int
main(int argc, char **argv)
{
	s.s_blocksize = 512;
	s.s_blocksize_bits = 9;
	i.i_size = 2048;
	i.i_sb = &s;
	f.f_pos = 0;

	do_isofs_readdir(&i,&f);
	abort ();
}
// source: 20001130-1.c
static inline int bar(void) { return 1; }
static int mem[3];

static int foo(int x)
{
  if (x != 0)
    return x;

  mem[x++] = foo(bar());

  if (x != 1)
    abort();

  return 0;
}

int main()
{
  foo(0);
  return 0;
}
// source: 20001130-2.c
static int which_alternative = 3;

static const char *i960_output_ldconst (void);

static const char *
output_25 (void)
{
  switch (which_alternative)
    {
    case 0:
      return "mov	%1,%0";
    case 1:
      return i960_output_ldconst ();
    case 2:
      return "ld	%1,%0";
    case 3:
      return "st	%1,%0";
    }
}

static const char *i960_output_ldconst (void)
{
  return "foo";
}
int main(void)
{
  const char *s = output_25 () ;
  if (s[0] != 's')
    abort ();
  exit (0);
}
// source: 20001203-1.c
/* Origin: PR c/410 from Jan Echternach
   <jan.echternach@informatik.uni-rostock.de>,
   adapted to a testcase by Joseph Myers <jsm28@cam.ac.uk>.
*/

extern void exit (int);

static void
foo (void)
{
  struct {
    long a;
    char b[1];
  } x = { 2, { 0 } };
}

int
main (void)
{
  int tmp;
  foo ();
  tmp = 1;
  exit (0);
}
// source: 20001203-2.c
struct obstack
{
  long chunk_size;
  struct _obstack_chunk *chunk;
  char *object_base;
  char *next_free;
  char *chunk_limit;
  int alignment_mask;
  unsigned maybe_empty_object;
};

struct objfile
  {
    struct objfile *next;
    struct obstack type_obstack;
  };

struct type
  {
    unsigned length;
    struct objfile *objfile;
    short nfields;
    struct field
      {
        union field_location
          {
            int bitpos;
            unsigned long physaddr;
            char *physname;
          }
        loc;
        int bitsize;
        struct type *type;
        char *name;
      }
     *fields;
  };

struct type *alloc_type (void);
void * xmalloc (unsigned int z);
void _obstack_newchunk (struct obstack *o, int i);
void get_discrete_bounds (long long *lowp, long long *highp);

extern void *memset(void *, int, __SIZE_TYPE__);

struct type *
create_array_type (struct type *result_type, struct type *element_type)
{
  long long low_bound, high_bound;
  if (result_type == ((void *)0))
    {
      result_type = alloc_type ();
    }
  get_discrete_bounds (&low_bound, &high_bound);
  (result_type)->length =
    (element_type)->length * (high_bound - low_bound + 1);
  (result_type)->nfields = 1;
  (result_type)->fields =
    (struct field *) ((result_type)->objfile != ((void *)0)
		      ? (
		      {
			struct obstack *__h =
			  (&(result_type)->objfile -> type_obstack);
			{
			  struct obstack *__o = (__h);
			  int __len = ((sizeof (struct field)));
			  if (__o->chunk_limit - __o->next_free < __len)
			    _obstack_newchunk (__o, __len);
			  __o->next_free += __len; (void) 0;
			};
			({
			  struct obstack *__o1 = (__h);
			  void *value;
			  value = (void *) __o1->object_base;
			  if (__o1->next_free == value)
			    __o1->maybe_empty_object = 1;
			  __o1->next_free = (((((__o1->next_free) - (char *) 0)
					       +__o1->alignment_mask)
					      & ~ (__o1->alignment_mask))
					     + (char *) 0);
			  if (__o1->next_free - (char *)__o1->chunk
			      > __o1->chunk_limit - (char *)__o1->chunk)
			    __o1->next_free = __o1->chunk_limit;
			  __o1->object_base = __o1->next_free;
			  value;
			});
		      }) : xmalloc (sizeof (struct field)));
  return (result_type);
}

struct type *
alloc_type (void)
{
  abort ();
}
void * xmalloc (unsigned int z)
{
  return 0;
}
void _obstack_newchunk (struct obstack *o, int i)
{
  abort ();
}
void
get_discrete_bounds (long long *lowp, long long *highp)
{
  *lowp = 0;
  *highp = 2;
}

int main(void)
{
  struct type element_type;
  struct type result_type;

  memset (&element_type, 0, sizeof (struct type));
  memset (&result_type, 0, sizeof (struct type));
  element_type.length = 4;
  create_array_type (&result_type, &element_type);
  if (result_type.length != 12)
    abort ();
  exit (0);
}
// source: 20001221-1.c
int main ()
{
  unsigned long long a;
  if (! (a = 0xfedcba9876543210ULL))
    abort ();
  exit (0);
}
// source: 20001228-1.c
int foo1(void)
{
  union {
    char a[sizeof (unsigned)];
    unsigned b;
  } u;

  u.b = 0x01;
  return u.a[0];
}

int foo2(void)
{
  volatile union {
    char a[sizeof (unsigned)];
    unsigned b;
  } u;

  u.b = 0x01;
  return u.a[0];
}

int main(void)
{
  if (foo1() != foo2())
    abort ();
  exit (0);
}
// source: 20001229-1.c
/* This testcase originally provoked an unaligned access fault on Alpha.

   Since Digital Unix and Linux (and probably others) by default fix
   these up in the kernel, the failure was not visible unless one
   is sitting at the console examining logs.

   So: If we know how, ask the kernel to deliver SIGBUS instead so
   that the test case visibly fails.  */

#if defined(__alpha__) && defined(__linux__)
#include <asm/sysinfo.h>
#include <asm/unistd.h>

static inline int
setsysinfo(unsigned long op, void *buffer, unsigned long size,
           int *start, void *arg, unsigned long flag)
{
  syscall(__NR_osf_setsysinfo, op, buffer, size, start, arg, flag);
}

static void __attribute__((constructor))
trap_unaligned(void)
{
  unsigned int buf[2];
  buf[0] = SSIN_UACPROC;
  buf[1] = UAC_SIGBUS | UAC_NOPRINT;
  setsysinfo(SSI_NVPAIRS, buf, 1, 0, 0, 0);
}
#endif /* alpha */

void foo(char *a, char *b) { }

void showinfo()
{
    char uname[33] = "", tty[38] = "/dev/";
    foo(uname, tty);
}

int main()
{
  showinfo ();
  exit (0);
}
// source: 20010106-1.c
/* Copyright 2001 Free Software Foundation
   Contributed by Alexandre Oliva <aoliva@redhat.com> */

int f(int i) {
  switch (i)
  {
    case -2:
      return 33;
    case -1:
      return 0;
    case 0:
      return 7;
    case 1:
      return 4;
    case 2:
      return 3;
    case 3:
      return 15;
    case 4:
     return 9;
    default:
      abort ();
  }
}

int main() {
  if (f(-1))
    abort ();
  exit (0);
}
// source: 20010114-1.c
/* Origin: PR c/1540 from Mattias Lampe <lampe@tu-harburg.de>,
   adapted to a testcase by Joseph Myers <jsm28@cam.ac.uk>.
   GCC 2.95.2 fails, CVS GCC of 2001-01-13 passes.  */
extern void abort (void);
extern void exit (int);

int
main (void)
{
  int array1[1] = { 1 };
  int array2[2][1]= { { 1 }, { 0 } };
  if (array1[0] != 1)
    abort ();
  exit (0);
}
// source: 20010116-1.c
/* Distilled from optimization/863.  */

extern void abort (void);
extern void exit (int);
extern void ok (int);

typedef struct
{
  int x, y, z;
} Data;

void find (Data *first, Data *last)
{
  int i;
  for (i = (last - first) >> 2; i > 0; --i)
    ok(i);
  abort ();
}

void ok(int i)
{
  if (i != 1)
    abort ();
  exit (0);
}

int
main ()
{
  Data DataList[4];
  find (DataList + 0, DataList + 4);
}
// source: 20010118-1.c
typedef struct {
  int a, b, c, d, e, f;
} A;

void foo (A *v, int w, int x, int *y, int *z)
{
}

void
bar (A *v, int x, int y, int w, int h)
{
  if (v->a != x || v->b != y) {
    int oldw = w;
    int oldh = h;
    int e = v->e;
    int f = v->f;
    int dx, dy;
    foo(v, 0, 0, &w, &h);
    dx = (oldw - w) * (double) e/2.0;
    dy = (oldh - h) * (double) f/2.0;
    x += dx;
    y += dy;
    v->a = x;
    v->b = y;
    v->c = w;
    v->d = h;
  }
}

int main ()
{
  A w = { 100, 110, 20, 30, -1, -1 };
  bar (&w,400,420,50,70);
  if (w.d != 70)
    abort();
  exit(0);
}
// source: 20010119-1.c
#ifdef __OPTIMIZE__
extern void undef (void);

void bar (unsigned x) { }
void baz (unsigned x) { }

extern inline void foo (int a, int b)
{
  int c = 0;
  while (c++ < b)
    (__builtin_constant_p (a) ? ((a) > 20000 ? undef () : bar (a)) : baz (a));
}
#else
void foo (int a, int b)
{
}
#endif

int main (void)
{
  foo(10, 100);
  exit (0);
}
// source: 20010122-1.c
/* { dg-skip-if "requires frame pointers" { *-*-* } "-fomit-frame-pointer" "" } */
/* { dg-require-effective-target return_address } */

extern void exit (int);
extern void abort (void);
extern void *alloca (__SIZE_TYPE__);
char *dummy (void);

#define NOINLINE __attribute__((noinline)) __attribute__ ((noclone))

void *save_ret1[6];
void *test4a (char *);
void *test5a (char *);
void *test6a (char *);

void NOINLINE *test1 (void)
{
  void * temp;
  temp = __builtin_return_address (0);
  return temp;
}

void NOINLINE *test2 (void)
{
  void * temp;
  dummy ();
  temp = __builtin_return_address (0);
  return temp;
}

void NOINLINE *test3 (void)
{
  void * temp;
  temp = __builtin_return_address (0);
  dummy ();
  return temp;
}

void NOINLINE *test4 (void)
{
  char * save = (char*) alloca (4);

  return test4a (save);
}

void *NOINLINE test4a (char * p)
{
  void * temp;
  temp = __builtin_return_address (1);
  return temp;
}

void NOINLINE *test5 (void)
{
  char * save = (char*) alloca (4);

  return test5a (save);
}

void NOINLINE *test5a (char * p)
{
  void * temp;
  dummy ();
  temp = __builtin_return_address (1);
  return temp;
}

void NOINLINE *test6 (void)
{
  char * save = (char*) alloca (4);

  return test6a (save);
}

void NOINLINE *test6a (char * p)
{
  void * temp;
  temp = __builtin_return_address (1);
  dummy ();
  return temp;
}

void *(*func1[6])(void) = { test1, test2, test3, test4, test5, test6 };

char * NOINLINE call_func1 (int i)
{
  save_ret1[i] = func1[i] ();
}

static void *ret_addr;
void *save_ret2[6];
void test10a (char *);
void test11a (char *);
void test12a (char *);

void NOINLINE test7 (void)
{
  ret_addr = __builtin_return_address (0);
  return;
}

void NOINLINE test8 (void)
{
  dummy ();
  ret_addr = __builtin_return_address (0);
  return;
}

void NOINLINE test9 (void)
{
  ret_addr = __builtin_return_address (0);
  dummy ();
  return;
}

void NOINLINE test10 (void)
{
  char * save = (char*) alloca (4);

  test10a (save);
}

void NOINLINE test10a (char * p)
{
  ret_addr = __builtin_return_address (1);
  return;
}

void NOINLINE test11 (void)
{
  char * save = (char*) alloca (4);

  test11a (save);
}

void NOINLINE test11a (char * p)
{
  dummy ();
  ret_addr = __builtin_return_address (1);
  return;
}

void NOINLINE test12 (void)
{
  char * save = (char*) alloca (4);

  test12a (save);
}

void NOINLINE test12a (char * p)
{
  ret_addr = __builtin_return_address (1);
  dummy ();
  return;
}

char * dummy (void)
{
  char * save = (char*) alloca (4);

  return save;
}

void (*func2[6])(void) = { test7, test8, test9, test10, test11, test12 };

void NOINLINE call_func2 (int i)
{
  func2[i] ();
  save_ret2[i] = ret_addr;
}

int main (void)
{
  int i;

  for (i = 0; i < 6; i++) {
    call_func1(i);
  }

  if (save_ret1[0] != save_ret1[1]
      || save_ret1[1] != save_ret1[2])
    abort ();
  if (save_ret1[3] != save_ret1[4]
      || save_ret1[4] != save_ret1[5])
    abort ();
  if (save_ret1[3] && save_ret1[0] != save_ret1[3])
    abort ();


  for (i = 0; i < 6; i++) {
    call_func2(i);
  }

  if (save_ret2[0] != save_ret2[1]
      || save_ret2[1] != save_ret2[2])
    abort ();
  if (save_ret2[3] != save_ret2[4]
      || save_ret2[4] != save_ret2[5])
    abort ();
  if (save_ret2[3] && save_ret2[0] != save_ret2[3])
    abort ();

  exit (0);
}
// source: 20010123-1.c
extern void abort ();
extern void exit (int);

struct s
{
    int value;
    char *string;
};

int main (void)
{
  int i;
  for (i = 0; i < 4; i++)
    {
      struct s *t = & (struct s) { 3, "hey there" };
      if (t->value != 3)
	abort();
      t->value = 4;
      if (t->value != 4)
	abort();
    }
  exit (0);
}
// source: 20010129-1.c
/* { dg-options "-mtune=i686" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */

extern void abort (void);
extern void exit (int);

long baz1 (void *a)
{
  static long l;
  return l++;
}

int baz2 (const char *a)
{
  return 0;
}

int baz3 (int i)
{
  if (!i)
    abort ();
  return 1;
}

void **bar;

int foo (void *a, long b, int c)
{
  int d = 0, e, f = 0, i;
  char g[256];
  void **h;

  g[0] = '\n';
  g[1] = 0;

  while (baz1 (a) < b) {
    if (g[0] != ' ' && g[0] != '\t') {
      f = 1;
      e = 0;
      if (!d && baz2 (g) == 0) {
	if ((c & 0x10) == 0)
	  continue;
	e = d = 1;
      }
      if (!((c & 0x10) && (c & 0x4000) && e) && (c & 2))
	continue;
      if ((c & 0x2000) && baz2 (g) == 0)
	continue;
      if ((c & 0x1408) && baz2 (g) == 0)
	continue;
      if ((c & 0x200) && baz2 (g) == 0)
	continue;
      if (c & 0x80) {
	for (h = bar, i = 0; h; h = (void **)*h, i++)
	  if (baz3 (i))
	    break;
      }
      f = 0;
    }
  }
  return 0;
}

int main ()
{
  void *n = 0;
  bar = &n;
  foo (&n, 1, 0xc811);
  exit (0);
}
// source: 20010206-1.c
int foo (void)
{
  int i;
#line 1 "20010206-1.c"
  if (0) i = 1; else i
#line 1 "20010206-1.c"
    = 26;
  return i;
}

int main ()
{
  if (foo () != 26)
    abort ();
  exit (0);
}
// source: 20010209-1.c
/* { dg-require-effective-target alloca } */
int b;
int foo (void)
{
  int x[b];
  int bar (int t[b])
  {
    int i;
    for (i = 0; i < b; i++)
      t[i] = i + (i > 0 ? t[i-1] : 0);
    return t[b-1];
  }
  return bar (x);
}

int main ()
{
  b = 6;
  if (foo () != 15)
    abort ();
  exit (0);
}
// source: 20010221-1.c

int n = 2;

main ()
{
  int i, x = 45;

  for (i = 0; i < n; i++)
    {
      if (i != 0)
	x = ( i > 0 ) ? i : 0;
    }

  if (x != 1)
    abort ();
  exit (0);
}
// source: 20010222-1.c
int a[2] = { 18, 6 };

int main ()
{
  int b = (-3 * a[0] -3 * a[1]) / 12;
  if (b != -6)
    abort ();
  exit (0);
}
// source: 20010224-1.c
extern void abort (void);

typedef signed short int16_t;
typedef unsigned short uint16_t;

int16_t logadd (int16_t *a, int16_t *b);
void ba_compute_psd (int16_t start);

int16_t masktab[6] = { 1, 2, 3, 4, 5};
int16_t psd[6] = { 50, 40, 30, 20, 10};
int16_t bndpsd[6] = { 1, 2, 3, 4, 5};

void ba_compute_psd (int16_t start)
{
  int i,j,k;
  int16_t lastbin = 4;

  j = start;
  k = masktab[start];

  bndpsd[k] = psd[j];
  j++;

  for (i = j; i < lastbin; i++) {
    bndpsd[k] = logadd(&bndpsd[k], &psd[j]);
    j++;
  }
}

int16_t logadd (int16_t *a, int16_t *b)
{
  return *a + *b;
}

int main (void)
{
  int i;

  ba_compute_psd (0);

  if (bndpsd[1] != 140) abort ();
  return 0;
}
// source: 20010325-1.c
/* Origin: Joseph Myers <jsm28@cam.ac.uk>.

   This tests for inconsistency in whether wide STRING_CSTs use the host
   or the target endianness.  */

extern void exit (int);
extern void abort (void);

int
main (void)
{
  if (L"a" "b"[1] != L'b')
    abort ();
  exit (0);
}
// source: 20010329-1.c
#include <limits.h>

int main (void)
{
  void *x = ((void *)((unsigned int)INT_MAX + 2));
  void *y = ((void *)((unsigned long)LONG_MAX + 2));
  if (x >= ((void *)((unsigned int)INT_MAX + 1))
      && x <= ((void *)((unsigned int)INT_MAX + 6))
      && y >= ((void *)((unsigned long)LONG_MAX + 1))
      && y <= ((void *)((unsigned long)LONG_MAX + 6)))
    exit (0);
  else
    abort ();
}
// source: 20010403-1.c
void b (int *);
void c (int, int);
void d (int);

int e;

void a (int x, int y)
{
  int f = x ? e : 0;
  int z = y;

  b (&y);
  c (z, y);
  d (f);
}

void b (int *y)
{
  (*y)++;
}

void c (int x, int y)
{
  if (x == y)
    abort ();
}

void d (int x)
{
}

int main (void)
{
  a (0, 0);
  exit (0);
}
// source: 20010409-1.c
typedef __SIZE_TYPE__ size_t;
extern size_t strlen (const char *s);

typedef struct A {
  int a, b;
} A;

typedef struct B {
  struct A **a;
  int b;
} B;

A *a;
int b = 1, c;
B d[1];

void foo (A *x, const char *y, int z)
{
  c = y[4] + z * 25;
}

A *bar (const char *v, int w, int x, const char *y, int z)
{
  if (w)
    abort ();
  exit (0);
}

void test (const char *x, int *y)
{
  foo (d->a[d->b], "test", 200);
  d->a[d->b] = bar (x, b ? 0 : 65536, strlen (x), "test", 201);
  d->a[d->b]->a++;
  if (y)
    d->a[d->b]->b = *y;
}

int main ()
{
  d->b = 0;
  d->a = &a;
  test ("", 0);
}
// source: 20010422-1.c
unsigned int foo(unsigned int x)
{
  if (x < 5)
    x = 4;
  else
    x = 8;
  return x;
}

int main(void)
{
  if (foo (8) != 8)
    abort ();
  exit (0);
}
// source: 20010518-1.c
/* Leaf functions with many arguments.  */

int
add (int a,
    int b,
    int c,
    int d,
    int e,
    int f,
    int g,
    int h,
    int i,
    int j,
    int k,
    int l,
    int m)
{
  return a+b+c+d+e+f+g+h+i+j+k+l+m;
}

int
main(void)
{
  if (add (1,2,3,4,5,6,7,8,9,10,11,12,13) != 91)
    abort ();

  exit (0);
}
// source: 20010518-2.c
/* Mis-aligned packed structures.  */

typedef struct
{
  char b0;
  char b1;
  char b2;
  char b3;
  char b4;
  char b5;
} __attribute__ ((packed)) b_struct;


typedef struct
{
  short a;
  long b;
  short c;
  short d;
  b_struct e;
} __attribute__ ((packed)) a_struct;


int
main(void)
{
  volatile a_struct *a;
  volatile a_struct b;

  a = &b;
  *a = (a_struct){1,2,3,4};
  a->e.b4 = 'c';

  if (a->a != 1 || a->b != 2 || a->c != 3 || a->d != 4 || a->e.b4 != 'c')
    abort ();

  exit (0);
}
// source: 20010520-1.c
static unsigned int expr_hash_table_size = 1;

int
main ()
{
  int del = 1;
  unsigned int i = 0;

  if (i < expr_hash_table_size && del)
    exit (0);
  abort ();
}
// source: 20010604-1.c
#include <stdbool.h>

int f (int a, int b, int c, _Bool d, _Bool e, _Bool f, char g)
{
  if (g != 1 || d != true || e != true || f != true) abort ();
  return a + b + c;
}

int main (void)
{
  if (f (1, 2, -3, true, true, true, '\001'))
    abort ();
  exit (0);
}
// source: 20010605-1.c
int main ()
{
  int v = 42;

  inline int fff (int x)
    {
      return x*10;
    }

  return (fff (v) != 420);
}
// source: 20010605-2.c
void foo (), bar (), baz ();
int main ()
{
  __complex__ double x;
  __complex__ float y;
  __complex__ long double z;
  __real__ x = 1.0;
  __imag__ x = 2.0;
  foo (x);
  __real__ y = 3.0f;
  __imag__ y = 4.0f;
  bar (y);
  __real__ z = 5.0L;
  __imag__ z = 6.0L;
  baz (z);
  exit (0);
}

void foo (__complex__ double x)
{
  if (__real__ x != 1.0 || __imag__ x != 2.0)
    abort ();
}

void bar (__complex__ float x)
{
  if (__real__ x != 3.0f || __imag__ x != 4.0f)
    abort ();
}

void baz (__complex__ long double x)
{
  if (__real__ x != 5.0L || __imag__ x != 6.0L)
    abort ();
}
// source: 20010711-1.c
void foo (int *a) {}

int main ()
{
  int a;
  if (&a == 0)
    abort ();
  else
    {
      foo (&a);
      exit (0);
    }
}
// source: 20010717-1.c
extern void abort (void);

int
main ()
{
  int i, j;
  unsigned long u, r1, r2;

  i = -16;
  j = 1;
  u = i + j;

  /* no sign extension upon shift */
  r1 = u >> 1;
  /* sign extension upon shift, but there shouldn't be */
  r2 = ((unsigned long) (i + j)) >> 1;

  if (r1 != r2)
    abort ();

  return 0;
}
// source: 20010723-1.c
int
test ()
{
  int biv,giv;
  for (biv = 0, giv = 0; giv != 8; biv++)
      giv = biv*8;
  return giv;
}


main()
{
  if (test () != 8)
    abort ();
  exit (0);
}
// source: 20010904-1.c
/* If some target has a Max alignment less than 32, please create
   a #ifdef around the alignment and add your alignment.  */
#ifdef __pdp11__
#define alignment 2
#else
#define alignment 32
#endif

typedef struct x { int a; int b; } __attribute__((aligned(alignment))) X;
typedef struct y { X x[32]; int c; } Y;

Y y[2];

int main(void)
{
  if (((char *)&y[1] - (char *)&y[0]) & 31)
    abort ();
  exit (0);
}
// source: 20010904-2.c
/* If some target has a Max alignment less than 32, please create
   a #ifdef around the alignment and add your alignment.  */
#ifdef __pdp11__
#define alignment 2
#else
#define alignment 32
#endif

typedef struct x { int a; int b; } __attribute__((aligned(alignment))) X;
typedef struct y { X x; X y[31]; int c; } Y;

Y y[2];

int main(void)
{
  if (((char *)&y[1] - (char *)&y[0]) & 31)
    abort ();
  exit (0);
}
// source: 20010910-1.c
/* Test case contributed by Ingo Rohloff <rohloff@in.tum.de>.
   Code distilled from Linux kernel.  */

/* Compile this program with a gcc-2.95.2 using
   "gcc -O2" and run it. The result will be that
   rx_ring[1].next == 0   (it should be == 14)
   and
   ep.skbuff[4] == 5      (it should be 0)
*/

extern void abort(void);

struct epic_rx_desc
{
  unsigned int next;
};

struct epic_private
{
  struct epic_rx_desc *rx_ring;
  unsigned int rx_skbuff[5];
};

static void epic_init_ring(struct epic_private *ep)
{
  int i;

  for (i = 0; i < 5; i++)
  {
    ep->rx_ring[i].next = 10 + (i+1)*2;
    ep->rx_skbuff[i] = 0;
  }
  ep->rx_ring[i-1].next = 10;
}

static int check_rx_ring[5] = { 12,14,16,18,10 };

int main(void)
{
  struct epic_private ep;
  struct epic_rx_desc rx_ring[5];
  int i;

  for (i=0;i<5;i++)
  {
    rx_ring[i].next=0;
    ep.rx_skbuff[i]=5;
  }

  ep.rx_ring=rx_ring;
  epic_init_ring(&ep);

  for (i=0;i<5;i++)
  {
    if ( rx_ring[i].next != check_rx_ring[i] ) abort();
    if ( ep.rx_skbuff[i] != 0 ) abort();
  }
  return 0;
}
// source: 20010915-1.c
/* Bug in reorg.c, deleting the "++" in the last loop in main.
   Origin: <hp@axis.com>.  */

extern void f (void);
extern int x (int, char **);
extern int r (const char *);
extern char *s (char *, char **);
extern char *m (char *);
char *u;
char *h;
int check = 0;
int o = 0;

int main (int argc, char **argv)
{
  char *args[] = {"a", "b", "c", "d", "e"};
  if (x (5, args) != 0 || check != 2 || o != 5)
    abort ();
  exit (0);
}

int x (int argc, char **argv)
{
  int opt = 0;
  char *g = 0;
  char *p = 0;

  if (argc > o && argc > 2 && argv[o])
    {
      g = s (argv[o], &p);
      if (g)
	{
	  *g++ = '\0';
	  h = s (g, &p);
	  if (g == p)
	    h = m (g);
	}
      u = s (argv[o], &p);
      if (argv[o] == p)
	u = m (argv[o]);
    }
  else
    abort ();

  while (++o < argc)
    if (r (argv[o]) == 0)
      return 1;

  return 0;
}

char *m (char *x) { abort (); }
char *s (char *v, char **pp)
{
  if (strcmp (v, "a") != 0 || check++ > 1)
    abort ();
  *pp = v+1;
  return 0;
}

int r (const char *f)
{
  static char c[2] = "b";
  static int cnt = 0;

  if (*f != *c || f[1] != c[1] || cnt > 3)
    abort ();
  c[0]++;
  cnt++;
  return 1;
}
// source: 20010924-1.c
/* Verify that flexible arrays can be initialized from STRING_CST
   constructors. */

/* Baselines.  */
struct {
  char a1c;
  char *a1p;
} a1 = {
  '4',
  "62"
};

struct {
  char a2c;
  char a2p[2];
} a2 = {
  'v',
  "cq"
};

/* The tests.  */
struct {
  char a3c;
  char a3p[];
} a3 = {
  'o',
  "wx"
};

struct {
  char a4c;
  char a4p[];
} a4 = {
  '9',
  { 'e', 'b' }
};

main()
{
  if (a1.a1c != '4')
    abort();
  if (a1.a1p[0] != '6')
    abort();
  if (a1.a1p[1] != '2')
    abort();
  if (a1.a1p[2] != '\0')
    abort();

  if (a2.a2c != 'v')
    abort();
  if (a2.a2p[0] != 'c')
    abort();
  if (a2.a2p[1] != 'q')
    abort();

  if (a3.a3c != 'o')
    abort();
  if (a3.a3p[0] != 'w')
    abort();
  if (a3.a3p[1] != 'x')
    abort();

  if (a4.a4c != '9')
    abort();
  if (a4.a4p[0] != 'e')
    abort();
  if (a4.a4p[1] != 'b')
    abort();

  return 0;
}
// source: 20010925-1.c
extern void exit(int);
extern void abort (void);

extern void * memcpy (void *, const void *, __SIZE_TYPE__);
int foo (void *, void *, unsigned int c);

int src[10];
int dst[10];

int main()
{
   if (foo (dst, src, 10) != 0)
     abort();
   exit(0);
}

int foo (void *a, void *b, unsigned int c)
{
  if (c == 0)
    return 1;

  memcpy (a, b, c);
  return 0;
}
// source: 20011008-3.c
/* { dg-add-options stack_size } */

extern void exit (int);
extern void abort (void);

typedef unsigned int u_int32_t;
typedef unsigned char u_int8_t;
typedef int int32_t;

typedef enum {
        TXNLIST_DELETE,
        TXNLIST_LSN,
        TXNLIST_TXNID,
        TXNLIST_PGNO
} db_txnlist_type;

struct __db_lsn; typedef struct __db_lsn DB_LSN;
struct __db_lsn {
        u_int32_t file;
        u_int32_t offset;
};
struct __db_txnlist; typedef struct __db_txnlist DB_TXNLIST;

struct __db_txnlist {
        db_txnlist_type type;
        struct { struct __db_txnlist *le_next; struct __db_txnlist **le_prev; } links;
        union {
                struct {
                        u_int32_t txnid;
                        int32_t generation;
                        int32_t aborted;
                } t;
                struct {


                        u_int32_t flags;
                        int32_t fileid;
                        u_int32_t count;
                        char *fname;
                } d;
                struct {
                        int32_t ntxns;
                        int32_t maxn;
                        DB_LSN *lsn_array;
                } l;
                struct {
                        int32_t nentries;
                        int32_t maxentry;
                        char *fname;
                        int32_t fileid;
                        void *pgno_array;
                        u_int8_t uid[20];
                } p;
        } u;
};

int log_compare (const DB_LSN *a, const DB_LSN *b)
{
  return 1;
}


int
__db_txnlist_lsnadd(int val, DB_TXNLIST *elp, DB_LSN *lsnp, u_int32_t flags)
{
   int i;

   for (i = 0; i < (!(flags & (0x1)) ? 1 : elp->u.l.ntxns); i++)
     {
	int __j;
	DB_LSN __tmp;
	val++;
	for (__j = 0; __j < elp->u.l.ntxns - 1; __j++)
	  if (log_compare(&elp->u.l.lsn_array[__j], &elp->u.l.lsn_array[__j + 1]) < 0)
	  {
	     __tmp = elp->u.l.lsn_array[__j];
	     elp->u.l.lsn_array[__j] = elp->u.l.lsn_array[__j + 1];
	     elp->u.l.lsn_array[__j + 1] = __tmp;
	  }
     }

   *lsnp = elp->u.l.lsn_array[0];
   return val;
}

#if defined (STACK_SIZE) && STACK_SIZE < 12350
#define VLEN (STACK_SIZE/10)
#else
#define VLEN 1235
#endif

int main (void)
{
  DB_TXNLIST el;
  DB_LSN lsn, lsn_a[VLEN];

  el.u.l.ntxns = VLEN-1;
  el.u.l.lsn_array = lsn_a;

  if (__db_txnlist_lsnadd (0, &el, &lsn, 0) != 1)
    abort ();

  if (__db_txnlist_lsnadd (0, &el, &lsn, 1) != VLEN-1)
    abort ();

  exit (0);
}
// source: 20011019-1.c
extern void exit (int);
extern void abort (void);

struct { int a; int b[5]; } x;
int *y;

int foo (void)
{
  return y - x.b;
}

int main (void)
{
  y = x.b;
  if (foo ())
    abort ();
  exit (0);
}
// source: 20011024-1.c
/* Test whether store motion recognizes pure functions as potentially reading
   any memory.  */

typedef __SIZE_TYPE__ size_t;
extern void *memcpy (void *dest, const void *src, size_t n);
extern size_t strlen (const char *s);
extern int strcmp (const char *s1, const char *s2) __attribute__((pure));

char buf[50];

static void foo (void)
{
  if (memcpy (buf, "abc", 4) != buf) abort ();
  if (strcmp (buf, "abc")) abort ();
  memcpy (buf, "abcdefgh", strlen ("abcdefgh") + 1);
}

int main (void)
{
  foo ();
  return 0;
}
// source: 20011109-1.c
void fail1(void)
{
  abort ();
}
void fail2(void)
{
  abort ();
}
void fail3(void)
{
  abort ();
}
void fail4(void)
{
  abort ();
}


void foo(long x)
{
  switch (x)
    {
    case -6:
      fail1 (); break;
    case 0:
      fail2 (); break;
    case 1: case 2:
      break;
    case 3: case 4: case 5:
      fail3 ();
      break;
    default:
      fail4 ();
      break;
    }
  switch (x)
    {

    case -3:
      fail1 (); break;
    case 0: case 4:
      fail2 (); break;
    case 1: case 3:
      break;
    case 2: case 8:
      abort ();
      break;
    default:
      fail4 ();
      break;
    }
}

int main(void)
{
  foo (1);
  exit (0);
}
// source: 20011109-2.c
int main(void)
{
  char *c1 = "foo";
  char *c2 = "foo";
  int i;
  for (i = 0; i < 3; i++)
    if (c1[i] != c2[i])
      abort ();
  exit (0);
}
// source: 20011113-1.c
typedef __SIZE_TYPE__ size_t;
extern void *memcpy (void *__restrict, const void *__restrict, size_t);
extern void abort (void);
extern void exit (int);

typedef struct t
{
  unsigned a : 16;
  unsigned b : 8;
  unsigned c : 8;
  long d[4];
} *T;

typedef struct {
  long r[3];
} U;

T bar (U, unsigned int);

T foo (T x)
{
  U d, u;

  memcpy (&u, &x->d[1], sizeof u);
  d = u;
  return bar (d, x->b);
}

T baz (T x)
{
  U d, u;

  d.r[0] = 0x123456789;
  d.r[1] = 0xfedcba987;
  d.r[2] = 0xabcdef123;
  memcpy (&u, &x->d[1], sizeof u);
  d = u;
  return bar (d, x->b);
}

T bar (U d, unsigned int m)
{
  if (d.r[0] != 21 || d.r[1] != 22 || d.r[2] != 23)
    abort ();
  return 0;
}

struct t t = { 26, 0, 0, { 0, 21, 22, 23 }};

int main (void)
{
  baz (&t);
  foo (&t);
  exit (0);
}
// source: 20011114-1.c
char foo(char bar[])
{
  return bar[1];
}
extern char foo(char *);
int main(void)
{
  if (foo("xy") != 'y')
    abort ();
  exit (0);
}
// source: 20011115-1.c
extern void exit (int);

static inline int
foo (void)
{
#ifdef __OPTIMIZE__
  extern int undefined_reference;
  return undefined_reference;
#else
  return 0;
#endif
}

static inline int
bar (void)
{
  if (foo == foo)
    return 1;
  else
    return foo ();
}

int main (void)
{
  exit (0);
}
// source: 20011121-1.c
struct s
{
  int i[18];
  char f;
  char b[2];
};

struct s s1;

int
main()
{
  struct s s2;
  s2.b[0] = 100;
  __builtin_memcpy(&s2, &s1, ((unsigned int) &((struct s *)0)->b));
  if (s2.b[0] != 100)
    abort();
  exit(0);
}
// source: 20011126-1.c
/* Produced a overflow in ifcvt.c, causing S to contain 0xffffffff7fffffff.  */

int a = 1;

int main ()
{
  long long s;

  s = a;
  if (s < 0)
    s = -2147483648LL;
  else
    s = 2147483647LL;

  if (s < 0)
    abort ();

  return 0;
}
// source: 20011126-2.c
/* Problem originally visible on ia64.

   There is a partial redundancy of "in + 1" that makes GCSE want to
   transform the final while loop to

     p = in + 1;
     tmp = p;
     ...
     goto start;
   top:
     tmp = tmp + 1;
   start:
     in = tmp;
     if (in < p) goto top;

   We miscalculate the number of loop iterations as (p - tmp) = 0
   instead of (p - in) = 1, which results in overflow in the doloop
   optimization.  */

static const char *
test (const char *in, char *out)
{
  while (1)
    {
      if (*in == 'a')
	{
	  const char *p = in + 1;
	  while (*p == 'x')
	    ++p;
	  if (*p == 'b')
	    return p;
	  while (in < p)
	    *out++ = *in++;
	}
    }
}

int main ()
{
  char out[4];
  test ("aab", out);
  return 0;
}
// source: 20011128-1.c
main()
{
  char blah[33] = "01234567890123456789";
  exit (0);
}
// source: 20011217-1.c
int
main()
{
  double x = 1.0;
  double y = 2.0;

  if ((y > x--) != 1)
    abort ();
  exit (0);
}
// source: 20011219-1.c
/* This testcase failed on IA-32 at -O and above, because combine attached
   a REG_LABEL note to jump instruction already using JUMP_LABEL.  */

extern void abort (void);
extern void exit (int);

enum X { A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q };

void
bar (const char *x, int y, const char *z)
{
}

long
foo (enum X x, const void *y)
{
  long a;

  switch (x)
    {
    case K:
      a = *(long *)y;
      break;
    case L:
      a = *(long *)y;
      break;
    case M:
      a = *(long *)y;
      break;
    case N:
      a = *(long *)y;
      break;
    case O:
      a = *(long *)y;
      break;
    default:
      bar ("foo", 1, "bar");
    }
  return a;
}

int
main ()
{
  long i = 24;
  if (foo (N, &i) != 24)
    abort ();
  exit (0);
}
// source: 20011223-1.c
/* Origin: Joseph Myers <jsm28@cam.ac.uk>.  */
/* Case labels in a switch statement are converted to the promoted
   type of the controlling expression, not an unpromoted version.
   Reported as PR c/2454 by
   Andreas Krakowczyk <Andreas.Krakowczyk@fujitsu-siemens.com>.  */

extern void exit (int);
extern void abort (void);

static int i;

int
main (void)
{
  i = -1;
  switch ((signed char) i) {
  case 255:
    abort ();
  default:
    exit (0);
  }
}
// source: 20020103-1.c
/* On h8300 port, the following used to be broken with -mh or -ms.  */

extern void abort (void);
extern void exit (int);

unsigned long
foo (unsigned long a)
{
  return a ^ 0x0000ffff;
}

unsigned long
bar (unsigned long a)
{
  return a ^ 0xffff0000;
}

int
main ()
{
  if (foo (0) != 0x0000ffff)
    abort ();

  if (bar (0) != 0xffff0000)
    abort ();

  exit (0);
}
// source: 20020107-1.c
/* This testcase failed because - 1 - buf was simplified into ~buf and when
   later expanding it back into - buf + -1, -1 got lost.  */
/* { dg-options "-fgnu89-inline" } */

extern void abort (void);
extern void exit (int);

static void
bar (int x)
{
  if (!x)
    abort ();
}

char buf[10];

inline char *
foo (char *tmp)
{
  asm ("" : "=r" (tmp) : "0" (tmp));
  return tmp + 2;
}

int
main (void)
{
  bar ((foo (buf) - 1 - buf) == 1);
  exit (0);
}
// source: 20020108-1.c
/* This file tests shifts in various integral modes.  */

#include <limits.h>

#define CAT(A, B) A ## B

#define REPEAT_8	\
REPEAT_FN ( 0)		\
REPEAT_FN ( 1)		\
REPEAT_FN ( 2)		\
REPEAT_FN ( 3)		\
REPEAT_FN ( 4)		\
REPEAT_FN ( 5)		\
REPEAT_FN ( 6)		\
REPEAT_FN ( 7)

#define REPEAT_16	\
REPEAT_8		\
REPEAT_FN ( 8)		\
REPEAT_FN ( 9)		\
REPEAT_FN (10)		\
REPEAT_FN (11)		\
REPEAT_FN (12)		\
REPEAT_FN (13)		\
REPEAT_FN (14)		\
REPEAT_FN (15)

#define REPEAT_32	\
REPEAT_16		\
REPEAT_FN (16)		\
REPEAT_FN (17)		\
REPEAT_FN (18)		\
REPEAT_FN (19)		\
REPEAT_FN (20)		\
REPEAT_FN (21)		\
REPEAT_FN (22)		\
REPEAT_FN (23)		\
REPEAT_FN (24)		\
REPEAT_FN (25)		\
REPEAT_FN (26)		\
REPEAT_FN (27)		\
REPEAT_FN (28)		\
REPEAT_FN (29)		\
REPEAT_FN (30)		\
REPEAT_FN (31)

/* Define 8-bit shifts.  */
#if CHAR_BIT == 8
typedef unsigned int u8 __attribute__((mode(QI)));
typedef signed int s8 __attribute__((mode(QI)));

#define REPEAT_FN(COUNT) \
u8 CAT (ashift_qi_, COUNT) (u8 n) { return n << COUNT; }
REPEAT_8
#undef REPEAT_FN

#define REPEAT_FN(COUNT) \
u8 CAT (lshiftrt_qi_, COUNT) (u8 n) { return n >> COUNT; }
REPEAT_8
#undef REPEAT_FN

#define REPEAT_FN(COUNT) \
s8 CAT (ashiftrt_qi_, COUNT) (s8 n) { return n >> COUNT; }
REPEAT_8
#undef REPEAT_FN
#endif /* CHAR_BIT == 8 */

/* Define 16-bit shifts.  */
#if CHAR_BIT == 8 || CHAR_BIT == 16
#if CHAR_BIT == 8
typedef unsigned int u16 __attribute__((mode(HI)));
typedef signed int s16 __attribute__((mode(HI)));
#elif CHAR_BIT == 16
typedef unsigned int u16 __attribute__((mode(QI)));
typedef signed int s16 __attribute__((mode(QI)));
#endif

#define REPEAT_FN(COUNT) \
u16 CAT (ashift_hi_, COUNT) (u16 n) { return n << COUNT; }
REPEAT_16
#undef REPEAT_FN

#define REPEAT_FN(COUNT) \
u16 CAT (lshiftrt_hi_, COUNT) (u16 n) { return n >> COUNT; }
REPEAT_16
#undef REPEAT_FN

#define REPEAT_FN(COUNT) \
s16 CAT (ashiftrt_hi_, COUNT) (s16 n) { return n >> COUNT; }
REPEAT_16
#undef REPEAT_FN
#endif /* CHAR_BIT == 8 || CHAR_BIT == 16 */

/* Define 32-bit shifts.  */
#if CHAR_BIT == 8 || CHAR_BIT == 16 || CHAR_BIT == 32
#if CHAR_BIT == 8
typedef unsigned int u32 __attribute__((mode(SI)));
typedef signed int s32 __attribute__((mode(SI)));
#elif CHAR_BIT == 16
typedef unsigned int u32 __attribute__((mode(HI)));
typedef signed int s32 __attribute__((mode(HI)));
#elif CHAR_BIT == 32
typedef unsigned int u32 __attribute__((mode(QI)));
typedef signed int s32 __attribute__((mode(QI)));
#endif

#define REPEAT_FN(COUNT) \
u32 CAT (ashift_si_, COUNT) (u32 n) { return n << COUNT; }
REPEAT_32
#undef REPEAT_FN

#define REPEAT_FN(COUNT) \
u32 CAT (lshiftrt_si_, COUNT) (u32 n) { return n >> COUNT; }
REPEAT_32
#undef REPEAT_FN

#define REPEAT_FN(COUNT) \
s32 CAT (ashiftrt_si_, COUNT) (s32 n) { return n >> COUNT; }
REPEAT_32
#undef REPEAT_FN
#endif /* CHAR_BIT == 8 || CHAR_BIT == 16 || CHAR_BIT == 32 */

extern void abort (void);
extern void exit (int);

int
main ()
{
  /* Test 8-bit shifts.  */
#if CHAR_BIT == 8
# define REPEAT_FN(COUNT) \
  if (CAT (ashift_qi_, COUNT) (0xff) != (u8) ((u8)0xff << COUNT)) abort ();
  REPEAT_8;
# undef REPEAT_FN

# define REPEAT_FN(COUNT) \
  if (CAT (lshiftrt_qi_, COUNT) (0xff) != (u8) ((u8)0xff >> COUNT)) abort ();
  REPEAT_8;
# undef REPEAT_FN

# define REPEAT_FN(COUNT) \
  if (CAT (ashiftrt_qi_, COUNT) (-1) != -1) abort ();
  REPEAT_8;
# undef REPEAT_FN

# define REPEAT_FN(COUNT) \
  if (CAT (ashiftrt_qi_, COUNT) (0) != 0) abort ();
  REPEAT_8;
# undef REPEAT_FN
#endif /* CHAR_BIT == 8 */

  /* Test 16-bit shifts.  */
#if CHAR_BIT == 8 || CHAR_BIT == 16
# define REPEAT_FN(COUNT)			\
  if (CAT (ashift_hi_, COUNT) (0xffff)		\
      != (u16) ((u16) 0xffff << COUNT)) abort ();
  REPEAT_16;
# undef REPEAT_FN

# define REPEAT_FN(COUNT)			\
  if (CAT (lshiftrt_hi_, COUNT) (0xffff)	\
      != (u16) ((u16) 0xffff >> COUNT)) abort ();
  REPEAT_16;
# undef REPEAT_FN

# define REPEAT_FN(COUNT) \
  if (CAT (ashiftrt_hi_, COUNT) (-1) != -1) abort ();
  REPEAT_16;
# undef REPEAT_FN

# define REPEAT_FN(COUNT) \
  if (CAT (ashiftrt_hi_, COUNT) (0) != 0) abort ();
  REPEAT_16;
# undef REPEAT_FN
#endif /* CHAR_BIT == 8 || CHAR_BIT == 16 */

  /* Test 32-bit shifts.  */
#if CHAR_BIT == 8 || CHAR_BIT == 16 || CHAR_BIT == 32
# define REPEAT_FN(COUNT)				\
  if (CAT (ashift_si_, COUNT) (0xffffffff)		\
      != (u32) ((u32) 0xffffffff << COUNT)) abort ();
  REPEAT_32;
# undef REPEAT_FN

# define REPEAT_FN(COUNT)				\
  if (CAT (lshiftrt_si_, COUNT) (0xffffffff)		\
      != (u32) ((u32) 0xffffffff >> COUNT)) abort ();
  REPEAT_32;
# undef REPEAT_FN

# define REPEAT_FN(COUNT) \
  if (CAT (ashiftrt_si_, COUNT) (-1) != -1) abort ();
  REPEAT_32;
# undef REPEAT_FN

# define REPEAT_FN(COUNT) \
  if (CAT (ashiftrt_si_, COUNT) (0) != 0) abort ();
  REPEAT_32;
# undef REPEAT_FN
#endif /* CHAR_BIT == 8 || CHAR_BIT == 16 || CHAR_BIT == 32 */

  exit (0);
}
// source: 20020118-1.c
/* This tests an insn length of sign extension on h8300 port.  */

extern void exit (int);

volatile signed char *q;
volatile signed int n;

void
foo (void)
{
  signed char *p;

  for (;;)
    {
      p = (signed char *) q; n = p[2];
      p = (signed char *) q; n = p[2];
      p = (signed char *) q; n = p[2];
      p = (signed char *) q; n = p[2];
      p = (signed char *) q; n = p[2];
      p = (signed char *) q; n = p[2];
      p = (signed char *) q; n = p[2];
      p = (signed char *) q; n = p[2];
      p = (signed char *) q; n = p[2];
      p = (signed char *) q; n = p[2];
      p = (signed char *) q; n = p[2];
    }
}

int
main ()
{
  exit (0);
}
// source: 20020127-1.c
/* This used to fail on h8300.  */

extern void abort (void);
extern void exit (int);

unsigned long
foo (unsigned long n)
{
  return (~n >> 3) & 1;
}

int
main ()
{
  if (foo (1 << 3) != 0)
    abort ();

  if (foo (0) != 1)
    abort ();

  exit (0);
}
// source: 20020129-1.c
/* This testcase failed at -O2 on IA-64, because scheduling did not take
   into account conditional execution when using cselib for alias
   analysis.  */

struct D { int d1; struct D *d2; };
struct C { struct D c1; long c2, c3, c4, c5, c6; };
struct A { struct A *a1; struct C *a2; };
struct B { struct C b1; struct A *b2; };

extern void abort (void);
extern void exit (int);

void
foo (struct B *x, struct B *y)
{
  if (x->b2 == 0)
    {
      struct A *a;

      x->b2 = a = y->b2;
      y->b2 = 0;
      for (; a; a = a->a1)
	a->a2 = &x->b1;
    }

  if (y->b2 != 0)
    abort ();

  if (x->b1.c3 == -1)
    {
      x->b1.c3 = y->b1.c3;
      x->b1.c4 = y->b1.c4;
      y->b1.c3 = -1;
      y->b1.c4 = 0;
    }

  if (y->b1.c3 != -1)
    abort ();
}

struct B x, y;

int main ()
{
  y.b1.c1.d1 = 6;
  y.b1.c3 = 145;
  y.b1.c4 = 2448;
  x.b1.c3 = -1;
  foo (&x, &y);
  exit (0);
}
// source: 20020201-1.c
/* Test whether division by constant works properly.  */

extern void abort (void);
extern void exit (int);

unsigned char cx = 7;
unsigned short sx = 14;
unsigned int ix = 21;
unsigned long lx = 28;
unsigned long long Lx = 35;

int
main ()
{
  unsigned char cy;
  unsigned short sy;
  unsigned int iy;
  unsigned long ly;
  unsigned long long Ly;

  cy = cx / 6; if (cy != 1) abort ();
  cy = cx % 6; if (cy != 1) abort ();

  sy = sx / 6; if (sy != 2) abort ();
  sy = sx % 6; if (sy != 2) abort ();

  iy = ix / 6; if (iy != 3) abort ();
  iy = ix % 6; if (iy != 3) abort ();

  ly = lx / 6; if (ly != 4) abort ();
  ly = lx % 6; if (ly != 4) abort ();

  Ly = Lx / 6; if (Ly != 5) abort ();
  Ly = Lx % 6; if (Ly != 5) abort ();

  exit(0);
}
// source: 20020206-1.c
struct A {
  unsigned int a, b, c;
};

extern void abort (void);
extern void exit (int);

struct A bar (void)
{
  return (struct A) { 176, 52, 31 };
}

void baz (struct A *a)
{
  if (a->a != 176 || a->b != 52 || a->c != 31)
    abort ();
}

int main ()
{
  struct A d;

  d = ({ ({ bar (); }); });
  baz (&d);
  exit (0);
}
// source: 20020206-2.c
/* Origin: PR c/5420 from David Mosberger <davidm@hpl.hp.com>.
   This testcase was miscompiled when tail call optimizing, because a
   compound literal initialization was emitted only in the tail call insn
   chain, not in the normal call insn chain.  */

typedef struct { unsigned short a; } A;

extern void abort (void);
extern void exit (int);

void foo (unsigned int x)
{
  if (x != 0x800 && x != 0x810)
    abort ();
}

int
main (int argc, char **argv)
{
  int i;
  for (i = 0; i < 2; ++i)
    foo (((A) { ((!(i >> 4) ? 8 : 64 + (i >> 4)) << 8) + (i << 4) } ).a);
  exit (0);
}
// source: 20020213-1.c
/* PR c/5681
   This testcase failed on IA-32 at -O0, because safe_from_p
   incorrectly assumed it is safe to first write into a.a2 b-1
   and then read the original value from it.  */

int bar (float);

struct A {
  float a1;
  int a2;
} a;

int b;

void foo (void)
{
  a.a2 = bar (a.a1);
  a.a2 = a.a2 < b - 1 ? a.a2 : b - 1;
  if (a.a2 >= b - 1)
    abort ();
}

int bar (float x)
{
  return 2241;
}

int main()
{
  a.a1 = 1.0f;
  b = 3384;
  foo ();
  return 0;
}
// source: 20020215-1.c
/* Test failed on an architecture that:

   - had 16-bit registers,
   - passed 64-bit structures in registers,
   - only allowed SImode values in even numbered registers.

   Before reload, s.i2 in foo() was represented as:

	(subreg:SI (reg:DI 0) 2)

   find_dummy_reload would return (reg:SI 1) for the subreg reload,
   despite that not being a valid register.  */

struct s
{
  short i1;
  long i2;
  short i3;
};

struct s foo (struct s s)
{
  s.i2++;
  return s;
}

int main ()
{
  struct s s = foo ((struct s) { 1000, 2000L, 3000 });
  if (s.i1 != 1000 || s.i2 != 2001L || s.i3 != 3000)
    abort ();
  exit (0);
}
// source: 20020216-1.c
/* PR c/3444
   This used to fail because bitwise xor was improperly computed in char type
   and sign extended to int type.  */

extern void abort ();
extern void exit (int);

signed char c = (signed char) 0xffffffff;

int foo (void)
{
  return (unsigned short) c ^ (signed char) 0x99999999;
}

int main (void)
{
  if ((unsigned char) -1 != 0xff
      || sizeof (short) != 2
      || sizeof (int) != 4)
    exit (0);
  if (foo () != (int) 0xffff0066)
    abort ();
  exit (0);
}
// source: 20020219-1.c
/* PR c/4308
   This testcase failed because 0x8000000000000000 >> 0
   was incorrectly folded into 0xffffffff00000000.  */

extern void abort (void);
extern void exit (int);

long long foo (void)
{
  long long C = 1ULL << 63, X;
  int Y = 32;
  X = C >> (Y & 31);
  return X;
}

int main (void)
{
  if (foo () != 1ULL << 63)
    abort ();
  exit (0);
}
// source: 20020225-1.c
/* This testcase failed at -O2 on powerpc64 due to andsi3 writing
   nonzero bits to the high 32 bits of a 64 bit register.  */

extern void abort (void);
extern void exit (int);

unsigned long foo (unsigned long base, unsigned int val)
{
  return base + (val & 0x80000001);
}

int main (void)
{
  if (foo (0L, 0x0ffffff0) != 0L)
    abort ();
  exit (0);
}
// source: 20020225-2.c
static int
test(int x)
{
  union
    {
      int i;
      double d;
  } a;
  a.d = 0;
  a.i = 1;
  return x >> a.i;
}

int main(void)
{
  if (test (5) != 2)
    abort ();
  exit (0);
}
// source: 20020226-1.c
/* This tests the rotate patterns that some machines support.  */

#include <limits.h>

#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

#define ROR(a,b) (((a) >> (b)) | ((a) << ((sizeof (a) * CHAR_BIT) - (b))))
#define ROL(a,b) (((a) << (b)) | ((a) >> ((sizeof (a) * CHAR_BIT) - (b))))

#define CHAR_VALUE ((unsigned char)0x1234U)
#define SHORT_VALUE ((unsigned short)0x1234U)
#define INT_VALUE 0x1234U
#define LONG_VALUE 0x12345678LU
#define LL_VALUE 0x12345678abcdef0LLU

#define SHIFT1 4
#define SHIFT2 ((sizeof (long long) * CHAR_BIT) - SHIFT1)

unsigned char uc = CHAR_VALUE;
unsigned short us = SHORT_VALUE;
unsigned int ui = INT_VALUE;
unsigned long ul = LONG_VALUE;
unsigned long long ull = LL_VALUE;
int shift1 = SHIFT1;
int shift2 = SHIFT2;

main ()
{
  if (ROR (uc, shift1) != ROR (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROR (uc, SHIFT1) != ROR (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROR (us, shift1) != ROR (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROR (us, SHIFT1) != ROR (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROR (ui, shift1) != ROR (INT_VALUE, SHIFT1))
    abort ();

  if (ROR (ui, SHIFT1) != ROR (INT_VALUE, SHIFT1))
    abort ();

  if (ROR (ul, shift1) != ROR (LONG_VALUE, SHIFT1))
    abort ();

  if (ROR (ul, SHIFT1) != ROR (LONG_VALUE, SHIFT1))
    abort ();

  if (ROR (ull, shift1) != ROR (LL_VALUE, SHIFT1))
    abort ();

  if (ROR (ull, SHIFT1) != ROR (LL_VALUE, SHIFT1))
    abort ();

  if (ROR (ull, shift2) != ROR (LL_VALUE, SHIFT2))
    abort ();

  if (ROR (ull, SHIFT2) != ROR (LL_VALUE, SHIFT2))
    abort ();

  if (ROL (uc, shift1) != ROL (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROL (uc, SHIFT1) != ROL (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROL (us, shift1) != ROL (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROL (us, SHIFT1) != ROL (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROL (ui, shift1) != ROL (INT_VALUE, SHIFT1))
    abort ();

  if (ROL (ui, SHIFT1) != ROL (INT_VALUE, SHIFT1))
    abort ();

  if (ROL (ul, shift1) != ROL (LONG_VALUE, SHIFT1))
    abort ();

  if (ROL (ul, SHIFT1) != ROL (LONG_VALUE, SHIFT1))
    abort ();

  if (ROL (ull, shift1) != ROL (LL_VALUE, SHIFT1))
    abort ();

  if (ROL (ull, SHIFT1) != ROL (LL_VALUE, SHIFT1))
    abort ();

  if (ROL (ull, shift2) != ROL (LL_VALUE, SHIFT2))
    abort ();

  if (ROL (ull, SHIFT2) != ROL (LL_VALUE, SHIFT2))
    abort ();

  exit (0);
}
// source: 20020227-1.c
/* This testcase failed on mmix-knuth-mmixware.  Problem was with storing
   to an unaligned mem:SC, gcc tried doing it by parts from a (concat:SC
   (reg:SF 293) (reg:SF 294)).  */

typedef __complex__ float cf;
struct x { char c; cf f; } __attribute__ ((__packed__));
extern void f2 (struct x*);
extern void f1 (void);
int
main (void)
{
  f1 ();
  exit (0);
}

void
f1 (void)
{
  struct x s;
  s.f = 1;
  s.c = 42;
  f2 (&s);
}

void
f2 (struct x *y)
{
  if (y->f != 1 || y->c != 42)
    abort ();
}
// source: 20020307-1.c
#define MASK(N) ((1UL << (N)) - 1)
#define BITS(N) ((1UL << ((N) - 1)) + 2)

#define FUNC(N) void f##N(long j) { if ((j & MASK(N)) >= BITS(N)) abort();}

FUNC(3)
FUNC(4)
FUNC(5)
FUNC(6)
FUNC(7)
FUNC(8)
FUNC(9)
FUNC(10)
FUNC(11)
FUNC(12)
FUNC(13)
FUNC(14)
FUNC(15)
FUNC(16)
FUNC(17)
FUNC(18)
FUNC(19)
FUNC(20)
FUNC(21)
FUNC(22)
FUNC(23)
FUNC(24)
FUNC(25)
FUNC(26)
FUNC(27)
FUNC(28)
FUNC(29)
FUNC(30)
FUNC(31)

int main ()
{
  f3(0);
  f4(0);
  f5(0);
  f6(0);
  f7(0);
  f8(0);
  f9(0);
  f10(0);
  f11(0);
  f12(0);
  f13(0);
  f14(0);
  f15(0);
  f16(0);
  f17(0);
  f18(0);
  f19(0);
  f20(0);
  f21(0);
  f22(0);
  f23(0);
  f24(0);
  f25(0);
  f26(0);
  f27(0);
  f28(0);
  f29(0);
  f30(0);
  f31(0);

  exit(0);
}
// source: 20020314-1.c
/* { dg-require-effective-target alloca } */
void f(void * a, double y)
{
}

double g (double a, double b, double c, double d)
{
  double x, y, z;
  void *p;

  x = a + b;
  y = c * d;

  p = alloca (16);

  f(p, y);
  z = x * y * a;

  return z + b;
}

main ()
{
  double a, b, c, d;
  a = 1.0;
  b = 0.0;
  c = 10.0;
  d = 0.0;

  if (g (a, b, c, d) != 0.0)
    abort ();

  if (a != 1.0 || b != 0.0 || c != 10.0 || d != 0.0)
    abort ();

  exit (0);
}
// source: 20020320-1.c
/* PR c/5354 */
/* Verify that GCC preserves relevant stack slots.  */

extern void abort(void);
extern void exit(int);

struct large { int x, y[9]; };

int main()
{
  int fixed;

  fixed = ({ int temp1 = 2; temp1; }) - ({ int temp2 = 1; temp2; });
  if (fixed != 1)
    abort();

  fixed = ({ struct large temp3; temp3.x = 2; temp3; }).x
	  - ({ struct large temp4; temp4.x = 1; temp4; }).x;
  if (fixed != 1)
    abort();

  exit(0);
}
// source: 20020321-1.c
/* PR 3177 */
/* Produced a SIGILL on ia64 with sibcall from F to G.  We hadn't
   widened the register window to allow for the fourth outgoing
   argument as an "in" register.  */

float g (void *a, void *b, int e, int c, float d)
{
  return d;
}

float f (void *a, void *b, int c, float d)
{
  return g (a, b, 0, c, d);
}

int main ()
{
  f (0, 0, 1, 1);
  return 0;
}
// source: 20020328-1.c
int b = 0;

func () { }

void
testit(int x)
{
  if (x != 20)
    abort ();
}

int
main()

{
  int a = 0;

  if (b)
    func();

  /* simplify_and_const_int would incorrectly omit the mask in
     the line below.  */
  testit ((a + 23) & 0xfffffffc);
  exit (0);
}
// source: 20020402-1.c
/* derived from PR c/2100 */

extern void abort ();
extern void exit (int);

#define SMALL_N  2
#define NUM_ELEM 4

int main(void)
{
  int listElem[NUM_ELEM]={30,2,10,5};
  int listSmall[SMALL_N];
  int i, j;
  int posGreatest=-1, greatest=-1;

  for (i=0; i<SMALL_N; i++) {
    listSmall[i] = listElem[i];
    if (listElem[i] > greatest) {
      posGreatest = i;
      greatest = listElem[i];
    }
  }

  for (i=SMALL_N; i<NUM_ELEM; i++) {
    if (listElem[i] < greatest) {
      listSmall[posGreatest] = listElem[i];
      posGreatest = 0;
      greatest = listSmall[0];
      for (j=1; j<SMALL_N; j++)
	if (listSmall[j] > greatest) {
	  posGreatest = j;
	  greatest = listSmall[j];
	}
    }
  }

  if (listSmall[0] != 5 || listSmall[1] != 2)
    abort ();
  exit (0);
}
// source: 20020402-2.c
/* PR 3967

   local-alloc screwed up consideration of high+lo_sum and created
   reg_equivs that it shouldn't have, resulting in lo_sum with
   uninitialized data, resulting in segv.  The test has to remain
   relatively large, since register spilling is required to twig
   the bug.  */

unsigned long *Local1;
unsigned long *Local2;
unsigned long *Local3;
unsigned long *RDbf1;
unsigned long *RDbf2;
unsigned long *RDbf3;
unsigned long *IntVc1;
unsigned long *IntVc2;
unsigned long *IntCode3;
unsigned long *IntCode4;
unsigned long *IntCode5;
unsigned long *IntCode6;
unsigned long *Lom1;
unsigned long *Lom2;
unsigned long *Lom3;
unsigned long *Lom4;
unsigned long *Lom5;
unsigned long *Lom6;
unsigned long *Lom7;
unsigned long *Lom8;
unsigned long *Lom9;
unsigned long *Lom10;
unsigned long *RDbf11;
unsigned long *RDbf12;

typedef struct
  {
    long a1;
    unsigned long n1;
    unsigned long local1;
    unsigned long local2;
    unsigned long local3;
    unsigned long rdbf1;
    unsigned long rdbf2;
    unsigned long milli;
    unsigned long frames1;
    unsigned long frames2;
    unsigned long nonShared;
    long newPrivate;
    long freeLimit;
    unsigned long cache1;
    unsigned long cache2;
    unsigned long cache3;
    unsigned long cache4;
    unsigned long cache5;
    unsigned long time6;
    unsigned long frames7;
    unsigned long page8;
    unsigned long ot9;
    unsigned long data10;
    unsigned long bm11;
    unsigned long misc12;
  }
ShrPcCommonStatSType;


typedef struct
  {
    unsigned long sharedAttached;
    unsigned long totalAttached;
    long avgPercentShared;
    unsigned long numberOfFreeFrames;
    unsigned long localDirtyPageCount;
    unsigned long globalDirtyPageCount;
    long wakeupInterval;
    unsigned long numActiveProcesses;
    unsigned long numRecentActiveProcesses;
    unsigned long gemDirtyPageKinds[10];
    unsigned long stoneDirtyPageKinds[10];
    unsigned long gemsInCacheCount;
    long targetFreeFrameCount;
  }
ShrPcMonStatSType;

typedef struct
  {
    unsigned long c1;
    unsigned long c2;
    unsigned long c3;
    unsigned long c4;
    unsigned long c5;
    unsigned long c6;
    unsigned long c7;
    unsigned long c8;
    unsigned long c9;
    unsigned long c10;
    unsigned long c11;
    unsigned long c12;
    unsigned long a1;
    unsigned long a2;
    unsigned long a3;
    unsigned long a4;
    unsigned long a5;
    unsigned long a6;
    unsigned long a7;
    unsigned long a8;
    unsigned long a9;
    unsigned long a10;
    unsigned long a11;
    unsigned long a12;
    unsigned long a13;
    unsigned long a14;
    unsigned long a15;
    unsigned long a16;
    unsigned long a17;
    unsigned long a18;
    unsigned long a19;
    unsigned long sessionStats[40];
  }
ShrPcGemStatSType;

union ShrPcStatUnion
  {
    ShrPcMonStatSType monitor;
    ShrPcGemStatSType gem;
  };

typedef struct
  {
    int processId;
    int sessionId;
    ShrPcCommonStatSType cmn;
    union ShrPcStatUnion u;
  } ShrPcStatsSType;

typedef struct
  {
    unsigned long *p1;
    unsigned long *p2;
    unsigned long *p3;
    unsigned long *p4;
    unsigned long *p5;
    unsigned long *p6;
    unsigned long *p7;
    unsigned long *p8;
    unsigned long *p9;
    unsigned long *p10;
    unsigned long *p11;
  }
WorkEntrySType;

WorkEntrySType Workspace;

static void
setStatPointers (ShrPcStatsSType * statsPtr, long sessionId)
{
  statsPtr->sessionId = sessionId;
  statsPtr->cmn.a1 = 0;
  statsPtr->cmn.n1 = 5;

  Local1 = &statsPtr->cmn.local1;
  Local2 = &statsPtr->cmn.local2;
  Local3 = &statsPtr->cmn.local3;
  RDbf1 = &statsPtr->cmn.rdbf1;
  RDbf2 = &statsPtr->cmn.rdbf2;
  RDbf3 = &statsPtr->cmn.milli;
  *RDbf3 = 1;

  IntVc1 = &statsPtr->u.gem.a1;
  IntVc2 = &statsPtr->u.gem.a2;
  IntCode3 = &statsPtr->u.gem.a3;
  IntCode4 = &statsPtr->u.gem.a4;
  IntCode5 = &statsPtr->u.gem.a5;
  IntCode6 = &statsPtr->u.gem.a6;

  {
    WorkEntrySType *workSpPtr;
    workSpPtr = &Workspace;
    workSpPtr->p1 = &statsPtr->u.gem.a7;
    workSpPtr->p2 = &statsPtr->u.gem.a8;
    workSpPtr->p3 = &statsPtr->u.gem.a9;
    workSpPtr->p4 = &statsPtr->u.gem.a10;
    workSpPtr->p5 = &statsPtr->u.gem.a11;
    workSpPtr->p6 = &statsPtr->u.gem.a12;
    workSpPtr->p7 = &statsPtr->u.gem.a13;
    workSpPtr->p8 = &statsPtr->u.gem.a14;
    workSpPtr->p9 = &statsPtr->u.gem.a15;
    workSpPtr->p10 = &statsPtr->u.gem.a16;
    workSpPtr->p11 = &statsPtr->u.gem.a17;
  }
  Lom1 = &statsPtr->u.gem.c1;
  Lom2 = &statsPtr->u.gem.c2;
  Lom3 = &statsPtr->u.gem.c3;
  Lom4 = &statsPtr->u.gem.c4;
  Lom5 = &statsPtr->u.gem.c5;
  Lom6 = &statsPtr->u.gem.c6;
  Lom7 = &statsPtr->u.gem.c7;
  Lom8 = &statsPtr->u.gem.c8;
  Lom9 = &statsPtr->u.gem.c9;
  Lom10 = &statsPtr->u.gem.c10;
  RDbf11 = &statsPtr->u.gem.c11;
  RDbf12 = &statsPtr->u.gem.c12;
}

typedef struct
{
  ShrPcStatsSType stats;
} ShrPcPteSType;

ShrPcPteSType MyPte;

static void
initPte (void *shrpcPtr, long sessionId)
{
  ShrPcPteSType *ptePtr;

  ptePtr = &MyPte;
  setStatPointers (&ptePtr->stats, sessionId);
}

void
InitCache (int sessionId)
{
  initPte (0, sessionId);
}

int
main (int argc, char *argv[])
{
  InitCache (5);
  return 0;
}
// source: 20020402-3.c
/* extracted from gdb sources */

typedef unsigned long long CORE_ADDR;

struct blockvector;

struct symtab {
  struct blockvector *blockvector;
};

struct sec {
  void *unused;
};

struct symbol {
  int len;
  char *name;
};

struct block {
	CORE_ADDR startaddr, endaddr;
	struct symbol *function;
	struct block *superblock;
	unsigned char gcc_compile_flag;
	int nsyms;
	struct symbol syms[1];
};

struct blockvector {
	int nblocks;
	struct block *block[2];
};

struct blockvector *blockvector_for_pc_sect(register CORE_ADDR pc,
					    struct symtab *symtab)
{
  register struct block *b;
  register int bot, top, half;
  struct blockvector *bl;

  bl = symtab->blockvector;
  b = bl->block[0];

  bot = 0;
  top = bl->nblocks;

  while (top - bot > 1)
    {
      half = (top - bot + 1) >> 1;
      b = bl->block[bot + half];
      if (b->startaddr <= pc)
	bot += half;
      else
	top = bot + half;
    }

  while (bot >= 0)
    {
      b = bl->block[bot];
      if (b->endaddr > pc)
	{
	  return bl;
	}
      bot--;
    }
  return 0;
}

int main(void)
{
  struct block a = { 0, 0x10000, 0, 0, 1, 20 };
  struct block b = { 0x10000, 0x20000, 0, 0, 1, 20 };
  struct blockvector bv = { 2, { &a, &b } };
  struct symtab s = { &bv };

  struct blockvector *ret;

  ret = blockvector_for_pc_sect(0x500, &s);

  return 0;
}
// source: 20020404-1.c
/* { dg-require-effective-target int32plus } */
/* { dg-skip-if "pointers can be truncated" { m32c-*-* } } */
/* Extracted from GDB sources. */

typedef long long bfd_signed_vma;
typedef bfd_signed_vma file_ptr;

typedef enum bfd_boolean {false, true} boolean;

typedef unsigned long long bfd_size_type;

typedef unsigned int flagword;

typedef unsigned long long CORE_ADDR;
typedef unsigned long long bfd_vma;

struct bfd_struct {
	int x;
};

struct asection_struct {
  unsigned int user_set_vma : 1;
  bfd_vma vma;
  bfd_vma lma;
  unsigned int alignment_power;
  unsigned int entsize;
};

typedef struct bfd_struct bfd;
typedef struct asection_struct asection;

static bfd *
bfd_openw_with_cleanup (char *filename, const char *target, char *mode);

static asection *
bfd_make_section_anyway (bfd *abfd, const char *name);

static boolean
bfd_set_section_size (bfd *abfd, asection *sec, bfd_size_type val);

static boolean
bfd_set_section_flags (bfd *abfd, asection *sec, flagword flags);

static boolean
bfd_set_section_contents (bfd *abfd, asection *section, void * data, file_ptr offset, bfd_size_type count);

static void
dump_bfd_file (char *filename, char *mode,
               char *target, CORE_ADDR vaddr,
               char *buf, int len)
{
  bfd *obfd;
  asection *osection;

  obfd = bfd_openw_with_cleanup (filename, target, mode);
  osection = bfd_make_section_anyway (obfd, ".newsec");
  bfd_set_section_size (obfd, osection, len);
  (((osection)->vma = (osection)->lma= (vaddr)), ((osection)->user_set_vma = (boolean)true), true);
  (((osection)->alignment_power = (0)),true);
  bfd_set_section_flags (obfd, osection, 0x203);
  osection->entsize = 0;
  bfd_set_section_contents (obfd, osection, buf, 0, len);
}

static bfd *
bfd_openw_with_cleanup (char *filename, const char *target, char *mode)
{
	static bfd foo_bfd = { 0 };
	return &foo_bfd;
}

static asection *
bfd_make_section_anyway (bfd *abfd, const char *name)
{
	static asection foo_section = { false, 0x0, 0x0, 0 };

	return &foo_section;
}

static boolean
bfd_set_section_size (bfd *abfd, asection *sec, bfd_size_type val)
{
	return true;
}

static boolean
bfd_set_section_flags (bfd *abfd, asection *sec, flagword flags)
{
}

static boolean
bfd_set_section_contents (bfd *abfd, asection *section, void * data, file_ptr offset, bfd_size_type count)
{
	if (count != (bfd_size_type)0x1eadbeef)
		abort();
}

static char hello[] = "hello";

int main(void)
{
	dump_bfd_file(0, 0, 0, (CORE_ADDR)0xdeadbeef, hello, (int)0x1eadbeef);
	exit(0);
}
// source: 20020406-1.c
// Origin: abbott@dima.unige.it
// PR c/5120

extern void * malloc (__SIZE_TYPE__);
extern void * calloc (__SIZE_TYPE__, __SIZE_TYPE__);

typedef unsigned int FFelem;

FFelem FFmul(const FFelem x, const FFelem y)
{
  return x;
}


struct DUPFFstruct
{
  int maxdeg;
  int deg;
  FFelem *coeffs;
};

typedef struct DUPFFstruct *DUPFF;


int DUPFFdeg(const DUPFF f)
{
  return f->deg;
}


DUPFF DUPFFnew(const int maxdeg)
{
  DUPFF ans = (DUPFF)malloc(sizeof(struct DUPFFstruct));
  ans->coeffs = 0;
  if (maxdeg >= 0) ans->coeffs = (FFelem*)calloc(maxdeg+1,sizeof(FFelem));
  ans->maxdeg = maxdeg;
  ans->deg = -1;
  return ans;
}

void DUPFFfree(DUPFF x)
{
}

void DUPFFswap(DUPFF x, DUPFF y)
{
}


DUPFF DUPFFcopy(const DUPFF x)
{
  return x;
}


void DUPFFshift_add(DUPFF f, const DUPFF g, int deg, const FFelem coeff)
{
}


DUPFF DUPFFexgcd(DUPFF *fcofac, DUPFF *gcofac, const DUPFF f, const DUPFF g)
{
  DUPFF u, v, uf, ug, vf, vg;
  FFelem q, lcu, lcvrecip, p;
  int df, dg, du, dv;

  printf("DUPFFexgcd called on degrees %d and %d\n", DUPFFdeg(f), DUPFFdeg(g));
  if (DUPFFdeg(f) < DUPFFdeg(g)) return DUPFFexgcd(gcofac, fcofac, g, f);  /*** BUG IN THIS LINE ***/
  if (DUPFFdeg(f) != 2 || DUPFFdeg(g) != 1) abort();
  if (f->coeffs[0] == 0) return f;
  /****** NEVER REACH HERE IN THE EXAMPLE ******/
  p = 2;

  df = DUPFFdeg(f);  if (df < 0) df = 0; /* both inputs are zero */
  dg = DUPFFdeg(g);  if (dg < 0) dg = 0; /* one input is zero */
  u = DUPFFcopy(f);
  v = DUPFFcopy(g);

  uf = DUPFFnew(dg); uf->coeffs[0] = 1; uf->deg = 0;
  ug = DUPFFnew(df);
  vf = DUPFFnew(dg);
  vg = DUPFFnew(df); vg->coeffs[0] = 1; vg->deg = 0;

  while (DUPFFdeg(v) > 0)
  {
    dv = DUPFFdeg(v);
    lcvrecip = FFmul(1, v->coeffs[dv]);
    while (DUPFFdeg(u) >= dv)
    {
      du = DUPFFdeg(u);
      lcu = u->coeffs[du];
      q = FFmul(lcu, lcvrecip);
      DUPFFshift_add(u, v, du-dv, p-q);
      DUPFFshift_add(uf, vf, du-dv, p-q);
      DUPFFshift_add(ug, vg, du-dv, p-q);
    }
    DUPFFswap(u, v);
    DUPFFswap(uf, vf);
    DUPFFswap(ug, vg);
  }
  if (DUPFFdeg(v) == 0)
  {
    DUPFFswap(u, v);
    DUPFFswap(uf, vf);
    DUPFFswap(ug, vg);
  }
  DUPFFfree(vf);
  DUPFFfree(vg);
  DUPFFfree(v);
  *fcofac = uf;
  *gcofac = ug;
  return u;
}



int main()
{
  DUPFF f, g, cf, cg, h;
  f = DUPFFnew(1); f->coeffs[1] = 1; f->deg = 1;
  g = DUPFFnew(2); g->coeffs[2] = 1; g->deg = 2;

  printf("calling DUPFFexgcd on degrees %d and %d\n", DUPFFdeg(f), DUPFFdeg(g)) ;
  h = DUPFFexgcd(&cf, &cg, f, g);
  return 0;
}
// source: 20020411-1.c
/* PR optimization/6177
   This testcase ICEd because expr.c did not expect to see a CONCAT
   as array rtl.  */

extern void abort (void);
extern void exit (int);

__complex__ float foo (void)
{
  __complex__ float f[1];
  __real__ f[0] = 1.0;
  __imag__ f[0] = 1.0;
  f[0] = __builtin_conjf (f[0]);
  return f[0];
}

int main (void)
{
  __complex__ double d[1];
  d[0] = foo ();
  if (__real__ d[0] != 1.0
      || __imag__ d[0] != -1.0)
    abort ();
  exit (0);
}
// source: 20020412-1.c
/* PR c/3711
   This testcase ICEd on IA-32 at -O0 and was miscompiled otherwise,
   because std_expand_builtin_va_arg didn't handle variable size types.  */
/* { dg-require-effective-target alloca } */

#include <stdarg.h>

extern void abort (void);
extern void exit (int);

void bar (int c)
{
  static int d = '0';

  if (c != d++)
    abort ();
  if (c < '0' || c > '9')
    abort ();
}

void foo (int size, ...)
{
  struct
  {
    char x[size];
  } d;
  va_list ap;
  int i;

  va_start (ap, size);
  d = va_arg (ap, typeof (d));
  for (i = 0; i < size; i++)
    bar (d.x[i]);
  d = va_arg (ap, typeof (d));
  for (i = 0; i < size; i++)
    bar (d.x[i]);
  va_end (ap);
}

int main (void)
{
  int z = 5;
  struct { char a[z]; } x, y;

  x.a[0] = '0';
  x.a[1] = '1';
  x.a[2] = '2';
  x.a[3] = '3';
  x.a[4] = '4';
  y.a[0] = '5';
  y.a[1] = '6';
  y.a[2] = '7';
  y.a[3] = '8';
  y.a[4] = '9';
  foo (z, x, y);
  exit (0);
}
// source: 20020413-1.c
void test(long double val, int *eval)
{
  long double tmp = 1.0l;
  int i = 0;

  if (val < 0.0l)
    val = -val;

  if (val >= tmp)
    while (tmp < val)
      {
	tmp *= 2.0l;
	if (i++ >= 10)
	  abort ();
      }
  else if (val != 0.0l)
    while (val < tmp)
      {
	tmp /= 2.0l;
	if (i++ >= 10)
	  abort ();
      }

  *eval = i;
}

int main(void)
{
  int eval;

  test(3.0, &eval);
  test(3.5, &eval);
  test(4.0, &eval);
  test(5.0, &eval);
  exit (0);
}
// source: 20020418-1.c
/* ifcvt accidentally deletes a referenced label while generating
   conditional traps on machines having such patterns */

struct foo { int a; };

void gcc_crash(struct foo *p)
{
	if (__builtin_expect(p->a < 52, 0))
		__builtin_trap();
 top:
	p->a++;
	if (p->a >= 62)
		goto top;
}

int main(void)
{
	struct foo x;

	x.a = 53;
	gcc_crash(&x);

	exit (0);
}
// source: 20020423-1.c
/* PR c/5430 */
/* Verify that the multiplicative folding code is not fooled
   by the mix between signed variables and unsigned constants. */

extern void abort (void);
extern void exit (int);

int main (void)
{
  int my_int = 924;
  unsigned int result;

  result = ((my_int*2 + 4) - 8U) / 2;
  if (result != 922U)
    abort();

  result = ((my_int*2 - 4U) + 2) / 2;
  if (result != 923U)
    abort();

  result = (((my_int + 2) * 2) - 8U - 4) / 2;
  if (result != 920U)
    abort();
  result = (((my_int + 2) * 2) - (8U + 4)) / 2;
  if (result != 920U)
    abort();

  result = ((my_int*4 + 2U) - 4U) / 2;
  if (result != 1847U)
    abort();

  exit(0);
}
// source: 20020503-1.c
/* PR 6534 */
/* GCSE unified the two i<0 tests, but if-conversion to ui=abs(i)
   insertted the code at the wrong place corrupting the i<0 test.  */

void abort (void);
static char *
inttostr (long i, char buf[128])
{
  unsigned long ui = i;
  char *p = buf + 127;
  *p = '\0';
  if (i < 0)
    ui = -ui;
  do
    *--p = '0' + ui % 10;
  while ((ui /= 10) != 0);
  if (i < 0)
    *--p = '-';
  return p;
}

int
main ()
{
  char buf[128], *p;

  p = inttostr (-1, buf);
  if (*p != '-')
    abort ();
  return 0;
}
// source: 20020506-1.c
/* Copyright (C) 2002  Free Software Foundation.

   Test that (A & C1) op C2 optimizations behave correctly where C1 is
   a constant power of 2, op is == or !=, and C2 is C1 or zero.

   Written by Roger Sayle, 5th May 2002.  */

#include <limits.h>

extern void abort (void);

void test1 (signed char c, int set);
void test2 (unsigned char c, int set);
void test3 (short s, int set);
void test4 (unsigned short s, int set);
void test5 (int i, int set);
void test6 (unsigned int i, int set);
void test7 (long long l, int set);
void test8 (unsigned long long l, int set);

#ifndef LONG_LONG_MAX
#define LONG_LONG_MAX __LONG_LONG_MAX__
#endif
#ifndef LONG_LONG_MIN
#define LONG_LONG_MIN (-LONG_LONG_MAX-1)
#endif
#ifndef ULONG_LONG_MAX
#define ULONG_LONG_MAX (LONG_LONG_MAX * 2ULL + 1)
#endif


void
test1 (signed char c, int set)
{
  if ((c & (SCHAR_MAX+1)) == 0)
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();

  if ((c & (SCHAR_MAX+1)) != 0)
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((c & (SCHAR_MAX+1)) == (SCHAR_MAX+1))
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((c & (SCHAR_MAX+1)) != (SCHAR_MAX+1))
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();
}

void
test2 (unsigned char c, int set)
{
  if ((c & (SCHAR_MAX+1)) == 0)
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();

  if ((c & (SCHAR_MAX+1)) != 0)
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((c & (SCHAR_MAX+1)) == (SCHAR_MAX+1))
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((c & (SCHAR_MAX+1)) != (SCHAR_MAX+1))
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();
}

void
test3 (short s, int set)
{
  if ((s & (SHRT_MAX+1)) == 0)
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();

  if ((s & (SHRT_MAX+1)) != 0)
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((s & (SHRT_MAX+1)) == (SHRT_MAX+1))
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((s & (SHRT_MAX+1)) != (SHRT_MAX+1))
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();
}

void
test4 (unsigned short s, int set)
{
  if ((s & (SHRT_MAX+1)) == 0)
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();

  if ((s & (SHRT_MAX+1)) != 0)
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((s & (SHRT_MAX+1)) == (SHRT_MAX+1))
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((s & (SHRT_MAX+1)) != (SHRT_MAX+1))
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();
}

void
test5 (int i, int set)
{
  if ((i & (INT_MAX+1U)) == 0)
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();

  if ((i & (INT_MAX+1U)) != 0)
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((i & (INT_MAX+1U)) == (INT_MAX+1U))
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((i & (INT_MAX+1U)) != (INT_MAX+1U))
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();
}

void
test6 (unsigned int i, int set)
{
  if ((i & (INT_MAX+1U)) == 0)
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();

  if ((i & (INT_MAX+1U)) != 0)
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((i & (INT_MAX+1U)) == (INT_MAX+1U))
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((i & (INT_MAX+1U)) != (INT_MAX+1U))
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();
}

void
test7 (long long l, int set)
{
  if ((l & (LONG_LONG_MAX+1ULL)) == 0)
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();

  if ((l & (LONG_LONG_MAX+1ULL)) != 0)
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((l & (LONG_LONG_MAX+1ULL)) == (LONG_LONG_MAX+1ULL))
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((l & (LONG_LONG_MAX+1ULL)) != (LONG_LONG_MAX+1ULL))
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();
}

void
test8 (unsigned long long l, int set)
{
  if ((l & (LONG_LONG_MAX+1ULL)) == 0)
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();

  if ((l & (LONG_LONG_MAX+1ULL)) != 0)
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((l & (LONG_LONG_MAX+1ULL)) == (LONG_LONG_MAX+1ULL))
    {
      if (!set) abort ();
    }
  else
    if (set) abort ();

  if ((l & (LONG_LONG_MAX+1ULL)) != (LONG_LONG_MAX+1ULL))
    {
      if (set) abort ();
    }
  else
    if (!set) abort ();
}

int
main ()
{
  test1 (0, 0);
  test1 (SCHAR_MAX, 0);
  test1 (SCHAR_MIN, 1);
  test1 (UCHAR_MAX, 1);

  test2 (0, 0);
  test2 (SCHAR_MAX, 0);
  test2 (SCHAR_MIN, 1);
  test2 (UCHAR_MAX, 1);

  test3 (0, 0);
  test3 (SHRT_MAX, 0);
  test3 (SHRT_MIN, 1);
  test3 (USHRT_MAX, 1);

  test4 (0, 0);
  test4 (SHRT_MAX, 0);
  test4 (SHRT_MIN, 1);
  test4 (USHRT_MAX, 1);

  test5 (0, 0);
  test5 (INT_MAX, 0);
  test5 (INT_MIN, 1);
  test5 (UINT_MAX, 1);

  test6 (0, 0);
  test6 (INT_MAX, 0);
  test6 (INT_MIN, 1);
  test6 (UINT_MAX, 1);

  test7 (0, 0);
  test7 (LONG_LONG_MAX, 0);
  test7 (LONG_LONG_MIN, 1);
  test7 (ULONG_LONG_MAX, 1);

  test8 (0, 0);
  test8 (LONG_LONG_MAX, 0);
  test8 (LONG_LONG_MIN, 1);
  test8 (ULONG_LONG_MAX, 1);

  return 0;
}
// source: 20020508-1.c
/* This tests the rotate patterns that some machines support.  */

#include <limits.h>

#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

#define ROR(a,b) (((a) >> (b)) | ((a) << ((sizeof (a) * CHAR_BIT) - (b))))
#define ROL(a,b) (((a) << (b)) | ((a) >> ((sizeof (a) * CHAR_BIT) - (b))))

#define CHAR_VALUE ((unsigned char)0xf234U)
#define SHORT_VALUE ((unsigned short)0xf234U)
#define INT_VALUE 0xf234U
#define LONG_VALUE 0xf2345678LU
#define LL_VALUE 0xf2345678abcdef0LLU

#define SHIFT1 4
#define SHIFT2 ((sizeof (long long) * CHAR_BIT) - SHIFT1)

unsigned char uc = CHAR_VALUE;
unsigned short us = SHORT_VALUE;
unsigned int ui = INT_VALUE;
unsigned long ul = LONG_VALUE;
unsigned long long ull = LL_VALUE;
int shift1 = SHIFT1;
int shift2 = SHIFT2;

main ()
{
  if (ROR (uc, shift1) != ROR (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROR (uc, SHIFT1) != ROR (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROR (us, shift1) != ROR (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROR (us, SHIFT1) != ROR (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROR (ui, shift1) != ROR (INT_VALUE, SHIFT1))
    abort ();

  if (ROR (ui, SHIFT1) != ROR (INT_VALUE, SHIFT1))
    abort ();

  if (ROR (ul, shift1) != ROR (LONG_VALUE, SHIFT1))
    abort ();

  if (ROR (ul, SHIFT1) != ROR (LONG_VALUE, SHIFT1))
    abort ();

  if (ROR (ull, shift1) != ROR (LL_VALUE, SHIFT1))
    abort ();

  if (ROR (ull, SHIFT1) != ROR (LL_VALUE, SHIFT1))
    abort ();

  if (ROR (ull, shift2) != ROR (LL_VALUE, SHIFT2))
    abort ();

  if (ROR (ull, SHIFT2) != ROR (LL_VALUE, SHIFT2))
    abort ();

  if (ROL (uc, shift1) != ROL (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROL (uc, SHIFT1) != ROL (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROL (us, shift1) != ROL (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROL (us, SHIFT1) != ROL (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROL (ui, shift1) != ROL (INT_VALUE, SHIFT1))
    abort ();

  if (ROL (ui, SHIFT1) != ROL (INT_VALUE, SHIFT1))
    abort ();

  if (ROL (ul, shift1) != ROL (LONG_VALUE, SHIFT1))
    abort ();

  if (ROL (ul, SHIFT1) != ROL (LONG_VALUE, SHIFT1))
    abort ();

  if (ROL (ull, shift1) != ROL (LL_VALUE, SHIFT1))
    abort ();

  if (ROL (ull, SHIFT1) != ROL (LL_VALUE, SHIFT1))
    abort ();

  if (ROL (ull, shift2) != ROL (LL_VALUE, SHIFT2))
    abort ();

  if (ROL (ull, SHIFT2) != ROL (LL_VALUE, SHIFT2))
    abort ();

  exit (0);
}
// source: 20020508-2.c
#include <limits.h>

#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

#define ROR(a,b) (((a) >> (b)) | ((a) << ((sizeof (a) * CHAR_BIT) - (b))))
#define ROL(a,b) (((a) << (b)) | ((a) >> ((sizeof (a) * CHAR_BIT) - (b))))

#define CHAR_VALUE ((char)0x1234)
#define SHORT_VALUE ((short)0x1234)
#define INT_VALUE ((int)0x1234)
#define LONG_VALUE ((long)0x12345678L)
#define LL_VALUE ((long long)0x12345678abcdef0LL)

#define SHIFT1 4
#define SHIFT2 ((sizeof (long long) * CHAR_BIT) - SHIFT1)

char c = CHAR_VALUE;
short s = SHORT_VALUE;
int i = INT_VALUE;
long l = LONG_VALUE;
long long ll = LL_VALUE;
int shift1 = SHIFT1;
int shift2 = SHIFT2;

main ()
{
  if (ROR (c, shift1) != ROR (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROR (c, SHIFT1) != ROR (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROR (s, shift1) != ROR (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROR (s, SHIFT1) != ROR (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROR (i, shift1) != ROR (INT_VALUE, SHIFT1))
    abort ();

  if (ROR (i, SHIFT1) != ROR (INT_VALUE, SHIFT1))
    abort ();

  if (ROR (l, shift1) != ROR (LONG_VALUE, SHIFT1))
    abort ();

  if (ROR (l, SHIFT1) != ROR (LONG_VALUE, SHIFT1))
    abort ();

  if (ROR (ll, shift1) != ROR (LL_VALUE, SHIFT1))
    abort ();

  if (ROR (ll, SHIFT1) != ROR (LL_VALUE, SHIFT1))
    abort ();

  if (ROR (ll, shift2) != ROR (LL_VALUE, SHIFT2))
    abort ();

  if (ROR (ll, SHIFT2) != ROR (LL_VALUE, SHIFT2))
    abort ();

  if (ROL (c, shift1) != ROL (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROL (c, SHIFT1) != ROL (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROL (s, shift1) != ROL (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROL (s, SHIFT1) != ROL (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROL (i, shift1) != ROL (INT_VALUE, SHIFT1))
    abort ();

  if (ROL (i, SHIFT1) != ROL (INT_VALUE, SHIFT1))
    abort ();

  if (ROL (l, shift1) != ROL (LONG_VALUE, SHIFT1))
    abort ();

  if (ROL (l, SHIFT1) != ROL (LONG_VALUE, SHIFT1))
    abort ();

  if (ROL (ll, shift1) != ROL (LL_VALUE, SHIFT1))
    abort ();

  if (ROL (ll, SHIFT1) != ROL (LL_VALUE, SHIFT1))
    abort ();

  if (ROL (ll, shift2) != ROL (LL_VALUE, SHIFT2))
    abort ();

  if (ROL (ll, SHIFT2) != ROL (LL_VALUE, SHIFT2))
    abort ();

  exit (0);
}
// source: 20020508-3.c
#include <limits.h>

#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

#define ROR(a,b) (((a) >> (b)) | ((a) << ((sizeof (a) * CHAR_BIT) - (b))))
#define ROL(a,b) (((a) << (b)) | ((a) >> ((sizeof (a) * CHAR_BIT) - (b))))

#define CHAR_VALUE ((char)0xf234)
#define SHORT_VALUE ((short)0xf234)
#define INT_VALUE ((int)0xf234)
#define LONG_VALUE ((long)0xf2345678L)
#define LL_VALUE ((long long)0xf2345678abcdef0LL)

#define SHIFT1 4
#define SHIFT2 ((sizeof (long long) * CHAR_BIT) - SHIFT1)

char c = CHAR_VALUE;
short s = SHORT_VALUE;
int i = INT_VALUE;
long l = LONG_VALUE;
long long ll = LL_VALUE;
int shift1 = SHIFT1;
int shift2 = SHIFT2;

main ()
{
  if (ROR (c, shift1) != ROR (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROR (c, SHIFT1) != ROR (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROR (s, shift1) != ROR (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROR (s, SHIFT1) != ROR (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROR (i, shift1) != ROR (INT_VALUE, SHIFT1))
    abort ();

  if (ROR (i, SHIFT1) != ROR (INT_VALUE, SHIFT1))
    abort ();

  if (ROR (l, shift1) != ROR (LONG_VALUE, SHIFT1))
    abort ();

  if (ROR (l, SHIFT1) != ROR (LONG_VALUE, SHIFT1))
    abort ();

  if (ROR (ll, shift1) != ROR (LL_VALUE, SHIFT1))
    abort ();

  if (ROR (ll, SHIFT1) != ROR (LL_VALUE, SHIFT1))
    abort ();

  if (ROR (ll, shift2) != ROR (LL_VALUE, SHIFT2))
    abort ();

  if (ROR (ll, SHIFT2) != ROR (LL_VALUE, SHIFT2))
    abort ();

  if (ROL (c, shift1) != ROL (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROL (c, SHIFT1) != ROL (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROL (s, shift1) != ROL (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROL (s, SHIFT1) != ROL (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROL (i, shift1) != ROL (INT_VALUE, SHIFT1))
    abort ();

  if (ROL (i, SHIFT1) != ROL (INT_VALUE, SHIFT1))
    abort ();

  if (ROL (l, shift1) != ROL (LONG_VALUE, SHIFT1))
    abort ();

  if (ROL (l, SHIFT1) != ROL (LONG_VALUE, SHIFT1))
    abort ();

  if (ROL (ll, shift1) != ROL (LL_VALUE, SHIFT1))
    abort ();

  if (ROL (ll, SHIFT1) != ROL (LL_VALUE, SHIFT1))
    abort ();

  if (ROL (ll, shift2) != ROL (LL_VALUE, SHIFT2))
    abort ();

  if (ROL (ll, SHIFT2) != ROL (LL_VALUE, SHIFT2))
    abort ();

  exit (0);
}
// source: 20020510-1.c
/* Copyright (C) 2002  Free Software Foundation.

   Test that optimizing ((c>=1) && (c<=127)) into (signed char)c < 0
   doesn't cause any problems for the compiler and behaves correctly.

   Written by Roger Sayle, 8th May 2002.  */

#include <limits.h>

extern void abort (void);

void
testc (unsigned char c, int ok)
{
  if ((c>=1) && (c<=SCHAR_MAX))
    {
      if (!ok) abort ();
    }
  else
    if (ok) abort ();
}

void
tests (unsigned short s, int ok)
{
  if ((s>=1) && (s<=SHRT_MAX))
    {
      if (!ok) abort ();
    }
  else
    if (ok) abort ();
}

void
testi (unsigned int i, int ok)
{
  if ((i>=1) && (i<=INT_MAX))
    {
      if (!ok) abort ();
    }
  else
    if (ok) abort ();
}

void
testl (unsigned long l, int ok)
{
  if ((l>=1) && (l<=LONG_MAX))
    {
      if (!ok) abort ();
    }
  else
    if (ok) abort ();
}

int
main ()
{
  testc (0, 0);
  testc (1, 1);
  testc (SCHAR_MAX, 1);
  testc (SCHAR_MAX+1, 0);
  testc (UCHAR_MAX, 0);

  tests (0, 0);
  tests (1, 1);
  tests (SHRT_MAX, 1);
  tests (SHRT_MAX+1, 0);
  tests (USHRT_MAX, 0);

  testi (0, 0);
  testi (1, 1);
  testi (INT_MAX, 1);
  testi (INT_MAX+1U, 0);
  testi (UINT_MAX, 0);

  testl (0, 0);
  testl (1, 1);
  testl (LONG_MAX, 1);
  testl (LONG_MAX+1UL, 0);
  testl (ULONG_MAX, 0);

  return 0;
}
// source: 20020529-1.c
/* PR target/6838 from cato@df.lth.se.
   cris-elf got an ICE with -O2: the insn matching
      (insn 49 48 52 (parallel[
		  (set (mem/s:HI (plus:SI (reg/v/f:SI 0 r0 [24])
			      (const_int 8 [0x8])) [5 <variable>.c+0 S2 A8])
		      (reg:HI 2 r2 [27]))
		  (set (reg/f:SI 2 r2 [31])
		      (plus:SI (reg/v/f:SI 0 r0 [24])
			  (const_int 8 [0x8])))
	      ] ) 24 {*mov_sidehi_mem} (nil)
	  (nil))
   forced a splitter through the output pattern "#", but there was no
   matching splitter.  */

/* The ptx assembler appears to clobber 'b' inside foo during the f1 call.
   Reported to nvidia 2016-05-18.  */
/* { dg-skip-if "PTX assembler bug" { nvptx-*-* } { "-O0" } { "" } } */

struct xx
 {
   int a;
   struct xx *b;
   short c;
 };

int f1 (struct xx *);
void f2 (void);

int
foo (struct xx *p, int b, int c, int d)
{
  int a;

  for (;;)
    {
      a = f1(p);
      if (a)
	return (0);
      if (b)
	continue;
      p->c = d;
      if (p->a)
	f2 ();
      if (c)
	f2 ();
      d = p->c;
      switch (a)
	{
	case 1:
	  if (p->b)
	    f2 ();
	  if (c)
	    f2 ();
	default:
	  break;
	}
    }
  return d;
}

int main (void)
{
  struct xx s = {0, &s, 23};
  if (foo (&s, 0, 0, 0) != 0 || s.a != 0 || s.b != &s || s.c != 0)
    abort ();
  exit (0);
}

int
f1 (struct xx *p)
{
  static int beenhere = 0;
  if (beenhere++ > 1)
    abort ();
  return beenhere > 1;
}

void
f2 (void)
{
  abort ();
}
// source: 20020611-1.c
/* PR target/6997.  Missing (set_attr "cc" "none") in sleu pattern in
   cris.md.  Testcase from hp@axis.com.  */

int p;
int k;
unsigned int n;

void x ()
{
  unsigned int h;

  h = n <= 30;
  if (h)
    p = 1;
  else
    p = 0;

  if (h)
    k = 1;
  else
    k = 0;
}

unsigned int n = 30;

main ()
{
  x ();
  if (p != 1 || k != 1)
    abort ();
  exit (0);
}
// source: 20020614-1.c
/* PR c/6677 */
/* Verify that GCC doesn't perform illegal simplifications
   when folding constants.  */

#include <limits.h>

extern void abort (void);
extern void exit (int);

int main (void)
{
  int i;
  signed char j;
  unsigned char k;

  i = SCHAR_MAX;

  j = ((signed char) (i << 1)) / 2;

  if (j != -1)
    abort();

  j = ((signed char) (i * 2)) / 2;

  if (j != -1)
    abort();

  i = UCHAR_MAX;

  k = ((unsigned char) (i << 1)) / 2;

  if (k != UCHAR_MAX/2)
    abort();

  k = ((unsigned char) (i * 2)) / 2;

  if (k != UCHAR_MAX/2)
    abort();

  exit(0);
}
// source: 20020615-1.c
/* PR target/7042.  When reorg.c changed branches into return insns, it
   completely forgot about any current_function_epilogue_delay_list and
   dropped those insns.  Uncovered on cris-axis-elf, where an insn in an
   epilogue delay-slot set the return-value register with the testcase
   below.  Derived from ghostscript-6.52 (GPL) by hp@axis.com.  */

typedef struct font_hints_s {
  int axes_swapped;
  int x_inverted, y_inverted;
} font_hints;
typedef struct gs_fixed_point_s {
  long x, y;
} gs_fixed_point;

int
line_hints(const font_hints *fh, const gs_fixed_point *p0,
	   const gs_fixed_point *p1)
{
  long dx = p1->x - p0->x;
  long dy = p1->y - p0->y;
  long adx, ady;
  int xi = fh->x_inverted, yi = fh->y_inverted;
  int hints;
  if (xi)
    dx = -dx;
  if (yi)
    dy = -dy;
  if (fh->axes_swapped) {
    long t = dx;
    int ti = xi;
    dx = dy, xi = yi;
    dy = t, yi = ti;
  }
  adx = dx < 0 ? -dx : dx;
  ady = dy < 0 ? -dy : dy;
  if (dy != 0 && (adx <= ady >> 4)) {
    hints = dy > 0 ? 2 : 1;
    if (xi)
      hints ^= 3;
  } else if (dx != 0 && (ady <= adx >> 4)) {
    hints = dx < 0 ? 8 : 4;
    if (yi)
      hints ^= 12;
  } else
    hints = 0;
  return hints;
}
int main ()
{
  static font_hints fh[] = {{0, 1, 0}, {0, 0, 1}, {0, 0, 0}};
  static gs_fixed_point gsf[]
    = {{0x30000, 0x13958}, {0x30000, 0x18189},
       {0x13958, 0x30000}, {0x18189, 0x30000}};
  if (line_hints (fh, gsf, gsf + 1) != 1
      || line_hints (fh + 1, gsf + 2, gsf + 3) != 8
      || line_hints (fh + 2, gsf + 2, gsf + 3) != 4)
    abort ();
  exit (0);
}
// source: 20020619-1.c
#if (__SIZEOF_INT__ == 4)
typedef int int32;
#elif (__SIZEOF_LONG__ == 4)
typedef long int32;
#else
#error Add target support for int32
#endif
static int32 ref(void)
{
  union {
    char c[5];
    int32 i;
  } u;

  __builtin_memset (&u, 0, sizeof(u));
  u.c[0] = 1;
  u.c[1] = 2;
  u.c[2] = 3;
  u.c[3] = 4;

  return u.i;
}

int main()
{
  int32 b = ref();
  if (b != 0x01020304
      && b != 0x04030201)
    abort ();
  return 0;
}
// source: 20020716-1.c
extern void abort (void);
extern void exit (int);

int sub1 (int val)
{
  return val;
}

int testcond (int val)
{
  int flag1;

    {
      int t1 = val;
        {
          int t2 = t1;
            {
              flag1 = sub1 (t2) ==0;
              goto lab1;
            };
        }
      lab1: ;
    }

  if (flag1 != 0)
    return 0x4d0000;
  else
    return 0;
}

int main (void)
{
  if (testcond (1))
    abort ();
  exit (0);
}
// source: 20020720-1.c
/* Copyright (C) 2002  Free Software Foundation.

   Ensure that fabs(x) < 0.0 optimization is working.

   Written by Roger Sayle, 20th July 2002.  */

extern void abort (void);
extern double fabs (double);
extern void link_error (void);

void
foo (double x)
{
  double p, q;

  p = fabs (x);
  q = 0.0;
  if (p < q)
    link_error ();
}

int
main()
{
  foo (1.0);
  return 0;
}

#ifndef __OPTIMIZE__
void
link_error ()
{
  abort ();
}
#endif
// source: 20020805-1.c
/* This testcase was miscompiled on IA-32, because fold-const
   assumed associate_trees is always done on PLUS_EXPR.  */

extern void abort (void);
extern void exit (int);

void check (unsigned int m)
{
  if (m != (unsigned int) -1)
    abort ();
}

unsigned int n = 1;

int main (void)
{
  unsigned int m;
  m = (1 | (2 - n)) | (-n);
  check (m);
  exit (0);
}
// source: 20020810-1.c
/* PR target/7559
   This testcase was miscompiled on x86-64, because classify_argument
   wrongly computed the offset of nested structure fields.  */

extern void abort (void);

struct A
{
  long x;
};

struct R
{
  struct A a, b;
};

struct R R = { 100, 200 };

void f (struct R r)
{
  if (r.a.x != R.a.x || r.b.x != R.b.x)
    abort ();
}

struct R g (void)
{
  return R;
}

int main (void)
{
  struct R r;
  f(R);
  r = g();
  if (r.a.x != R.a.x || r.b.x != R.b.x)
    abort ();
  return 0;
}
// source: 20020819-1.c
foo ()
{
  return 0;
}

main()
{
  int i, j, k, ccp_bad = 0;

  for (i = 0; i < 10; i++)
    {
      for (j = 0; j < 10; j++)
	if (foo ())
	  ccp_bad = 1;

      k = ccp_bad != 0;
      if (k)
	abort ();
    }

  exit (0);
}
// source: 20020904-1.c
/* PR c/7102 */

/* Verify that GCC zero-extends integer constants
   in unsigned binary operations. */

typedef unsigned char u8;

u8 fun(u8 y)
{
  u8 x=((u8)255)/y;
  return x;
}

int main(void)
{
  if (fun((u8)2) != 127)
    abort ();
  return 0;
}
// source: 20020911-1.c
extern void abort (void);
unsigned short c = 0x8000;
int main()
{
  if ((c-0x8000) < 0 || (c-0x8000) > 0x7fff)
    abort();
  return 0;
}
// source: 20020916-1.c
/* Distilled from try_pre_increment in flow.c.  If-conversion inserted
   new instructions at the wrong place on ppc.  */

int foo(int a)
{
  int x;
  x = 0;
  if (a > 0) x = 1;
  if (a < 0) x = 1;
  return x;
}

int main()
{
  if (foo(1) != 1)
    abort();
  return 0;
}
// source: 20020920-1.c
extern void abort (void);
extern void exit (int);

struct B
{
  int x;
  int y;
};

struct A
{
  int z;
  struct B b;
};

struct A
f ()
{
  struct B b = { 0, 1 };
  struct A a = { 2, b };
  return a;
}

int
main (void)
{
  struct A a = f ();
  if (a.z != 2 || a.b.x != 0 || a.b.y != 1)
    abort ();
  exit (0);
}
// source: 20021010-1.c
#include <limits.h>

int
sub ()
{
  int dummy = 0, a = 16;

  if (a / INT_MAX / 16 == 0)
    return 0;
  else
    return a / INT_MAX / 16;
}

int
main ()
{
  if (sub () != 0)
    abort ();

  exit (0);
}
// source: 20021010-2.c
/* cse.c failure on x86 target.
   Contributed by Stuart Hastings 10 Oct 2002 <stuart@apple.com> */
#include <stdlib.h>

typedef signed short SInt16;

typedef struct {
    SInt16 minx;
    SInt16 maxx;
    SInt16 miny;
    SInt16 maxy;
} IOGBounds;

int expectedwidth = 50;

unsigned int *global_vramPtr = (unsigned int *)0xa000;

IOGBounds global_bounds = { 100, 150, 100, 150 };
IOGBounds global_saveRect = { 75, 175, 75, 175 };

main()
{
  unsigned int *vramPtr;
  int width;
  IOGBounds saveRect = global_saveRect;
  IOGBounds bounds = global_bounds;

  if (saveRect.minx < bounds.minx) saveRect.minx = bounds.minx;
  if (saveRect.maxx > bounds.maxx) saveRect.maxx = bounds.maxx;

  vramPtr = global_vramPtr + (saveRect.miny - bounds.miny) ;
  width = saveRect.maxx - saveRect.minx;

  if (width != expectedwidth)
    abort ();
  exit (0);
}
// source: 20021011-1.c
/* PR opt/8165.  */

extern void abort (void);

char buf[64];

int
main (void)
{
  int i;

  __builtin_strcpy (buf, "mystring");
  if (__builtin_strcmp (buf, "mystring") != 0)
    abort ();

  for (i = 0; i < 16; ++i)
    {
      __builtin_strcpy (buf + i, "mystring");
      if (__builtin_strcmp (buf + i, "mystring") != 0)
	abort ();
    }

  return 0;
}
// source: 20021015-1.c
/* PR opt/7409.  */

extern void abort (void);

char g_list[] = { '1' };

void g (void *p, char *list, int length, char **elementPtr, char **nextPtr)
{
  if (*nextPtr != g_list)
    abort ();

  **nextPtr = 0;
}

int main (void)
{
  char *list = g_list;
  char *element;
  int i, length = 100;

  for (i = 0; *list != 0; i++)
    {
      char *prevList = list;
      g (0, list, length, &element, &list);
      length -= (list - prevList);
    }

  return 0;
}
// source: 20021024-1.c
/* Origin: PR target/6981 from Mattias Engdegaard <mattias@virtutech.se>.  */
/* { dg-require-effective-target int32plus } */

void exit (int);
void abort (void);

unsigned long long *cp, m;

void foo (void)
{
}

void bar (unsigned rop, unsigned long long *r)
{
  unsigned rs1, rs2, rd;

top:
  rs2 = (rop >> 23) & 0x1ff;
  rs1 = (rop >> 9) & 0x1ff;
  rd = rop & 0x1ff;

  *cp = 1;
  m = r[rs1] + r[rs2];
  *cp = 2;
  foo();
  if (!rd)
    goto top;
  r[rd] = 1;
}

int main(void)
{
  static unsigned long long r[64];
  unsigned long long cr;
  cp = &cr;

  r[4] = 47;
  r[8] = 11;
  bar((8 << 23) | (4 << 9) | 15, r);

  if (m != 47 + 11)
    abort ();
  exit (0);
}
// source: 20021111-1.c
/* Origin: PR c/8467 */

extern void abort (void);
extern void exit (int);

int aim_callhandler(int sess, int conn, unsigned short family, unsigned short type);

int aim_callhandler(int sess, int conn, unsigned short family, unsigned short type)
{
  static int i = 0;

  if (!conn)
    return 0;

  if (type == 0xffff)
    {
      return 0;
    }

  if (i >= 1)
    abort ();

  i++;
  return aim_callhandler(sess, conn, family, (unsigned short) 0xffff);
}

int main (void)
{
  aim_callhandler (0, 1, 0, 0);
  exit (0);
}
// source: 20021113-1.c
/* { dg-require-effective-target alloca } */

/* This program tests a data flow bug that would cause constant propagation
   to propagate constants through function calls.  */

foo (int *p)
{
  *p = 10;
}

main()
{
  int *ptr = alloca (sizeof (int));
  *ptr = 5;
  foo (ptr);
  if (*ptr == 5)
    abort ();
  exit (0);
}
// source: 20021118-1.c
struct s { int f[4]; };

int foo (struct s s, int x1, int x2, int x3, int x4, int x5, int x6, int x7)
{
  return s.f[3] + x7;
}

int main ()
{
  struct s s = { 1, 2, 3, 4 };

  if (foo (s, 100, 200, 300, 400, 500, 600, 700) != 704)
    abort ();
  exit (0);
}
// source: 20021118-2.c
/* Originally added to test SH constant pool layout.  t1() failed for
   non-PIC and t2() failed for PIC.  */

int t1 (float *f, int i,
	void (*f1) (double),
	void (*f2) (float, float))
{
  f1 (3.0);
  f[i] = f[i + 1];
  f2 (2.5f, 3.5f);
}

int t2 (float *f, int i,
	void (*f1) (double),
	void (*f2) (float, float),
	void (*f3) (float))
{
  f3 (6.0f);
  f1 (3.0);
  f[i] = f[i + 1];
  f2 (2.5f, 3.5f);
}

void f1 (double d)
{
  if (d != 3.0)
    abort ();
}

void f2 (float f1, float f2)
{
  if (f1 != 2.5f || f2 != 3.5f)
    abort ();
}

void f3 (float f)
{
  if (f != 6.0f)
    abort ();
}

int main ()
{
  float f[3] = { 2.0f, 3.0f, 4.0f };
  t1 (f, 0, f1, f2);
  t2 (f, 1, f1, f2, f3);
  if (f[0] != 3.0f && f[1] != 4.0f)
    abort ();
  exit (0);
}
// source: 20021118-3.c
extern void abort (void);
extern void exit (int);

int
foo (int x)
{
  if (x == -2 || -x - 100 >= 0)
    abort ();
  return 0;
}

int
main ()
{
  foo (-3);
  foo (-99);
  exit (0);
}
// source: 20021119-1.c
/* PR 8639.  */

extern void abort(void);

int foo (int i)
{
  int r;
  r = (80 - 4 * i) / 20;
  return r;
}

int main ()
{
  if (foo (1) != 3)
    abort ();
  return 0;
}
// source: 20021120-1.c
/* Macros to emit "L Nxx R" for each octal number xx between 000 and 037.  */
#define OP1(L, N, R, I, J) L N##I##J R
#define OP2(L, N, R, I) \
    OP1(L, N, R, 0, I), OP1(L, N, R, 1, I), \
    OP1(L, N, R, 2, I), OP1(L, N, R, 3, I)
#define OP(L, N, R) \
    OP2(L, N, R, 0), OP2(L, N, R, 1), OP2(L, N, R, 2), OP2(L, N, R, 3), \
    OP2(L, N, R, 4), OP2(L, N, R, 5), OP2(L, N, R, 6), OP2(L, N, R, 7)

/* Declare 32 unique variables with prefix N.  */
#define DECLARE(N) OP (, N,)

/* Copy 32 variables with prefix N from the array at ADDR.
   Leave ADDR pointing to the end of the array.  */
#define COPYIN(N, ADDR) OP (, N, = *(ADDR++))

/* Likewise, but copy the other way.  */
#define COPYOUT(N, ADDR) OP (*(ADDR++) =, N,)

/* Add the contents of the array at ADDR to 32 variables with prefix N.
   Leave ADDR pointing to the end of the array.  */
#define ADD(N, ADDR) OP (, N, += *(ADDR++))

volatile double gd[32];
volatile float gf[32];

void foo (int n)
{
  double DECLARE(d);
  float DECLARE(f);
  volatile double *pd;
  volatile float *pf;
  int i;

  pd = gd; COPYIN (d, pd);
  for (i = 0; i < n; i++)
    {
      pf = gf; COPYIN (f, pf);
      pd = gd; ADD (d, pd);
      pd = gd; ADD (d, pd);
      pd = gd; ADD (d, pd);
      pf = gf; COPYOUT (f, pf);
    }
  pd = gd; COPYOUT (d, pd);
}

int main ()
{
  int i;

  for (i = 0; i < 32; i++)
    gd[i] = i, gf[i] = i;
  foo (1);
  for (i = 0; i < 32; i++)
    if (gd[i] != i * 4 || gf[i] != i)
      abort ();
  exit (0);
}
// source: 20021120-2.c
int g1, g2;

void foo (int x)
{
  int y;

  if (x)
    y = 793;
  else
    y = 793;
  g1 = 7930 / y;
  g2 = 7930 / x;
}

int main ()
{
  foo (793);
  if (g1 != 10 || g2 != 10)
    abort ();
  exit (0);
}
// source: 20021120-3.c
/* Test whether a partly call-clobbered register will be moved over a call.
   Although the original test case didn't use any GNUisms, it proved
   difficult to reduce without the named register extension.  */
#if __SH64__ == 32
#define LOC asm ("r10")
#else
#define LOC
#endif

unsigned int foo (char *c, unsigned int x, unsigned int y)
{
  register unsigned int z LOC;

  sprintf (c, "%d", x / y);
  z = x + 1;
  return z / (y + 1);
}

int main ()
{
  char c[16];

  if (foo (c, ~1U, 4) != (~0U / 5))
    abort ();
  exit (0);
}
// source: 20021127-1.c
/* { dg-options "-std=c99" } */

long long a = -1;
long long llabs (long long);
void abort (void);
int
main()
{
  if (llabs (a) != 1)
    abort ();
  return 0;
}
long long llabs (long long b)
{
	abort ();
}
// source: 20021204-1.c
/* This test was miscompiled when using sibling call optimization,
   because X ? Y : Y - 1 optimization changed X into !X in place
   and haven't reverted it if do_store_flag was successful, so
   when expanding the expression the second time it was
   !X ? Y : Y - 1.  */

extern void abort (void);
extern void exit (int);

void foo (int x)
{
  if (x != 1)
    abort ();
}

int z;

int main (int argc, char **argv)
{
  char *a = "test";
  char *b = a + 2;

  foo (z > 0 ? b - a : b - a - 1);
  exit (0);
}
// source: 20021219-1.c
/* PR optimization/8988 */
/* Contributed by Kevin Easton */

void foo(char *p1, char **p2)
{}

int main(void)
{
  char str[] = "foo { xx }";
  char *ptr = str + 5;

  foo(ptr, &ptr);

  while (*ptr && (*ptr == 13 || *ptr == 32))
    ptr++;

  return 0;
}
// source: 20030105-1.c
int __attribute__ ((noinline))
foo ()
{
  const int a[8] = { 0, 1, 2, 3, 4, 5, 6, 7 };
  int i, sum;

  sum = 0;
  for (i = 0; i < sizeof (a) / sizeof (*a); i++)
    sum += a[i];

  return sum;
}

int
main ()
{
  if (foo () != 28)
    abort ();
  exit (0);
}
// source: 20030109-1.c
/* PR c/8032 */
/* Verify that an empty initializer inside a partial
   parent initializer doesn't confuse GCC.  */

struct X
{
  int a;
  int b;
  int z[];
};

struct X x = { .b = 40, .z = {} };

int main ()
{
  if (x.b != 40)
    abort ();

  return 0;
}
// source: 20030117-1.c
int foo (int, int, int);
int bar (int, int, int);

int main (void)
{
  if (foo (5, 10, 21) != 12)
    abort ();

  if (bar (9, 12, 15) != 150)
    abort ();

  exit (0);
}

int foo (int x, int y, int z)
{
  return (x + y + z) / 3;
}

int bar (int x, int y, int z)
{
  return foo (x * x, y * y, z * z);
}
// source: 20030120-1.c
/* On H8/300 port, NOTICE_UPDATE_CC had a bug that causes the final
   pass to remove test insns that should be kept.  */

unsigned short
test1 (unsigned short w)
{
  if ((w & 0xff00) == 0)
    {
      if (w == 0)
	w = 2;
    }
  return w;
}

unsigned long
test2 (unsigned long w)
{
  if ((w & 0xffff0000) == 0)
    {
      if (w == 0)
	w = 2;
    }
  return w;
}

int
test3 (unsigned short a)
{
  if (a & 1)
    return 1;
  else if (a)
    return 1;
  else
    return 0;
}

int
main ()
{
  if (test1 (1) != 1)
    abort ();

  if (test2 (1) != 1)
    abort ();

  if (test3 (2) != 1)
    abort ();

  exit (0);
}
// source: 20030120-2.c
/* PR 8848 */

extern void abort ();

int foo(int status)
{
  int s = 0;
  if (status == 1) s=1;
  if (status == 3) s=3;
  if (status == 4) s=4;
  return s;
}

int main()
{
  if (foo (3) != 3)
    abort ();
  return 0;
}
// source: 20030125-1.c
/* Verify whether math functions are simplified.  */
/* { dg-require-effective-target c99_runtime } */
/* { dg-require-weak "" } */
double sin(double);
double floor(double);
float
t(float a)
{
	return sin(a);
}
float
q(float a)
{
	return floor(a);
}
double
q1(float a)
{
	return floor(a);
}
main()
{
#ifdef __OPTIMIZE__
	if (t(0)!=0)
		abort ();
	if (q(0)!=0)
		abort ();
	if (q1(0)!=0)
		abort ();
#endif
	return 0;
}
__attribute__ ((weak))
double
floor(double a)
{
	abort ();
}
__attribute__ ((weak))
float
floorf(float a)
{
	return a;
}
__attribute__ ((weak))
double
sin(double a)
{
	return a;
}
__attribute__ ((weak))
float
sinf(float a)
{
	abort ();
}
// source: 20030128-1.c
unsigned char x = 50;
volatile short y = -5;

int main ()
{
  x /= y;
  if (x != (unsigned char) -10)
    abort ();
  exit (0);
}
// source: 20030203-1.c
void f(int);
int do_layer3(int single)
{
  int stereo1;

  if(single >= 0) /* stream is stereo, but force to mono */
    stereo1 = 1;
  else
    stereo1 = 2;
  f(single);

  return stereo1;
}

extern void abort ();
int main()
{
  if (do_layer3(-1) != 2)
    abort ();
  return 0;
}

void f(int i) {}
// source: 20030209-1.c
/* { dg-require-stack-size "8*100*100" } */

double x[100][100];
int main ()
{
  int i;

  i = 99;
  x[i][0] = 42;
  if (x[99][0] != 42)
    abort ();
  exit (0);
}
// source: 20030216-1.c
/* This test requires constant propagation of loads and stores to be
   enabled.  This is only guaranteed at -O2 and higher.  Do not run
   at -O1.  */
/* { dg-skip-if "requires higher optimization" { *-*-* } "-O1" "" } */

void link_error (void);
const double one=1.0;
main ()
{
#ifdef __OPTIMIZE__
  if ((int) one != 1)
    link_error ();
#endif
  return 0;
}
// source: 20030218-1.c
/*  On H8, the predicate general_operand_src(op,mode) used to ignore
    mode when op is a (mem (post_inc ...)).  As a result, the pattern
    for extendhisi2 was recognized as extendqisi2.  */

extern void abort ();
extern void exit (int);

short *q;

long
foo (short *p)
{
  long b = *p;
  q = p + 1;
  return b;
}

int
main ()
{
  short a = 0xff00;
  if (foo (&a) != (long) (short) 0xff00)
    abort ();
  exit (0);
}
// source: 20030221-1.c
/* PR optimization/8613 */
/* Contributed by Glen Nakamura */

extern void abort (void);

int main (void)
{
  char buf[16] = "1234567890";
  char *p = buf;

  *p++ = (char) __builtin_strlen (buf);

  if ((buf[0] != 10) || (p - buf != 1))
    abort ();

  return 0;
}
// source: 20030222-1.c
/* Verify that we get the low part of the long long as an int.  We
   used to get it wrong on big-endian machines, if register allocation
   succeeded at all.  We use volatile to make sure the long long is
   actually truncated to int, in case a single register is wide enough
   for a long long.  */
/* { dg-skip-if "asm would require extra shift-left-4-byte" { spu-*-* } } */
/* { dg-skip-if "asm requires register allocation" { nvptx-*-* } } */
#include <limits.h>

void
ll_to_int (long long x, volatile int *p)
{
  int i;
  asm ("" : "=r" (i) : "0" (x));
  *p = i;
}

int val = INT_MIN + 1;

int main() {
  volatile int i;

  ll_to_int ((long long)val, &i);
  if (i != val)
    abort ();

  exit (0);
}
// source: 20030224-2.c
/* Make sure that we don't free any temp stack slots associated with
   initializing marker before we're finished with them.  */

extern void abort();

typedef struct { short v16; } __attribute__((packed)) jint16_t;

struct node {
  jint16_t magic;
  jint16_t nodetype;
  int totlen;
} __attribute__((packed));

struct node node, *node_p = &node;

int main()
{
  struct node marker = {
    .magic = (jint16_t) {0x1985},
    .nodetype = (jint16_t) {0x2003},
    .totlen = node_p->totlen
  };
  if (marker.magic.v16 != 0x1985)
    abort();
  if (marker.nodetype.v16 != 0x2003)
    abort();
  return 0;
}
// source: 20030307-1.c
/* PR optimization/8726 */
/* Originator: Paul Eggert <eggert@twinsun.com> */

/* Verify that GCC doesn't miscompile tail calls on Sparc. */

extern void abort(void);

int fcntl_lock(int fd, int op, long long offset, long long count, int type);

int vfswrap_lock(char *fsp, int fd, int op, long long offset, long long count, int type)
{
  return fcntl_lock(fd, op, offset, count, type);
}

int fcntl_lock(int fd, int op, long long offset, long long count, int type)
{
  return type;
}

int main(void)
{
  if (vfswrap_lock (0, 1, 2, 3, 4, 5) != 5)
    abort();

  return 0;
}
// source: 20030313-1.c
struct A
{
  unsigned long p, q, r, s;
} x = { 13, 14, 15, 16 };

extern void abort (void);
extern void exit (int);

static inline struct A *
bar (void)
{
  struct A *r;

  switch (8)
    {
    case 2:
      abort ();
      break;
    case 8:
      r = &x;
      break;
    default:
      abort ();
      break;
    }
  return r;
}

void
foo (unsigned long *x, int y)
{
  if (y != 12)
    abort ();
  if (x[0] != 1 || x[1] != 11)
    abort ();
  if (x[2] != 2 || x[3] != 12)
    abort ();
  if (x[4] != 3 || x[5] != 13)
    abort ();
  if (x[6] != 4 || x[7] != 14)
    abort ();
  if (x[8] != 5 || x[9] != 15)
    abort ();
  if (x[10] != 6 || x[11] != 16)
    abort ();
}

int
main (void)
{
  unsigned long a[40];
  int b = 0;

  a[b++] = 1;
  a[b++] = 11;
  a[b++] = 2;
  a[b++] = 12;
  a[b++] = 3;
  a[b++] = bar()->p;
  a[b++] = 4;
  a[b++] = bar()->q;
  a[b++] = 5;
  a[b++] = bar()->r;
  a[b++] = 6;
  a[b++] = bar()->s;
  foo (a, b);
  exit (0);
}
// source: 20030316-1.c
/* PR target/9164 */
/* The comparison operand was sign extended erraneously.  */

int
main (void)
{
    long j = 0x40000000;
    if ((unsigned int) (0x40000000 + j) < 0L)
	abort ();

    return 0;
}
// source: 20030323-1.c
/* PR opt/10116 */
/* { dg-require-effective-target return_address } */
/* Removed tablejump while label still in use; this is really a link test.  */

void *NSReturnAddress(int offset)
{
	switch (offset) {
	case 0:  return __builtin_return_address(0 + 1);
	case 1:  return __builtin_return_address(1 + 1);
	case 2:  return __builtin_return_address(2 + 1);
	case 3:  return __builtin_return_address(3 + 1);
	case 4:  return __builtin_return_address(4 + 1);
	case 5:  return __builtin_return_address(5 + 1);
	case 6:  return __builtin_return_address(6 + 1);
	case 7:  return __builtin_return_address(7 + 1);
	case 8:  return __builtin_return_address(8 + 1);
	case 9:  return __builtin_return_address(9 + 1);
	case 10: return __builtin_return_address(10 + 1);
	case 11: return __builtin_return_address(11 + 1);
	case 12: return __builtin_return_address(12 + 1);
	case 13: return __builtin_return_address(13 + 1);
	case 14: return __builtin_return_address(14 + 1);
	case 15: return __builtin_return_address(15 + 1);
	case 16: return __builtin_return_address(16 + 1);
	case 17: return __builtin_return_address(17 + 1);
	case 18: return __builtin_return_address(18 + 1);
	case 19: return __builtin_return_address(19 + 1);
	case 20: return __builtin_return_address(20 + 1);
	case 21: return __builtin_return_address(21 + 1);
	case 22: return __builtin_return_address(22 + 1);
	case 23: return __builtin_return_address(23 + 1);
	case 24: return __builtin_return_address(24 + 1);
	case 25: return __builtin_return_address(25 + 1);
	case 26: return __builtin_return_address(26 + 1);
	case 27: return __builtin_return_address(27 + 1);
	case 28: return __builtin_return_address(28 + 1);
	case 29: return __builtin_return_address(29 + 1);
	case 30: return __builtin_return_address(30 + 1);
	case 31: return __builtin_return_address(31 + 1);
	case 32: return __builtin_return_address(32 + 1);
	case 33: return __builtin_return_address(33 + 1);
	case 34: return __builtin_return_address(34 + 1);
	case 35: return __builtin_return_address(35 + 1);
	case 36: return __builtin_return_address(36 + 1);
	case 37: return __builtin_return_address(37 + 1);
	case 38: return __builtin_return_address(38 + 1);
	case 39: return __builtin_return_address(39 + 1);
	case 40: return __builtin_return_address(40 + 1);
	case 41: return __builtin_return_address(41 + 1);
	case 42: return __builtin_return_address(42 + 1);
	case 43: return __builtin_return_address(43 + 1);
	case 44: return __builtin_return_address(44 + 1);
	case 45: return __builtin_return_address(45 + 1);
	case 46: return __builtin_return_address(46 + 1);
	case 47: return __builtin_return_address(47 + 1);
	case 48: return __builtin_return_address(48 + 1);
	case 49: return __builtin_return_address(49 + 1);
	case 50: return __builtin_return_address(50 + 1);
	case 51: return __builtin_return_address(51 + 1);
	case 52: return __builtin_return_address(52 + 1);
	case 53: return __builtin_return_address(53 + 1);
	case 54: return __builtin_return_address(54 + 1);
	case 55: return __builtin_return_address(55 + 1);
	case 56: return __builtin_return_address(56 + 1);
	case 57: return __builtin_return_address(57 + 1);
	case 58: return __builtin_return_address(58 + 1);
	case 59: return __builtin_return_address(59 + 1);
	case 60: return __builtin_return_address(60 + 1);
	case 61: return __builtin_return_address(61 + 1);
	case 62: return __builtin_return_address(62 + 1);
	case 63: return __builtin_return_address(63 + 1);
	case 64: return __builtin_return_address(64 + 1);
	case 65: return __builtin_return_address(65 + 1);
	case 66: return __builtin_return_address(66 + 1);
	case 67: return __builtin_return_address(67 + 1);
	case 68: return __builtin_return_address(68 + 1);
	case 69: return __builtin_return_address(69 + 1);
	case 70: return __builtin_return_address(70 + 1);
	case 71: return __builtin_return_address(71 + 1);
	case 72: return __builtin_return_address(72 + 1);
	case 73: return __builtin_return_address(73 + 1);
	case 74: return __builtin_return_address(74 + 1);
	case 75: return __builtin_return_address(75 + 1);
	case 76: return __builtin_return_address(76 + 1);
	case 77: return __builtin_return_address(77 + 1);
	case 78: return __builtin_return_address(78 + 1);
	case 79: return __builtin_return_address(79 + 1);
	case 80: return __builtin_return_address(80 + 1);
	case 81: return __builtin_return_address(81 + 1);
	case 82: return __builtin_return_address(82 + 1);
	case 83: return __builtin_return_address(83 + 1);
	case 84: return __builtin_return_address(84 + 1);
	case 85: return __builtin_return_address(85 + 1);
	case 86: return __builtin_return_address(86 + 1);
	case 87: return __builtin_return_address(87 + 1);
	case 88: return __builtin_return_address(88 + 1);
	case 89: return __builtin_return_address(89 + 1);
	case 90: return __builtin_return_address(90 + 1);
	case 91: return __builtin_return_address(91 + 1);
	case 92: return __builtin_return_address(92 + 1);
	case 93: return __builtin_return_address(93 + 1);
	case 94: return __builtin_return_address(94 + 1);
	case 95: return __builtin_return_address(95 + 1);
	case 96: return __builtin_return_address(96 + 1);
	case 97: return __builtin_return_address(97 + 1);
	case 98: return __builtin_return_address(98 + 1);
	case 99: return __builtin_return_address(99 + 1);
	}
	return 0;
}

int main()
{
  return 0;
}
// source: 20030330-1.c
/* PR opt/10011 */
/* This is link test for builtin_constant_p simplification + DCE.  */

extern void link_error(void);
static void usb_hub_port_wait_reset(unsigned int delay)
{
        int delay_time;
        for (delay_time = 0; delay_time < 500; delay_time += delay) {
                if (__builtin_constant_p(delay))
                        link_error();
        }
}

int main() { return 0; }
// source: 20030401-1.c
/* Testcase for PR fortran/9974.  This was a miscompilation of the g77
   front-end caused by the jump bypassing optimizations not handling
   instructions inserted on CFG edges.  */

extern void abort ();

int bar ()
{
  return 1;
}

void foo (int x)
{
  unsigned char error = 0;

  if (! (error = ((x == 0) || bar ())))
    bar ();
  if (! error)
    abort ();
}

int main()
{
  foo (1);
  return 0;
}
// source: 20030403-1.c
/* The non-destructive folder was always emitting >= when folding
   comparisons to signed_max+1.  */

#include <limits.h>

int
main ()
{
  unsigned long count = 8;

  if (count > INT_MAX)
    abort ();

  return (0);
}
// source: 20030404-1.c
/* This exposed a bug in tree-ssa-ccp.c.  Since 'j' and 'i' are never
   defined, CCP was not traversing the edges out of the if(), which caused
   the PHI node for 'k' at the top of the while to only be visited once.
   This ended up causing CCP to think that 'k' was the constant '1'.  */
main()
{
  int i, j, k;

  k = 0;
  while (k < 10)
    {
      k++;
      if (j > i)
	j = 5;
      else
	j =3;
    }

  if (k != 10)
    abort ();

  return 0;
}
// source: 20030408-1.c
/* PR optimization/8634 */
/* Contributed by Glen Nakamura <glen at imodulo dot com> */

extern void abort (void);

struct foo {
  char a, b, c, d, e, f, g, h, i, j;
};

int test1 ()
{
  const char X[8] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H' };
  char buffer[8];
  __builtin_memcpy (buffer, X, 8);
  if (buffer[0] != 'A' || buffer[1] != 'B'
      || buffer[2] != 'C' || buffer[3] != 'D'
      || buffer[4] != 'E' || buffer[5] != 'F'
      || buffer[6] != 'G' || buffer[7] != 'H')
    abort ();
  return 0;
}

int test2 ()
{
  const char X[10] = { 'A', 'B', 'C', 'D', 'E' };
  char buffer[10];
  __builtin_memcpy (buffer, X, 10);
  if (buffer[0] != 'A' || buffer[1] != 'B'
      || buffer[2] != 'C' || buffer[3] != 'D'
      || buffer[4] != 'E' || buffer[5] != '\0'
      || buffer[6] != '\0' || buffer[7] != '\0'
      || buffer[8] != '\0' || buffer[9] != '\0')
    abort ();
  return 0;
}

int test3 ()
{
  const struct foo X = { a : 'A', c : 'C', e : 'E', g : 'G', i : 'I' };
  char buffer[10];
  __builtin_memcpy (buffer, &X, 10);
  if (buffer[0] != 'A' || buffer[1] != '\0'
      || buffer[2] != 'C' || buffer[3] != '\0'
      || buffer[4] != 'E' || buffer[5] != '\0'
      || buffer[6] != 'G' || buffer[7] != '\0'
      || buffer[8] != 'I' || buffer[9] != '\0')
    abort ();
  return 0;
}

int test4 ()
{
  const struct foo X = { .b = 'B', .d = 'D', .f = 'F', .h = 'H' , .j = 'J' };
  char buffer[10];
  __builtin_memcpy (buffer, &X, 10);
  if (buffer[0] != '\0' || buffer[1] != 'B'
      || buffer[2] != '\0' || buffer[3] != 'D'
      || buffer[4] != '\0' || buffer[5] != 'F'
      || buffer[6] != '\0' || buffer[7] != 'H'
      || buffer[8] != '\0' || buffer[9] != 'J')
    abort ();
  return 0;
}

int main ()
{
  test1 (); test2 (); test3 (); test4 ();
  return 0;
}
// source: 20030501-1.c
int
main (int argc, char **argv)
{
  int size = 10;

  {
    int retframe_block()
      {
        return size + 5;
      }

  if (retframe_block() != 15)
      abort ();
  exit (0);

  }
}
// source: 20030606-1.c

int * foo (int *x, int b)
{

  *(x++) = 55;
  if (b)
    *(x++) = b;

  return x;
}

main()
{
  int a[5];

  memset (a, 1, sizeof (a));

  if (foo(a, 0) - a != 1 || a[0] != 55 || a[1] != a[4])
    abort();

  memset (a, 1, sizeof (a));

  if (foo(a, 2) - a != 2 || a[0] != 55 || a[1] != 2)
    abort();

  exit (0);
}
// source: 20030613-1.c
/* PR optimization/10955 */
/* Originator: <heinrich.brand@fujitsu-siemens.com> */

/* This used to fail on SPARC32 at -O3 because the loop unroller
   wrongly thought it could eliminate a pseudo in a loop, while
   the pseudo was used outside the loop.  */

extern void abort(void);

#define COMPLEX struct CS

COMPLEX {
  long x;
  long y;
};


static COMPLEX CCID (COMPLEX x)
{
  COMPLEX a;

  a.x = x.x;
  a.y = x.y;

  return a;
}


static COMPLEX CPOW (COMPLEX x, int y)
{
  COMPLEX a;
  a = x;

  while (--y > 0)
    a=CCID(a);

  return a;
}


static int c5p (COMPLEX x)
{
  COMPLEX a,b;
  a = CPOW (x, 2);
  b = CCID( CPOW(a,2) );

  return (b.x == b.y);
}


int main (void)
{
  COMPLEX  x;

  x.x = -7;
  x.y = -7;

  if (!c5p(x))
    abort();

  return 0;
}
// source: 20030626-1.c
char buf[10];

extern void abort (void);
extern int sprintf (char*, const char*, ...);

int main()
{
  int l = sprintf (buf, "foo\0bar");
  if (l != 3)
    abort ();
  return 0;
}
// source: 20030626-2.c
char buf[40];

extern int sprintf (char*, const char*, ...);
extern void abort (void);

int main()
{
  int i = 0;
  int l = sprintf (buf, "%s", i++ ? "string" : "other string");
  if (l != sizeof ("other string") - 1 || i != 1)
    abort ();
  return 0;
}
// source: 20030714-1.c
/* derived from PR optimization/11440  */

extern void abort (void);
extern void exit (int);

typedef _Bool bool;
const bool false = 0;
const bool true = 1;

enum EPosition
{
  STATIC, RELATIVE, ABSOLUTE, FIXED
};
typedef enum EPosition EPosition;

enum EFloat
{
  FNONE = 0, FLEFT, FRIGHT
};
typedef enum EFloat EFloat;

struct RenderBox
{
  int unused[6];
  short m_verticalPosition;

  bool m_layouted : 1;
  bool m_unused : 1;
  bool m_minMaxKnown : 1;
  bool m_floating : 1;

  bool m_positioned : 1;
  bool m_overhangingContents : 1;
  bool m_relPositioned : 1;
  bool m_paintSpecial : 1;

  bool m_isAnonymous : 1;
  bool m_recalcMinMax : 1;
  bool m_isText : 1;
  bool m_inline : 1;

  bool m_replaced : 1;
  bool m_mouseInside : 1;
  bool m_hasFirstLine : 1;
  bool m_isSelectionBorder : 1;

  bool (*isTableCell) (struct RenderBox *this);
};

typedef struct RenderBox RenderBox;

struct RenderStyle
{
  struct NonInheritedFlags
    {
      union
	{
	  struct
	    {
	      unsigned int _display : 4;
	      unsigned int _bg_repeat : 2;
	      bool _bg_attachment : 1;
	      unsigned int _overflow : 4 ;
	      unsigned int _vertical_align : 4;
	      unsigned int _clear : 2;
	      EPosition _position : 2;
	      EFloat _floating : 2;
	      unsigned int _table_layout : 1;
	      bool _flowAroundFloats :1;

	      unsigned int _styleType : 3;
	      bool _hasHover : 1;
	      bool _hasActive : 1;
	      bool _clipSpecified : 1;
	      unsigned int _unicodeBidi : 2;
	      int _unused : 1;
	    } f;
	  int _niflags;
	};
    } noninherited_flags;
};

typedef struct RenderStyle RenderStyle;

extern void RenderObject_setStyle(RenderBox *this, RenderStyle *_style);
extern void removeFromSpecialObjects(RenderBox *this);



void RenderBox_setStyle(RenderBox *thisin, RenderStyle *_style)
{
  RenderBox *this = thisin;
  bool oldpos, tmp;
  EPosition tmppo;

  tmp = this->m_positioned;

  oldpos = tmp;

  RenderObject_setStyle(this, _style);

  tmppo = _style->noninherited_flags.f._position;

  switch(tmppo)
    {
    case ABSOLUTE:
    case FIXED:
	{
	  bool ltrue = true;
	  this->m_positioned = ltrue;
	  break;
	}

    default:
	{
	  EFloat tmpf;
	  EPosition tmpp;
	  if (oldpos)
	    {
	      bool ltrue = true;
	      this->m_positioned = ltrue;
	      removeFromSpecialObjects(this);
	    }
	    {
	      bool lfalse = false;
	      this->m_positioned = lfalse;
	    }

	  tmpf = _style->noninherited_flags.f._floating;

	  if(!this->isTableCell (this) && !(tmpf == FNONE))
	    {
	      bool ltrue = true;
	      this->m_floating = ltrue;
	    }
	  else
	    {
	      tmpp = _style->noninherited_flags.f._position;
	      if (tmpp == RELATIVE)
		{
		  bool ltrue = true;
		  this->m_relPositioned = ltrue;
		}
	    }
	}
    }
}




RenderBox g_this;
RenderStyle g__style;

void RenderObject_setStyle(RenderBox *this, RenderStyle *_style)
{
  (void) this;
  (void) _style;
}

void removeFromSpecialObjects(RenderBox *this)
{
  (void) this;
}

bool RenderBox_isTableCell (RenderBox *this)
{
  (void) this;
  return false;
}

int main (void)
{

  g_this.m_relPositioned = false;
  g_this.m_positioned = false;
  g_this.m_floating = false;
  g_this.isTableCell = RenderBox_isTableCell;

  g__style.noninherited_flags.f._position = FIXED;
  g__style.noninherited_flags.f._floating = FNONE;

  RenderBox_setStyle (&g_this, &g__style);

  if (g_this.m_positioned != true)
    abort ();
  if (g_this.m_relPositioned != false)
    abort ();
  if (g_this.m_floating != false)
    abort ();

  exit (0);
}
// source: 20030715-1.c
/* PR optimization/11320 */
/* Origin: Andreas Schwab <schwab@suse.de> */

/* Verify that the scheduler correctly computes the dependencies
   in the presence of conditional instructions.  */

int strcmp (const char *, const char *);
int ap_standalone;

const char *ap_check_cmd_context (void *a, int b)
{
  return 0;
}

const char *server_type (void *a, void *b, char *arg)
{
  const char *err = ap_check_cmd_context (a, 0x01|0x02|0x04|0x08|0x10);
  if (err)
    return err;

  if (!strcmp (arg, "inetd"))
    ap_standalone = 0;
  else if (!strcmp (arg, "standalone"))
      ap_standalone = 1;
  else
    return "ServerType must be either 'inetd' or 'standalone'";

  return 0;
}

int main ()
{
  server_type (0, 0, "standalone");
  return 0;
}
// source: 20030717-1.c
/* PR target/11087
   This testcase was miscompiled on ppc64, because basic_induction_var called
   convert_modes, yet did not expect it to emit any new instructions.
   Those were emitted at the end of the function and destroyed during life
   analysis, while the program used uninitialized pseudos created by
   convert_modes.  */

struct A
{
  unsigned short a1;
  unsigned long a2;
};

struct B
{
  int b1, b2, b3, b4, b5;
};

struct C
{
  struct B c1[1];
  int c2, c3;
};

static
int foo (int x)
{
  return  x < 0 ? -x : x;
}

int bar (struct C *x, struct A *y)
{
  int a = x->c3;
  const int b = y->a1 >> 9;
  const unsigned long c = y->a2;
  int d = a;
  unsigned long e, f;

  f = foo (c - x->c1[d].b4);
  do
    {
      if (d <= 0)
	d = x->c2;
      d--;

      e = foo (c-x->c1[d].b4);
      if (e < f)
	a = d;
    }
  while (d != x->c3);
  x->c1[a].b4 = c + b;
  return a;
}

int
main ()
{
  struct A a;
  struct C b;
  int c;

  a.a1 = 512;
  a.a2 = 4242;
  __builtin_memset (&b, 0, sizeof (b));
  b.c1[0].b3 = 424242;
  b.c2 = 1;
  c = bar (&b, &a);
  return 0;
}
// source: 20030718-1.c
/* PR c/10320
   The function temp was not being emitted in a prerelease of 3.4 20030406.
   Contributed by pinskia@physics.uc.edu */

static inline void temp();
int main()
{
        temp();
        return 0;
}
static void temp(){}
// source: 20030811-1.c
/* Origin: PR target/11535 from H. J. Lu <hjl@lucon.org> */
/* { dg-require-effective-target return_address } */

void vararg (int i, ...)
{
  (void) i;
}

int i0[0], i1;

void test1 (void)
{
  int a = (int) (long long) __builtin_return_address (0);
  vararg (0, a);
}

void test2 (void)
{
  i0[0] = (int) (long long) __builtin_return_address (0);
}

void test3 (void)
{
  i1 = (int) (long long) __builtin_return_address (0);
}

void test4 (void)
{
  volatile long long a = (long long) __builtin_return_address (0);
  i0[0] = (int) a;
}

int main (void)
{
  return 0;
}
// source: 20030821-1.c
extern void abort (void);

int
foo (int x)
{
  if ((int) (x & 0x80ffffff) != (int) (0x8000fffe))
    abort ();

  return 0;
}

int
main ()
{
  return foo (0x8000fffe);
}
// source: 20030828-1.c
const int *p;

int bar (void)
{
  return *p + 1;
}

main ()
{
  /* Variable 'i' is never used but it's aliased to a global pointer.  The
     alias analyzer was not considering that 'i' may be used in the call to
     bar().  */
  const int i = 5;
  p = &i;
  if (bar() != 6)
    abort ();
  exit (0);
}
// source: 20030828-2.c
struct rtx_def
{
  int code;
};

main()
{
  int tmp[2];
  struct rtx_def *r, s;
  int *p, *q;

  /* The alias analyzer was creating the same memory tag for r, p and q
     because 'struct rtx_def *' is type-compatible with 'int *'.  However,
     the alias set of 'int[2]' is not the same as 'int *', so variable
     'tmp' was deemed not aliased with anything.  */
  r = &s;
  r->code = 39;

  /* If 'r' wasn't declared, then q and tmp would have had the same memory
     tag.  */
  p = tmp;
  q = p + 1;
  *q = 0;
  tmp[1] = 39;
  if (*q != 39)
    abort ();
  exit (0);
}
// source: 20030903-1.c
/* Test that we don't let stmt.c think that the enumeration's values are
   the entire set of possibilities.  Such an assumption is false for C,
   but true for other languages.  */

enum X { X1 = 1, X2, X3, X4 };
static volatile enum X test = 0;
static void y(int);

int main()
{
  switch (test)
    {
    case X1: y(1); break;
    case X2: y(2); break;
    case X3: y(3); break;
    case X4: y(4); break;
    }
  return 0;
}

static void y(int x) { abort (); }
// source: 20030909-1.c
void abort ();
void exit (int);

void test(int x, int y)
{
  if (x == y)
    abort ();
}

void foo(int x, int y)
{
  if (x == y)
    goto a;
  else
    {
a:;
      if (x == y)
	goto b;
      else
	{
b:;
	  if (x != y)
	    test (x, y);
	}
    }
}

int main(void)
{
  foo (0, 0);

  exit (0);
}
// source: 20030910-1.c
/* The gimplifier was inserting unwanted temporaries for REALPART_EXPR
   nodes.  These need to be treated like a COMPONENT_REF so their address can
   be taken.  */

int main()
{
  __complex double dc;
  double *dp = &(__real dc);
  *dp = 3.14;
  if ((__real dc) != 3.14) abort();
  exit (0);
}
// source: 20030913-1.c
/* Assignments via pointers pointing to global variables were being killed
   by SSA-DCE.  Test contributed by Paul Brook <paul@nowt.org>  */

int glob;

void
fn2(int ** q)
{
  *q = &glob;
}

void test()
{
  int *p;

  fn2(&p);

  *p=42;
}

int main()
{
  test();
  if (glob != 42) abort();
  exit (0);
}
// source: 20030914-1.c
/* On IRIX 6, PB is passed partially in registers and partially on the
   stack, with an odd number of words in the register part.  Check that
   the long double stack argument (PC) is still accessed properly.  */

struct s { int val[16]; };

long double f (int pa, struct s pb, long double pc)
{
  int i;

  for (i = 0; i < 16; i++)
    pc += pb.val[i];
  return pc;
}

int main ()
{
  struct s x;
  int i;

  for (i = 0; i < 16; i++)
    x.val[i] = i + 1;
  if (f (1, x, 10000.0L) != 10136.0L)
    abort ();
  exit (0);
}
// source: 20030914-2.c
/* On IRIX 6, PA is passed partially in registers and partially on the
   stack.  We therefore have two potential uses of pretend_args_size:
   one for the partial argument and one for the varargs save area.
   Make sure that these uses don't conflict.  */

struct s { int i[18]; };

int f (struct s pa, int pb, ...)
{
  return pb;
}

struct s gs;

int main ()
{
  if (f (gs, 0x1234) != 0x1234)
    abort ();

  exit (0);
}
// source: 20030916-1.c
/* "i" overflows in f().  Check that x[i] is not treated as a giv.  */
#include <limits.h>

#if CHAR_BIT == 8

void f (unsigned int *x)
{
  unsigned char i;
  int j;

  i = 0x10;
  for (j = 0; j < 0x10; j++)
    {
      i += 0xe8;
      x[i] = 0;
      i -= 0xe7;
    }
}

int main ()
{
  unsigned int x[256];
  int i;

  for (i = 0; i < 256; i++)
    x[i] = 1;
  f (x);
  for (i = 0; i < 256; i++)
    if (x[i] != (i >= 0x08 && i < 0xf8))
      abort ();
  exit (0);
}
#else
int main () { exit (0); }
#endif
// source: 20030920-1.c
extern void abort (void);

int main()
{
  int hicount = 0;
  unsigned char *c;
  char *str = "\x7f\xff";
  for (c = (unsigned char *)str; *c ; c++) {
    if (!(((unsigned int)(*c)) < 0x80)) hicount++;
  }
  if (hicount != 1)
    abort ();
  return 0;
}
// source: 20030928-1.c
#include <limits.h>

#if INT_MAX <= 32767
int main () { exit (0); }
#else
void get_addrs (const char**x, int *y)
{
  x[0] = "a1111" + (y[0] - 0x10000) * 2;
  x[1] = "a1112" + (y[1] - 0x20000) * 2;
  x[2] = "a1113" + (y[2] - 0x30000) * 2;
  x[3] = "a1114" + (y[3] - 0x40000) * 2;
  x[4] = "a1115" + (y[4] - 0x50000) * 2;
  x[5] = "a1116" + (y[5] - 0x60000) * 2;
  x[6] = "a1117" + (y[6] - 0x70000) * 2;
  x[7] = "a1118" + (y[7] - 0x80000) * 2;
}

int main ()
{
  const char *x[8];
  int y[8];
  int i;

  for (i = 0; i < 8; i++)
    y[i] = 0x10000 * (i + 1);
  get_addrs (x, y);
  for (i = 0; i < 8; i++)
    if (*x[i] != 'a')
      abort ();
  exit (0);
}
#endif
// source: 20031003-1.c
/* PR optimization/9325  */

#include <limits.h>

extern void abort (void);

int f1()
{
  return (int)2147483648.0f;
}

int f2()
{
  return (int)(float)(2147483647);
}

int main()
{
#if INT_MAX == 2147483647
  if (f1() != 2147483647)
    abort ();
#ifdef __SPU__
  /* SPU float rounds towards zero.  */
  if (f2() != 0x7fffff80)
    abort ();
#else
  if (f2() != 2147483647)
    abort ();
#endif
#endif
  return 0;
}
// source: 20031010-1.c
/* A reminder to process ops in generate_expr_as_of_bb exactly once.  */

long __attribute__((noinline))
foo (long ct, long cf, _Bool p1, _Bool p2, _Bool p3)
{
  long diff;

  diff = ct - cf;

  if (p1)
    {
      if (p2)
	{
	  if (p3)
	    {
	      long tmp = ct;
	      ct = cf;
	      cf = tmp;
	    }
	  diff = ct - cf;
	}

      return diff;
    }

  abort ();
}

int main ()
{
  if (foo(2, 3, 1, 1, 1) == 0)
    abort ();
  return 0;
}
// source: 20031011-1.c
/* Check that MAX_EXPR and MIN_EXPR are working properly.  */

#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))
#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))

extern void abort (void);

int main()
{
  int ll_bitsize, ll_bitpos;
  int rl_bitsize, rl_bitpos;
  int end_bit;

  ll_bitpos = 32;  ll_bitsize = 32;
  rl_bitpos = 0;   rl_bitsize = 32;

  end_bit = MAX (ll_bitpos + ll_bitsize, rl_bitpos + rl_bitsize);
  if (end_bit != 64)
    abort ();
  end_bit = MAX (rl_bitpos + rl_bitsize, ll_bitpos + ll_bitsize);
  if (end_bit != 64)
    abort ();
  end_bit = MIN (ll_bitpos + ll_bitsize, rl_bitpos + rl_bitsize);
  if (end_bit != 32)
    abort ();
  end_bit = MIN (rl_bitpos + rl_bitsize, ll_bitpos + ll_bitsize);
  if (end_bit != 32)
    abort ();
  return 0;
}
// source: 20031012-1.c
/* { dg-add-options stack_size } */

/* PR optimization/8750
   Used to fail under Cygwin with
   -O2 -fomit-frame-pointer
   Testcase by David B. Trout     */

#if defined(STACK_SIZE) && STACK_SIZE < 16000
#define ARRAY_SIZE (STACK_SIZE / 2)
#define STRLEN	   (ARRAY_SIZE - 9)
#else
#define ARRAY_SIZE 15000
#define STRLEN     13371
#endif

extern void *memset (void *, int, __SIZE_TYPE__);
extern void abort (void);

static void foo ()
{
    char a[ARRAY_SIZE];

    a[0]=0;
    memset( &a[0], 0xCD, STRLEN );
    a[STRLEN]=0;
    if (strlen(a) != STRLEN)
      abort ();
}

int main ( int argc, char* argv[] )
{
    foo();
    return 0;
}
// source: 20031020-1.c
/* PR target/12654
   The Alpha backend tried to do a >= 1024 as (a - 1024) >= 0, which fails
   for very large negative values.  */
/* Origin: tg@swox.com  */

#include <limits.h>

extern void abort (void);

void __attribute__((noinline))
foo (long x)
{
  if (x >= 1024)
    abort ();
}

int
main ()
{
  foo (LONG_MIN);
  foo (LONG_MIN + 10000);
  return 0;
}
// source: 20031201-1.c
/* Copyright (C) 2003  Free Software Foundation.
   PR target/13256
   STRICT_LOW_PART was handled incorrectly in delay slots.
   Origin: Hans-Peter Nilsson.  */

typedef struct { unsigned int e0 : 16; unsigned int e1 : 16; } s1;
typedef struct { unsigned int e0 : 16; unsigned int e1 : 16; } s2;
typedef struct { s1 i12; s2 i16; } io;
static int test_length = 2;
static io *i;
static int m = 1;
static int d = 1;
static unsigned long test_t0;
static unsigned long test_t1;
void test(void) __attribute__ ((__noinline__));
extern int f1 (void *port) __attribute__ ((__noinline__));
extern void f0 (void) __attribute__ ((__noinline__));
int
f1 (void *port)
{
  int fail_count = 0;
  unsigned long tlen;
  s1 x0 = {0};
  s2 x1 = {0};

  i = port;
  x0.e0 = x1.e0 = 32;
  i->i12 = x0;
  i->i16 = x1;
  do f0(); while (test_t1);
  x0.e0 = x1.e0 = 8;
  i->i12 = x0;
  i->i16 = x1;
  test ();
  if (m)
    {
      unsigned long e = 1000000000 / 460800 * test_length;
      tlen = test_t1 - test_t0;
      if (((tlen-e) & 0x7FFFFFFF) > 1000)
	f0();
    }
  if (d)
    {
      unsigned long e = 1000000000 / 460800 * test_length;
      tlen = test_t1 - test_t0;
      if (((tlen - e) & 0x7FFFFFFF) > 1000)
	f0();
    }
  return fail_count != 0 ? 1 : 0;
}

int
main ()
{
  io io0;
  f1 (&io0);
  abort ();
}

void
test (void)
{
  io *iop = i;
  if (iop->i12.e0 != 8 || iop->i16.e0 != 8)
    abort ();
  exit (0);
}

void
f0 (void)
{
  static int washere = 0;
  io *iop = i;
  if (washere++ || iop->i12.e0 != 32 || iop->i16.e0 != 32)
    abort ();
}
// source: 20031204-1.c
/* PR optimization/13260 */

#include <string.h>

typedef unsigned long u32;

u32 in_aton(const char* x)
{
  return 0x0a0b0c0d;
}

u32 root_nfs_parse_addr(char *name)
{
 u32 addr;
 int octets = 0;
 char *cp, *cq;

 cp = cq = name;
 while (octets < 4) {
  while (*cp >= '0' && *cp <= '9')
   cp++;
  if (cp == cq || cp - cq > 3)
   break;
  if (*cp == '.' || octets == 3)
   octets++;
  if (octets < 4)
   cp++;
  cq = cp;
 }

 if (octets == 4 && (*cp == ':' || *cp == '\0')) {
  if (*cp == ':')
   *cp++ = '\0';
  addr = in_aton(name);
  strcpy(name, cp);
 } else
  addr = (-1);

 return addr;
}

int
main()
{
  static char addr[] = "10.11.12.13:/hello";
  u32 result = root_nfs_parse_addr(addr);
  if (result != 0x0a0b0c0d) { abort(); }
  return 0;
}
// source: 20031211-1.c
struct a { unsigned int bitfield : 1; };

unsigned int x;

main()
{
  struct a a = {0};
  x = 0xbeef;
  a.bitfield |= x;
  if (a.bitfield != 1)
    abort ();
  exit (0);
}
// source: 20031211-2.c
struct a
{
  unsigned int bitfield : 3;
};

int main()
{
  struct a a;

  a.bitfield = 131;
  foo (a.bitfield);
  exit (0);
}

foo(unsigned int z)
{
  if (z != 3)
    abort ();
}
// source: 20031214-1.c
/* PR optimization/10312 */
/* Originator: Peter van Hoof <p dot van-hoof at qub dot ac dot uk> */

/* Verify that the strength reduction pass doesn't find
   illegitimate givs.  */

struct
{
  double a;
  int n[2];
} g = { 0., { 1, 2}};

int k = 0;

void
b (int *j)
{
}

int
main ()
{
  int j;

  for (j = 0; j < 2; j++)
    k = (k > g.n[j]) ? k : g.n[j];

  k++;
  b (&j);

  return 0;
}
// source: 20031215-1.c
/* PR middle-end/13400 */
/* The following test used to fail at run-time with a write to read-only
   memory, caused by if-conversion converting a conditional write into an
   unconditional write.  */

typedef struct {int c, l; char ch[3];} pstr;
const pstr ao = {2, 2, "OK"};
const pstr * const a = &ao;

void test1(void)
{
    if (a->ch[a->l]) {
        ((char *)a->ch)[a->l] = 0;
    }
}

void test2(void)
{
    if (a->ch[a->l]) {
        ((char *)a->ch)[a->l] = -1;
    }
}

void test3(void)
{
    if (a->ch[a->l]) {
        ((char *)a->ch)[a->l] = 1;
    }
}

int main(void)
{
    test1();
    test2();
    test3();
    return 0;
}
// source: 20031216-1.c
/* PR optimization/13313 */
/* Origin: Mike Lerwill <mike@ml-solutions.co.uk> */

extern void abort(void);

void DisplayNumber (unsigned long v)
{
  if (v != 0x9aL)
    abort();
}

unsigned long ReadNumber (void)
{
  return 0x009a0000L;
}

int main (void)
{
  unsigned long tmp;
  tmp = (ReadNumber() & 0x00ff0000L) >> 16;
  DisplayNumber (tmp);
  return 0;
}
// source: 20040208-1.c
int main ()
{
  long double x;

  x = 0x1.0p-500L;
  x *= 0x1.0p-522L;
  if (x != 0x1.0p-1022L)
    abort ();
  exit (0);
}
// source: 20040218-1.c
/* PR target/14209.  Bug in cris.md, shrinking access size of
   postincrement.
   Origin: <hp@axis.com>.  */

long int xb (long int *y) __attribute__ ((__noinline__));
long int xw (long int *y) __attribute__ ((__noinline__));
short int yb (short int *y) __attribute__ ((__noinline__));

long int xb (long int *y)
{
  long int xx = *y & 255;
  return xx + y[1];
}

long int xw (long int *y)
{
  long int xx = *y & 65535;
  return xx + y[1];
}

short int yb (short int *y)
{
  short int xx = *y & 255;
  return xx + y[1];
}

int main (void)
{
  long int y[] = {-1, 16000};
  short int yw[] = {-1, 16000};

  if (xb (y) != 16255
      || xw (y) != 81535
      || yb (yw) != 16255)
    abort ();
  exit (0);
}
// source: 20040223-1.c
/* { dg-require-effective-target alloca } */
#include <string.h>
#include <stdio.h>

void
a(void *x,int y)
{
  if (y != 1234)
    abort ();
}

int
main()
{
  a(strcpy(alloca(100),"abc"),1234);
  return 0;
}
// source: 20040302-1.c
/* { dg-require-effective-target label_values } */
int code[]={0,0,0,0,1};

void foo(int x) {
  volatile int b;
  b = 0xffffffff;
}

void bar(int *pc) {
  static const void *l[] = {&&lab0, &&end};

  foo(0);
  goto *l[*pc];
 lab0:
  foo(0);
  pc++;
  goto *l[*pc];
 end:
  return;
}

int main() {
  bar(code);
  return 0;
}
// source: 20040307-1.c
int main()
{
  int b = 0;

  struct {
    unsigned int bit0:1;
    unsigned int bit1:1;
    unsigned int bit2:1;
    unsigned int bit3:1;
    unsigned int bit4:1;
    unsigned int bit5:1;
    unsigned int bit6:1;
    unsigned int bit7:1;
  } sdata = {0x01};

  while ( sdata.bit0-- > 0 ) {
    b++ ;
    if ( b > 100 ) break;
  }

  if (b != 1)
    abort ();
  return 0;
}
// source: 20040308-1.c
/* { dg-require-effective-target alloca } */
/* This used to fail on SPARC with an unaligned memory access.  */

void foo(int n)
{
  struct S {
    int i[n];
    unsigned int b:1;
    int i2;
  } __attribute__ ((packed)) __attribute__ ((aligned (4)));

  struct S s;

  s.i2 = 0;
}

int main(void)
{
  foo(4);

  return 0;
}
// source: 20040309-1.c
extern void abort ();

int foo(unsigned short x)
{
  unsigned short y;
  y = x > 32767 ? x - 32768 : 0;
  return y;
}

int main()
{
  if (foo (0) != 0)
    abort ();
  if (foo (32767) != 0)
    abort ();
  if (foo (32768) != 0)
    abort ();
  if (foo (32769) != 1)
    abort ();
  if (foo (65535) != 32767)
    abort ();
  return 0;
}
// source: 20040311-1.c
/* Copyright (C) 2004 Free Software Foundation.

   Check that constant folding and RTL simplification of -(x >> y) doesn't
   break anything and produces the expected results.

   Written by Roger Sayle, 11th March 2004.  */

extern void abort (void);

#define INT_BITS  (sizeof(int)*8)

int test1(int x)
{
  return -(x >> (INT_BITS-1));
}

int test2(unsigned int x)
{
  return -((int)(x >> (INT_BITS-1)));
}

int test3(int x)
{
  int y;
  y = INT_BITS-1;
  return -(x >> y);
}

int test4(unsigned int x)
{
  int y;
  y = INT_BITS-1;
  return -((int)(x >> y));
}

int main()
{
  if (test1(0) != 0)
    abort ();
  if (test1(1) != 0)
    abort ();
  if (test1(-1) != 1)
    abort ();

  if (test2(0) != 0)
    abort ();
  if (test2(1) != 0)
    abort ();
  if (test2((unsigned int)-1) != -1)
    abort ();

  if (test3(0) != 0)
    abort ();
  if (test3(1) != 0)
    abort ();
  if (test3(-1) != 1)
    abort ();

  if (test4(0) != 0)
    abort ();
  if (test4(1) != 0)
    abort ();
  if (test4((unsigned int)-1) != -1)
    abort ();

  return 0;
}
// source: 20040313-1.c
/* PR middle-end/14470 */
/* Origin: Lodewijk Voge <lvoge@cs.vu.nl> */

extern void abort(void);

int main()
{
  int t[1025] = { 1024 }, d;

  d = 0;
  d = t[d]++;
  if (t[0] != 1025)
    abort();
  if (d != 1024)
    abort();
  return 0;
}
// source: 20040319-1.c
int
blah (int zzz)
{
  int foo;
  if (zzz >= 0)
    return 1;
  foo = (zzz >= 0 ? (zzz) : -(zzz));
  return foo;
}

main()
{
  if (blah (-1) != 1)
    abort ();
  else
    exit (0);
}
// source: 20040331-1.c
/* PR c++/14755 */
extern void abort (void);
extern void exit (int);

int
main (void)
{
#if __INT_MAX__ >= 2147483647
  struct { int count: 31; } s = { 0 };
  while (s.count--)
    abort ();
#elif __INT_MAX__ >= 32767
  struct { int count: 15; } s = { 0 };
  while (s.count--)
    abort ();
#else
  /* Don't bother because __INT_MAX__ is too small.  */
#endif
  exit (0);
}
// source: 20040409-1.c
#include <limits.h>

extern void abort ();

int test1(int x)
{
  return x ^ INT_MIN;
}

unsigned int test1u(unsigned int x)
{
  return x ^ (unsigned int)INT_MIN;
}

unsigned int test2u(unsigned int x)
{
  return x + (unsigned int)INT_MIN;
}

unsigned int test3u(unsigned int x)
{
  return x - (unsigned int)INT_MIN;
}

int test4(int x)
{
  int y = INT_MIN;
  return x ^ y;
}

unsigned int test4u(unsigned int x)
{
  unsigned int y = (unsigned int)INT_MIN;
  return x ^ y;
}

unsigned int test5u(unsigned int x)
{
  unsigned int y = (unsigned int)INT_MIN;
  return x + y;
}

unsigned int test6u(unsigned int x)
{
  unsigned int y = (unsigned int)INT_MIN;
  return x - y;
}



void test(int a, int b)
{
  if (test1(a) != b)
    abort();
  if (test4(a) != b)
    abort();
}

void testu(unsigned int a, unsigned int b)
{
  if (test1u(a) != b)
    abort();
  if (test2u(a) != b)
    abort();
  if (test3u(a) != b)
    abort();
  if (test4u(a) != b)
    abort();
  if (test5u(a) != b)
    abort();
  if (test6u(a) != b)
    abort();
}


int main()
{
#if INT_MAX == 2147483647
  test(0x00000000,0x80000000);
  test(0x80000000,0x00000000);
  test(0x12345678,0x92345678);
  test(0x92345678,0x12345678);
  test(0x7fffffff,0xffffffff);
  test(0xffffffff,0x7fffffff);

  testu(0x00000000,0x80000000);
  testu(0x80000000,0x00000000);
  testu(0x12345678,0x92345678);
  testu(0x92345678,0x12345678);
  testu(0x7fffffff,0xffffffff);
  testu(0xffffffff,0x7fffffff);
#endif

#if INT_MAX == 32767
  test(0x0000,0x8000);
  test(0x8000,0x0000);
  test(0x1234,0x9234);
  test(0x9234,0x1234);
  test(0x7fff,0xffff);
  test(0xffff,0x7fff);

  testu(0x0000,0x8000);
  testu(0x8000,0x0000);
  testu(0x1234,0x9234);
  testu(0x9234,0x1234);
  testu(0x7fff,0xffff);
  testu(0xffff,0x7fff);
#endif

  return 0;
}
// source: 20040409-1w.c
/* { dg-additional-options "-fwrapv" } */

#include <limits.h>

extern void abort ();

int test2(int x)
{
  return x + INT_MIN;
}

int test3(int x)
{
  return x - INT_MIN;
}

int test5(int x)
{
  int y = INT_MIN;
  return x + y;
}

int test6(int x)
{
  int y = INT_MIN;
  return x - y;
}



void test(int a, int b)
{
  if (test2(a) != b)
    abort();
  if (test3(a) != b)
    abort();
  if (test5(a) != b)
    abort();
  if (test6(a) != b)
    abort();
}


int main()
{
#if INT_MAX == 2147483647
  test(0x00000000,0x80000000);
  test(0x80000000,0x00000000);
  test(0x12345678,0x92345678);
  test(0x92345678,0x12345678);
  test(0x7fffffff,0xffffffff);
  test(0xffffffff,0x7fffffff);
#endif

#if INT_MAX == 32767
  test(0x0000,0x8000);
  test(0x8000,0x0000);
  test(0x1234,0x9234);
  test(0x9234,0x1234);
  test(0x7fff,0xffff);
  test(0xffff,0x7fff);
#endif

  return 0;
}
// source: 20040409-2.c
#include <limits.h>

extern void abort ();

int test1(int x)
{
  return (x ^ INT_MIN) ^ 0x1234;
}

unsigned int test1u(unsigned int x)
{
  return (x ^ (unsigned int)INT_MIN) ^ 0x1234;
}

int test2(int x)
{
  return (x ^ 0x1234) ^ INT_MIN;
}

unsigned int test2u(unsigned int x)
{
  return (x ^ 0x1234) ^ (unsigned int)INT_MIN;
}

unsigned int test3u(unsigned int x)
{
  return (x + (unsigned int)INT_MIN) ^ 0x1234;
}

unsigned int test4u(unsigned int x)
{
  return (x ^ 0x1234) + (unsigned int)INT_MIN;
}

unsigned int test5u(unsigned int x)
{
  return (x - (unsigned int)INT_MIN) ^ 0x1234;
}

unsigned int test6u(unsigned int x)
{
  return (x ^ 0x1234) - (unsigned int)INT_MIN;
}

int test7(int x)
{
  int y = INT_MIN;
  int z = 0x1234;
  return (x ^ y) ^ z;
}

unsigned int test7u(unsigned int x)
{
  unsigned int y = (unsigned int)INT_MIN;
  unsigned int z = 0x1234;
  return (x ^ y) ^ z;
}

int test8(int x)
{
  int y = 0x1234;
  int z = INT_MIN;
  return (x ^ y) ^ z;
}

unsigned int test8u(unsigned int x)
{
  unsigned int y = 0x1234;
  unsigned int z = (unsigned int)INT_MIN;
  return (x ^ y) ^ z;
}

unsigned int test9u(unsigned int x)
{
  unsigned int y = (unsigned int)INT_MIN;
  unsigned int z = 0x1234;
  return (x + y) ^ z;
}

unsigned int test10u(unsigned int x)
{
  unsigned int y = 0x1234;
  unsigned int z = (unsigned int)INT_MIN;
  return (x ^ y) + z;
}

unsigned int test11u(unsigned int x)
{
  unsigned int y = (unsigned int)INT_MIN;
  unsigned int z = 0x1234;
  return (x - y) ^ z;
}

unsigned int test12u(unsigned int x)
{
  unsigned int y = 0x1234;
  unsigned int z = (unsigned int)INT_MIN;
  return (x ^ y) - z;
}


void test(int a, int b)
{
  if (test1(a) != b)
    abort();
  if (test2(a) != b)
    abort();
  if (test7(a) != b)
    abort();
  if (test8(a) != b)
    abort();
}

void testu(unsigned int a, unsigned int b)
{
  if (test1u(a) != b)
    abort();
  if (test2u(a) != b)
    abort();
  if (test3u(a) != b)
    abort();
  if (test4u(a) != b)
    abort();
  if (test5u(a) != b)
    abort();
  if (test6u(a) != b)
    abort();
  if (test7u(a) != b)
    abort();
  if (test8u(a) != b)
    abort();
  if (test9u(a) != b)
    abort();
  if (test10u(a) != b)
    abort();
  if (test11u(a) != b)
    abort();
  if (test12u(a) != b)
    abort();
}


int main()
{
#if INT_MAX == 2147483647
  test(0x00000000,0x80001234);
  test(0x00001234,0x80000000);
  test(0x80000000,0x00001234);
  test(0x80001234,0x00000000);
  test(0x7fffffff,0xffffedcb);
  test(0xffffffff,0x7fffedcb);

  testu(0x00000000,0x80001234);
  testu(0x00001234,0x80000000);
  testu(0x80000000,0x00001234);
  testu(0x80001234,0x00000000);
  testu(0x7fffffff,0xffffedcb);
  testu(0xffffffff,0x7fffedcb);
#endif

#if INT_MAX == 32767
  test(0x0000,0x9234);
  test(0x1234,0x8000);
  test(0x8000,0x1234);
  test(0x9234,0x0000);
  test(0x7fff,0xedcb);
  test(0xffff,0x6dcb);

  testu(0x0000,0x9234);
  testu(0x8000,0x1234);
  testu(0x1234,0x8000);
  testu(0x9234,0x0000);
  testu(0x7fff,0xedcb);
  testu(0xffff,0x6dcb);
#endif

  return 0;
}
// source: 20040409-2w.c
/* { dg-additional-options "-fwrapv" } */

#include <limits.h>

extern void abort ();

int test3(int x)
{
  return (x + INT_MIN) ^ 0x1234;
}

int test4(int x)
{
  return (x ^ 0x1234) + INT_MIN;
}

int test5(int x)
{
  return (x - INT_MIN) ^ 0x1234;
}

int test6(int x)
{
  return (x ^ 0x1234) - INT_MIN;
}

int test9(int x)
{
  int y = INT_MIN;
  int z = 0x1234;
  return (x + y) ^ z;
}

int test10(int x)
{
  int y = 0x1234;
  int z = INT_MIN;
  return (x ^ y) + z;
}

int test11(int x)
{
  int y = INT_MIN;
  int z = 0x1234;
  return (x - y) ^ z;
}

int test12(int x)
{
  int y = 0x1234;
  int z = INT_MIN;
  return (x ^ y) - z;
}


void test(int a, int b)
{
  if (test3(a) != b)
    abort();
  if (test4(a) != b)
    abort();
  if (test5(a) != b)
    abort();
  if (test6(a) != b)
    abort();
  if (test9(a) != b)
    abort();
  if (test10(a) != b)
    abort();
  if (test11(a) != b)
    abort();
  if (test12(a) != b)
    abort();
}


int main()
{
#if INT_MAX == 2147483647
  test(0x00000000,0x80001234);
  test(0x00001234,0x80000000);
  test(0x80000000,0x00001234);
  test(0x80001234,0x00000000);
  test(0x7fffffff,0xffffedcb);
  test(0xffffffff,0x7fffedcb);
#endif

#if INT_MAX == 32767
  test(0x0000,0x9234);
  test(0x1234,0x8000);
  test(0x8000,0x1234);
  test(0x9234,0x0000);
  test(0x7fff,0xedcb);
  test(0xffff,0x6dcb);
#endif

  return 0;
}
// source: 20040409-3.c
#include <limits.h>

extern void abort ();

int test1(int x)
{
  return ~(x ^ INT_MIN);
}

unsigned int test1u(unsigned int x)
{
  return ~(x ^ (unsigned int)INT_MIN);
}

unsigned int test2u(unsigned int x)
{
  return ~(x + (unsigned int)INT_MIN);
}

unsigned int test3u(unsigned int x)
{
  return ~(x - (unsigned int)INT_MIN);
}

int test4(int x)
{
  int y = INT_MIN;
  return ~(x ^ y);
}

unsigned int test4u(unsigned int x)
{
  unsigned int y = (unsigned int)INT_MIN;
  return ~(x ^ y);
}

unsigned int test5u(unsigned int x)
{
  unsigned int y = (unsigned int)INT_MIN;
  return ~(x + y);
}

unsigned int test6u(unsigned int x)
{
  unsigned int y = (unsigned int)INT_MIN;
  return ~(x - y);
}



void test(int a, int b)
{
  if (test1(a) != b)
    abort();
  if (test4(a) != b)
    abort();
}

void testu(unsigned int a, unsigned int b)
{
  if (test1u(a) != b)
    abort();
  if (test2u(a) != b)
    abort();
  if (test3u(a) != b)
    abort();
  if (test4u(a) != b)
    abort();
  if (test5u(a) != b)
    abort();
  if (test6u(a) != b)
    abort();
}


int main()
{
#if INT_MAX == 2147483647
  test(0x00000000,0x7fffffff);
  test(0x80000000,0xffffffff);
  test(0x12345678,0x6dcba987);
  test(0x92345678,0xedcba987);
  test(0x7fffffff,0x00000000);
  test(0xffffffff,0x80000000);

  testu(0x00000000,0x7fffffff);
  testu(0x80000000,0xffffffff);
  testu(0x12345678,0x6dcba987);
  testu(0x92345678,0xedcba987);
  testu(0x7fffffff,0x00000000);
  testu(0xffffffff,0x80000000);
#endif

#if INT_MAX == 32767
  test(0x0000,0x7fff);
  test(0x8000,0xffff);
  test(0x1234,0x6dcb);
  test(0x9234,0xedcb);
  test(0x7fff,0x0000);
  test(0xffff,0x8000);

  testu(0x0000,0x7fff);
  testu(0x8000,0xffff);
  testu(0x1234,0x6dcb);
  testu(0x9234,0xedcb);
  testu(0x7fff,0x0000);
  testu(0xffff,0x8000);
#endif

  return 0;
}
// source: 20040409-3w.c
/* { dg-additional-options "-fwrapv" } */

#include <limits.h>

extern void abort ();

int test2(int x)
{
  return ~(x + INT_MIN);
}

int test3(int x)
{
  return ~(x - INT_MIN);
}

int test5(int x)
{
  int y = INT_MIN;
  return ~(x + y);
}

int test6(int x)
{
  int y = INT_MIN;
  return ~(x - y);
}


void test(int a, int b)
{
  if (test2(a) != b)
    abort();
  if (test3(a) != b)
    abort();
  if (test5(a) != b)
    abort();
  if (test6(a) != b)
    abort();
}


int main()
{
#if INT_MAX == 2147483647
  test(0x00000000,0x7fffffff);
  test(0x80000000,0xffffffff);
  test(0x12345678,0x6dcba987);
  test(0x92345678,0xedcba987);
  test(0x7fffffff,0x00000000);
  test(0xffffffff,0x80000000);
#endif

#if INT_MAX == 32767
  test(0x0000,0x7fff);
  test(0x8000,0xffff);
  test(0x1234,0x6dcb);
  test(0x9234,0xedcb);
  test(0x7fff,0x0000);
  test(0xffff,0x8000);
#endif

  return 0;
}
// source: 20040411-1.c
int
sub1 (int i, int j)
{
  typedef int c[i+2];
  int x[10], y[10];

  if (j == 2)
    {
      memcpy (x, y, 10 * sizeof (int));
      return sizeof (c);
    }
  else
    return sizeof (c) * 3;
}

int
main ()
{
  if (sub1 (20, 3) != 66 * sizeof (int))
    abort ();

  return 0;
}
// source: 20040423-1.c
int
sub1 (int i, int j)
{
  typedef struct
  {
   int  c[i+2];
  }c;
  int x[10], y[10];

  if (j == 2)
    {
      memcpy (x, y, 10 * sizeof (int));
      return sizeof (c);
    }
  else
    return sizeof (c) * 3;
}

int
main ()
{
  typedef struct
  {
   int  c[22];
  }c;
  if (sub1 (20, 3) != sizeof (c)*3)
    abort ();

  return 0;
}
// source: 20040520-1.c
/* PR 15454 */

void abort ();
int main () {
        int foo;
        int bar (void)
        {
                int baz = 0;
                if (foo!=45)
                        baz = foo;
                return baz;
        }
        foo = 1;
        if (!bar ())
                abort ();
        return 0;
}
// source: 20040625-1.c
/* From PR target/16176 */
struct __attribute__ ((packed)) s { struct s *next; };

struct s * __attribute__ ((noinline))
maybe_next (struct s *s, int t)
{
  if (t)
    s = s->next;
  return s;
}

int main ()
{
  struct s s1, s2;

  s1.next = &s2;
  if (maybe_next (&s1, 1) != &s2)
    abort ();
  exit (0);
}
// source: 20040629-1.c
/* { dg-require-effective-target int32plus } */

/* Test arithmetics on bitfields.  */
#ifndef T

extern void abort (void);
extern void exit (int);

#ifndef FIELDS1
#define FIELDS1
#endif
#ifndef FIELDS2
#define FIELDS2
#endif

struct { FIELDS1 unsigned int i : 6, j : 11, k : 15; FIELDS2 } b;
struct { FIELDS1 unsigned int i : 5, j : 1, k : 26; FIELDS2 } c;
struct { FIELDS1 unsigned int i : 16, j : 8, k : 8; FIELDS2 } d;

unsigned int ret1 (void) { return b.i; }
unsigned int ret2 (void) { return b.j; }
unsigned int ret3 (void) { return b.k; }
unsigned int ret4 (void) { return c.i; }
unsigned int ret5 (void) { return c.j; }
unsigned int ret6 (void) { return c.k; }
unsigned int ret7 (void) { return d.i; }
unsigned int ret8 (void) { return d.j; }
unsigned int ret9 (void) { return d.k; }

#define T(n, pre, post, op) 					\
void fn1_##n (unsigned int x) { pre b.i post; }			\
void fn2_##n (unsigned int x) { pre b.j post; }			\
void fn3_##n (unsigned int x) { pre b.k post; }			\
void fn4_##n (unsigned int x) { pre c.i post; }			\
void fn5_##n (unsigned int x) { pre c.j post; }			\
void fn6_##n (unsigned int x) { pre c.k post; }			\
void fn7_##n (unsigned int x) { pre d.i post; }			\
void fn8_##n (unsigned int x) { pre d.j post; }			\
void fn9_##n (unsigned int x) { pre d.k post; }

#include "20040629-1.c"
#undef T

#define FAIL(n, i) abort ()

int
main (void)
{
#define T(n, pre, post, op)					\
  b.i = 51;							\
  b.j = 636;							\
  b.k = 31278;							\
  c.i = 21;							\
  c.j = 1;							\
  c.k = 33554432;						\
  d.i = 26812;							\
  d.j = 156;							\
  d.k = 187;							\
  fn1_##n (3);							\
  if (ret1 () != (op (51, 3) & ((1 << 6) - 1)))			\
    FAIL (n, 1);						\
  b.i = 51;							\
  fn2_##n (251);						\
  if (ret2 () != (op (636, 251) & ((1 << 11) - 1)))		\
    FAIL (n, 2);						\
  b.j = 636;							\
  fn3_##n (13279);						\
  if (ret3 () != (op (31278, 13279) & ((1 << 15) - 1)))		\
    FAIL (n, 3);						\
  b.j = 31278;							\
  fn4_##n (24);							\
  if (ret4 () != (op (21, 24) & ((1 << 5) - 1)))		\
    FAIL (n, 4);						\
  c.i = 21;							\
  fn5_##n (1);							\
  if (ret5 () != (op (1, 1) & ((1 << 1) - 1)))			\
    FAIL (n, 5);						\
  c.j = 1;							\
  fn6_##n (264151);						\
  if (ret6 () != (op (33554432, 264151) & ((1 << 26) - 1)))	\
    FAIL (n, 6);						\
  c.k = 33554432;						\
  fn7_##n (713);						\
  if (ret7 () != (op (26812, 713) & ((1 << 16) - 1)))		\
    FAIL (n, 7);						\
  d.i = 26812;							\
  fn8_##n (17);							\
  if (ret8 () != (op (156, 17) & ((1 << 8) - 1)))		\
    FAIL (n, 8);						\
  d.j = 156;							\
  fn9_##n (199);						\
  if (ret9 () != (op (187, 199) & ((1 << 8) - 1)))		\
    FAIL (n, 9);						\
  d.k = 187;

#include "20040629-1.c"
#undef T
  return 0;
}

#else

#ifndef opadd
#define opadd(x, y) (x + y)
#define opsub(x, y) (x - y)
#define opinc(x, y) (x + 1)
#define opdec(x, y) (x - 1)
#define opand(x, y) (x & y)
#define opior(x, y) (x | y)
#define opxor(x, y) (x ^ y)
#define opdiv(x, y) (x / y)
#define oprem(x, y) (x % y)
#define opadd3(x, y) (x + 3)
#define opsub7(x, y) (x - 7)
#define opand21(x, y) (x & 21)
#define opior19(x, y) (x | 19)
#define opxor37(x, y) (x ^ 37)
#define opdiv17(x, y) (x / 17)
#define oprem19(x, y) (x % 19)
#endif

T(1, , += x, opadd)
T(2, ++, , opinc)
T(3, , ++, opinc)
T(4, , -= x, opsub)
T(5, --, , opdec)
T(6, , --, opdec)
T(7, , &= x, opand)
T(8, , |= x, opior)
T(9, , ^= x, opxor)
T(a, , /= x, opdiv)
T(b, , %= x, oprem)
T(c, , += 3, opadd3)
T(d, , -= 7, opsub7)
T(e, , &= 21, opand21)
T(f, , |= 19, opior19)
T(g, , ^= 37, opxor37)
T(h, , /= 17, opdiv17)
T(i, , %= 19, oprem19)

#endif
// source: 20040703-1.c
/* PR 16341 */
/* { dg-require-effective-target int32plus } */

#define PART_PRECISION (sizeof (cpp_num_part) * 8)

typedef unsigned int cpp_num_part;
typedef struct cpp_num cpp_num;
struct cpp_num
{
   cpp_num_part high;
   cpp_num_part low;
   int unsignedp;  /* True if value should be treated as unsigned.  */
   int overflow;   /* True if the most recent calculation overflowed.  */
};

static  int
num_positive (cpp_num num, unsigned int precision)
{
   if (precision > PART_PRECISION)
     {
       precision -= PART_PRECISION;
       return (num.high & (cpp_num_part) 1 << (precision - 1)) == 0;
     }

   return (num.low & (cpp_num_part) 1 << (precision - 1)) == 0;
}

static cpp_num
num_trim (cpp_num num, unsigned int precision)
{
   if (precision > PART_PRECISION)
     {
       precision -= PART_PRECISION;
       if (precision < PART_PRECISION)
         num.high &= ((cpp_num_part) 1 << precision) - 1;
     }
   else
     {
       if (precision < PART_PRECISION)
         num.low &= ((cpp_num_part) 1 << precision) - 1;
       num.high = 0;
     }

   return num;
}

/* Shift NUM, of width PRECISION, right by N bits.  */
static cpp_num
num_rshift (cpp_num num, unsigned int precision, unsigned int n)
{
   cpp_num_part sign_mask;
   int x = num_positive (num, precision);

   if (num.unsignedp || x)
     sign_mask = 0;
   else
     sign_mask = ~(cpp_num_part) 0;

   if (n >= precision)
     num.high = num.low = sign_mask;
   else
     {
       /* Sign-extend.  */
       if (precision < PART_PRECISION)
         num.high = sign_mask, num.low |= sign_mask << precision;
       else if (precision < 2 * PART_PRECISION)
         num.high |= sign_mask << (precision - PART_PRECISION);

       if (n >= PART_PRECISION)
         {
           n -= PART_PRECISION;
           num.low = num.high;
           num.high = sign_mask;
         }

       if (n)
         {
           num.low = (num.low >> n) | (num.high << (PART_PRECISION - n));
           num.high = (num.high >> n) | (sign_mask << (PART_PRECISION - n));
         }
     }

   num = num_trim (num, precision);
   num.overflow = 0;
   return num;
}
                              #define num_zerop(num) ((num.low | num.high) == 0)
#define num_eq(num1, num2) (num1.low == num2.low && num1.high == num2.high)

cpp_num
num_lshift (cpp_num num, unsigned int precision, unsigned int n)
{
   if (n >= precision)
     {
       num.overflow = !num.unsignedp && !num_zerop (num);
       num.high = num.low = 0;
     }
   else
     {
       cpp_num orig;
       unsigned int m = n;

       orig = num;
       if (m >= PART_PRECISION)
         {
           m -= PART_PRECISION;
           num.high = num.low;
           num.low = 0;
         }
       if (m)
         {
           num.high = (num.high << m) | (num.low >> (PART_PRECISION - m));
           num.low <<= m;
         }
       num = num_trim (num, precision);

       if (num.unsignedp)
         num.overflow = 0;
       else
         {
           cpp_num maybe_orig = num_rshift (num, precision, n);
           num.overflow = !num_eq (orig, maybe_orig);
         }
     }

   return num;
}

unsigned int precision = 64;
unsigned int n = 16;

cpp_num num = { 0, 3, 0, 0 };

int main()
{
   cpp_num res = num_lshift (num, 64, n);

   if (res.low != 0x30000)
     abort ();

   if (res.high != 0)
     abort ();

   if (res.overflow != 0)
     abort ();

   exit (0);
}
// source: 20040704-1.c
/* PR 16348: Make sure that condition-first false loops DTRT.  */

extern void abort ();

int main()
{
  for (; 0 ;)
    {
      abort ();
    label:
      return 0;
    }
  goto label;
}
// source: 20040705-1.c
/* { dg-require-effective-target int32plus } */

#define FIELDS1 long long l;
#include "20040629-1.c"
// source: 20040705-2.c
/* { dg-require-effective-target int32plus } */
#define FIELDS2 long long l;
#include "20040629-1.c"
// source: 20040706-1.c
int main ()
{
  int i;
  for (i = 0; i < 10; i++)
    continue;
  if (i < 10)
    abort ();
  exit (0);
}
// source: 20040707-1.c
struct s { char c1, c2; };
void foo (struct s s)
{
  static struct s s1;
  s1 = s;
}
int main ()
{
  static struct s s2;
  foo (s2);
  exit (0);
}
// source: 20040709-1.c
/* { dg-require-effective-target int32plus } */

/* Test arithmetics on bitfields.  */

extern void abort (void);
extern void exit (int);

unsigned int
myrnd (void)
{
  static unsigned int s = 1388815473;
  s *= 1103515245;
  s += 12345;
  return (s / 65536) % 2048;
}

#define T(S)					\
struct S s##S;					\
struct S retme##S (struct S x)			\
{						\
  return x;					\
}						\
						\
unsigned int fn1##S (unsigned int x)		\
{						\
  struct S y = s##S;				\
  y.k += x;					\
  y = retme##S (y);				\
  return y.k;					\
}						\
						\
unsigned int fn2##S (unsigned int x)		\
{						\
  struct S y = s##S;				\
  y.k += x;					\
  y.k %= 15;					\
  return y.k;					\
}						\
						\
unsigned int retit##S (void)			\
{						\
  return s##S.k;				\
}						\
						\
unsigned int fn3##S (unsigned int x)		\
{						\
  s##S.k += x;					\
  return retit##S ();				\
}						\
						\
void test##S (void)				\
{						\
  int i;					\
  unsigned int mask, v, a, r;			\
  struct S x;					\
  char *p = (char *) &s##S;			\
  for (i = 0; i < sizeof (s##S); ++i)		\
    *p++ = myrnd ();				\
  if (__builtin_classify_type (s##S.l) == 8)	\
    s##S.l = 5.25;				\
  s##S.k = -1;					\
  mask = s##S.k;				\
  v = myrnd ();					\
  a = myrnd ();					\
  s##S.k = v;					\
  x = s##S;					\
  r = fn1##S (a);				\
  if (x.i != s##S.i || x.j != s##S.j		\
      || x.k != s##S.k || x.l != s##S.l		\
      || ((v + a) & mask) != r)			\
    abort ();					\
  v = myrnd ();					\
  a = myrnd ();					\
  s##S.k = v;					\
  x = s##S;					\
  r = fn2##S (a);				\
  if (x.i != s##S.i || x.j != s##S.j		\
      || x.k != s##S.k || x.l != s##S.l		\
      || ((((v + a) & mask) % 15) & mask) != r)	\
    abort ();					\
  v = myrnd ();					\
  a = myrnd ();					\
  s##S.k = v;					\
  x = s##S;					\
  r = fn3##S (a);				\
  if (x.i != s##S.i || x.j != s##S.j		\
      || s##S.k != r || x.l != s##S.l		\
      || ((v + a) & mask) != r)			\
    abort ();					\
}

struct A { unsigned int i : 6, l : 1, j : 10, k : 15; }; T(A)
struct B { unsigned int i : 6, j : 11, k : 15; unsigned int l; }; T(B)
struct C { unsigned int l; unsigned int i : 6, j : 11, k : 15; }; T(C)
struct D { unsigned long long l : 6, i : 6, j : 23, k : 29; }; T(D)
struct E { unsigned long long l, i : 12, j : 23, k : 29; }; T(E)
struct F { unsigned long long i : 12, j : 23, k : 29, l; }; T(F)
struct G { unsigned int i : 12, j : 13, k : 7; unsigned long long l; }; T(G)
struct H { unsigned int i : 12, j : 11, k : 9; unsigned long long l; }; T(H)
struct I { unsigned short i : 1, j : 6, k : 9; unsigned long long l; }; T(I)
struct J { unsigned short i : 1, j : 8, k : 7; unsigned short l; }; T(J)
struct K { unsigned int k : 6, l : 1, j : 10, i : 15; }; T(K)
struct L { unsigned int k : 6, j : 11, i : 15; unsigned int l; }; T(L)
struct M { unsigned int l; unsigned int k : 6, j : 11, i : 15; }; T(M)
struct N { unsigned long long l : 6, k : 6, j : 23, i : 29; }; T(N)
struct O { unsigned long long l, k : 12, j : 23, i : 29; }; T(O)
struct P { unsigned long long k : 12, j : 23, i : 29, l; }; T(P)
struct Q { unsigned int k : 12, j : 13, i : 7; unsigned long long l; }; T(Q)
struct R { unsigned int k : 12, j : 11, i : 9; unsigned long long l; }; T(R)
struct S { unsigned short k : 1, j : 6, i : 9; unsigned long long l; }; T(S)
struct T { unsigned short k : 1, j : 8, i : 7; unsigned short l; }; T(T)
struct U { unsigned short j : 6, k : 1, i : 9; unsigned long long l; }; T(U)
struct V { unsigned short j : 8, k : 1, i : 7; unsigned short l; }; T(V)
struct W { long double l; unsigned int k : 12, j : 13, i : 7; }; T(W)
struct X { unsigned int k : 12, j : 13, i : 7; long double l; }; T(X)
struct Y { unsigned int k : 12, j : 11, i : 9; long double l; }; T(Y)
struct Z { long double l; unsigned int j : 13, i : 7, k : 12; }; T(Z)

int
main (void)
{
  testA ();
  testB ();
  testC ();
  testD ();
  testE ();
  testF ();
  testG ();
  testH ();
  testI ();
  testJ ();
  testK ();
  testL ();
  testM ();
  testN ();
  testO ();
  testP ();
  testQ ();
  testR ();
  testS ();
  testT ();
  testU ();
  testV ();
  testW ();
  testX ();
  testY ();
  testZ ();
  exit (0);
}
// source: 20040709-2.c
/* Test arithmetics on bitfields.  */
/* { dg-require-effective-target int32plus } */

extern void abort (void);
extern void exit (int);

unsigned int
myrnd (void)
{
  static unsigned int s = 1388815473;
  s *= 1103515245;
  s += 12345;
  return (s / 65536) % 2048;
}

#define T(S)					\
struct S s##S;					\
struct S retme##S (struct S x)			\
{						\
  return x;					\
}						\
						\
unsigned int fn1##S (unsigned int x)		\
{						\
  struct S y = s##S;				\
  y.k += x;					\
  y = retme##S (y);				\
  return y.k;					\
}						\
						\
unsigned int fn2##S (unsigned int x)		\
{						\
  struct S y = s##S;				\
  y.k += x;					\
  y.k %= 15;					\
  return y.k;					\
}						\
						\
unsigned int retit##S (void)			\
{						\
  return s##S.k;				\
}						\
						\
unsigned int fn3##S (unsigned int x)		\
{						\
  s##S.k += x;					\
  return retit##S ();				\
}						\
						\
void test##S (void)				\
{						\
  int i;					\
  unsigned int mask, v, a, r;			\
  struct S x;					\
  char *p = (char *) &s##S;			\
  for (i = 0; i < sizeof (s##S); ++i)		\
    *p++ = myrnd ();				\
  if (__builtin_classify_type (s##S.l) == 8)	\
    s##S.l = 5.25;				\
  s##S.k = -1;					\
  mask = s##S.k;				\
  v = myrnd ();					\
  a = myrnd ();					\
  s##S.k = v;					\
  x = s##S;					\
  r = fn1##S (a);				\
  if (x.i != s##S.i || x.j != s##S.j		\
      || x.k != s##S.k || x.l != s##S.l		\
      || ((v + a) & mask) != r)			\
    abort ();					\
  v = myrnd ();					\
  a = myrnd ();					\
  s##S.k = v;					\
  x = s##S;					\
  r = fn2##S (a);				\
  if (x.i != s##S.i || x.j != s##S.j		\
      || x.k != s##S.k || x.l != s##S.l		\
      || ((((v + a) & mask) % 15) & mask) != r)	\
    abort ();					\
  v = myrnd ();					\
  a = myrnd ();					\
  s##S.k = v;					\
  x = s##S;					\
  r = fn3##S (a);				\
  if (x.i != s##S.i || x.j != s##S.j		\
      || s##S.k != r || x.l != s##S.l		\
      || ((v + a) & mask) != r)			\
    abort ();					\
}

#define pck __attribute__((packed))
struct pck A { unsigned short i : 1, l : 1, j : 3, k : 11; }; T(A)
struct pck B { unsigned short i : 4, j : 1, k : 11; unsigned int l; }; T(B)
struct pck C { unsigned int l; unsigned short i : 4, j : 1, k : 11; }; T(C)
struct pck D { unsigned long long l : 6, i : 6, j : 23, k : 29; }; T(D)
struct pck E { unsigned long long l, i : 12, j : 23, k : 29; }; T(E)
struct pck F { unsigned long long i : 12, j : 23, k : 29, l; }; T(F)
struct pck G { unsigned short i : 1, j : 1, k : 6; unsigned long long l; }; T(G)
struct pck H { unsigned short i : 6, j : 2, k : 8; unsigned long long l; }; T(H)
struct pck I { unsigned short i : 1, j : 6, k : 1; unsigned long long l; }; T(I)
struct pck J { unsigned short i : 1, j : 8, k : 7; unsigned short l; }; T(J)
struct pck K { unsigned int k : 6, l : 1, j : 10, i : 15; }; T(K)
struct pck L { unsigned int k : 6, j : 11, i : 15; unsigned int l; }; T(L)
struct pck M { unsigned int l; unsigned short k : 6, j : 11, i : 15; }; T(M)
struct pck N { unsigned long long l : 6, k : 6, j : 23, i : 29; }; T(N)
struct pck O { unsigned long long l, k : 12, j : 23, i : 29; }; T(O)
struct pck P { unsigned long long k : 12, j : 23, i : 29, l; }; T(P)
struct pck Q { unsigned short k : 12, j : 1, i : 3; unsigned long long l; }; T(Q)
struct pck R { unsigned short k : 2, j : 11, i : 3; unsigned long long l; }; T(R)
struct pck S { unsigned short k : 1, j : 6, i : 9; unsigned long long l; }; T(S)
struct pck T { unsigned short k : 1, j : 8, i : 7; unsigned short l; }; T(T)
struct pck U { unsigned short j : 6, k : 1, i : 9; unsigned long long l; }; T(U)
struct pck V { unsigned short j : 8, k : 1, i : 7; unsigned short l; }; T(V)
struct pck W { long double l; unsigned int k : 12, j : 13, i : 7; }; T(W)
struct pck X { unsigned int k : 12, j : 13, i : 7; long double l; }; T(X)
struct pck Y { unsigned int k : 12, j : 11, i : 9; long double l; }; T(Y)
struct pck Z { long double l; unsigned int j : 13, i : 7, k : 12; }; T(Z)

int
main (void)
{
  testA ();
  testB ();
  testC ();
  testD ();
  testE ();
  testF ();
  testG ();
  testH ();
  testI ();
  testJ ();
  testK ();
  testL ();
  testM ();
  testN ();
  testO ();
  testP ();
  testQ ();
  testR ();
  testS ();
  testT ();
  testU ();
  testV ();
  testW ();
  testX ();
  testY ();
  testZ ();
  exit (0);
}
// source: 20040709-3.c
/* PR rtl-optimization/68205 */
/* { dg-require-effective-target int32plus } */
/* { dg-additional-options "-fno-common" } */

#include "20040709-2.c"
// source: 20040805-1.c
/* { dg-require-stack-size "0x12000" } */

#if __INT_MAX__ < 32768
int main () { exit (0); }
#else
int a[2] = { 2, 3 };

static int __attribute__((noinline))
bar (int x, void *b)
{
  a[0]++;
  return x;
}

static int __attribute__((noinline))
foo (int x)
{
  char buf[0x10000];
  int y = a[0];
  a[1] = y;
  x = bar (x, buf);
  y = bar (y, buf);
  return x + y;
}

int
main ()
{
  if (foo (100) != 102)
    abort ();
  exit (0);
}
#endif
// source: 20040811-1.c
/* { dg-require-effective-target int32plus } */
/* { dg-require-effective-target alloca } */

/* Ensure that we deallocate X when branching back before its
   declaration.  */

void *volatile p;

int
main (void)
{
  int n = 0;
 lab:;
  int x[n % 1000 + 1];
  x[0] = 1;
  x[n % 1000] = 2;
  p = x;
  n++;
  if (n < 1000000)
    goto lab;
  return 0;
}
// source: 20040820-1.c
/* PR rtl-optimization/17099 */

extern void exit (int);
extern void abort (void);

void
check (int a)
{
  if (a != 1)
    abort ();
}

void
test (int a, int b)
{
  check ((a ? 1 : 0) | (b ? 2 : 0));
}

int
main (void)
{
  test (1, 0);
  exit (0);
}
// source: 20040823-1.c
/* Ensure that we create VUSE operands also for noreturn functions.  */

#include <stdlib.h>
#include <string.h>

int *pwarn;

void bla (void) __attribute__ ((noreturn));

void bla (void)
{
  if (!*pwarn)
    abort ();

  exit (0);
}

int main (void)
{
  int warn;

  memset (&warn, 0, sizeof (warn));

  pwarn = &warn;

  warn = 1;

  bla ();
}
// source: 20040831-1.c
/* This testcase was being miscompiled, because operand_equal_p
   returned that (unsigned long) d and (long) d are equal.  */
extern void abort (void);
extern void exit (int);

int
main (void)
{
  double d = -12.0;
  long l = (d > 10000) ? (unsigned long) d : (long) d;
  if (l != -12)
    abort ();
  exit (0);
}
// source: 20040917-1.c
/* submitted by kenneth zadeck */

static int test_var;

/* the idea here is that not only is inlinable, inlinable but since it
   is static, the cgraph node will not be marked as output.  The
   current version of the code ignores these cgraph nodes.  */

void not_inlinable()  __attribute__((noinline));

static void
inlinable ()
{
  test_var = -10;
}

void
not_inlinable ()
{
  inlinable();
}

main ()
{
  test_var = 10;
  /* Variable test_var should be considered call-clobbered by the call
     to not_inlinable().  */
  not_inlinable ();
  if (test_var == 10)
    abort ();
  return 0;
}
// source: 20041011-1.c
typedef unsigned long long ull;
volatile int gvol[32];
ull gull;

#define MULTI(X) \
	X( 1), X( 2), X( 3), X( 4), X( 5), X( 6), X( 7), X( 8), X( 9), X(10), \
	X(11), X(12), X(13), X(14), X(15), X(16), X(17), X(18), X(19), X(20), \
	X(21), X(22), X(23), X(24), X(25), X(26), X(27), X(28), X(29), X(30)

#define DECLARE(INDEX) x##INDEX
#define COPYIN(INDEX) x##INDEX = gvol[INDEX]
#define COPYOUT(INDEX) gvol[INDEX] = x##INDEX

#define BUILD_TEST(NAME, N)		\
  ull __attribute__((noinline))		\
  NAME (int n, ull x)			\
  {					\
    while (n--)				\
      {					\
	int MULTI (DECLARE);		\
	MULTI (COPYIN);			\
	MULTI (COPYOUT);		\
	x += N;				\
      }					\
    return x;				\
  }

#define RUN_TEST(NAME, N)		\
  if (NAME (3, ~0ULL) != N * 3 - 1)	\
    abort ();				\
  if (NAME (3, 0xffffffffULL)		\
      != N * 3 + 0xffffffffULL)		\
    abort ();

#define DO_TESTS(DO_TEST)	\
  DO_TEST (t1, -2048)		\
  DO_TEST (t2, -513)		\
  DO_TEST (t3, -512)		\
  DO_TEST (t4, -511)		\
  DO_TEST (t5, -1)		\
  DO_TEST (t6, 1)		\
  DO_TEST (t7, 511)		\
  DO_TEST (t8, 512)		\
  DO_TEST (t9, 513)		\
  DO_TEST (t10, gull)		\
  DO_TEST (t11, -gull)

DO_TESTS (BUILD_TEST)

ull neg (ull x) { return -x; }

int
main ()
{
  gull = 100;
  DO_TESTS (RUN_TEST)
  if (neg (gull) != -100ULL)
    abort ();
  exit (0);
}
// source: 20041019-1.c
test_store_ccp (int i)
{
  int *p, a, b, c;

  if (i < 5)
    p = &a;
  else if (i > 8)
    p = &b;
  else
    p = &c;

  *p = 10;
  b = 3;

  /* STORE-CCP was wrongfully propagating 10 into *p.  */
  return *p + 2;
}


test_store_copy_prop (int i)
{
  int *p, a, b, c;

  if (i < 5)
    p = &a;
  else if (i > 8)
    p = &b;
  else
    p = &c;

  *p = i;
  b = i + 1;

  /* STORE-COPY-PROP was wrongfully propagating i into *p.  */
  return *p;
}


main()
{
  int x;

  x = test_store_ccp (10);
  if (x == 12)
    abort ();

  x = test_store_copy_prop (9);
  if (x == 9)
    abort ();

  return 0;
}
// source: 20041112-1.c
/* This was failing on Alpha because the comparison (p != -1) was rewritten
   as (p+1 != 0) and p+1 isn't allowed to wrap for pointers.  */

extern void abort(void);

typedef __SIZE_TYPE__ size_t;

int global;

static void *foo(int p)
{
  if (p == 0)
   {
      global++;
      return &global;
   }

  return (void *)(size_t)-1;
}

int bar(void)
{
  void *p;

  p = foo(global);
  if (p != (void *)(size_t)-1)
    return 1;

  global++;
  return 0;
}

int main(void)
{
  global = 1;
  if (bar () != 0)
    abort();

  return 0;
}
// source: 20041113-1.c
#include <stdarg.h>

void test (int x, ...)
{
    va_list ap;
    int i;
    va_start (ap, x);
    if (va_arg (ap, int) != 1)
	abort ();
    if (va_arg (ap, int) != 2)
	abort ();
    if (va_arg (ap, int) != 3)
	abort ();
    if (va_arg (ap, int) != 4)
	abort ();
}

double a = 40.0;

int main(int argc, char *argv[])
{
    test(0, 1, 2, 3, (int)(a / 10.0));
    exit (0);
}
// source: 20041114-1.c
/* Verify that

   var <= 0 || ((long unsigned) (unsigned) (var - 1) < MAX_UNSIGNED_INT)

   gets folded to 1.  */

#include <limits.h>

void abort (void);
void link_failure (void);

volatile int v;

void
foo (int var)
{
  if (!(var <= 0
        || ((long unsigned) (unsigned) (var - 1) < UINT_MAX)))
    link_failure ();
}

int
main (int argc, char **argv)
{
  foo (v);
  return 0;
}

#ifndef __OPTIMIZE__
void
link_failure (void)
{
  abort ();
}
#endif
// source: 20041124-1.c
struct s { _Complex unsigned short x; };
struct s gs = { 100 + 200i };
struct s __attribute__((noinline)) foo (void) { return gs; }

int main ()
{
  if (foo ().x != gs.x)
    abort ();
  exit (0);
}
// source: 20041126-1.c
extern int abs (int);
extern void abort (void);

void
check (int *p)
{
  int i;
  for (i = 0; i < 5; ++i)
    if (p[i])
      abort ();
  for (; i < 10; ++i)
    if (p[i] != i + 1)
      abort ();
}

int
main (void)
{
  int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
  int i;

  for (i = -5; i < 0; i++)
    a[abs (i - 10) - 11] = 0;
  check (a);
  return 0;
}
// source: 20041201-1.c
/* PR rtl-opt/15289 */

typedef struct { _Complex char a; _Complex char b; } Scc2;

Scc2 s = { 1+2i, 3+4i };

int checkScc2 (Scc2 s)
{
  return s.a != 1+2i || s.b != 3+4i;
}

int main (void)
{
  return checkScc2 (s);
}
// source: 20041210-1.c
/* The FR-V port used to fail this test because the andcc patterns
   wrongly claimed to set the C and V flags.  */
#include <limits.h>

int x[4] = { INT_MIN / 2, INT_MAX, 2, 4 };

int
main ()
{
  if (x[0] < x[1])
    if ((x[2] & x[3]) < 0)
      abort ();
  exit (0);
}
// source: 20041212-1.c
/* A function pointer compared with a void pointer should not be canonicalized.
   See PR middle-end/17564.  */
void *f (void) __attribute__ ((__noinline__));
void *
f (void)
{
  return f;
}
int
main (void)
{
  if (f () != f)
    abort ();
  exit (0);
}
// source: 20041213-2.c
/* PR tree-optimization/18694

   The dominator optimization didn't take the PHI evaluation order
   into account when threading an edge.  */

extern void abort (void) __attribute__((noreturn));
extern void exit (int) __attribute__((noreturn));

void __attribute__((noinline))
foo (int i)
{
  int next_n = 1;
  int j = 0;

  for (; i != 0; i--)
    {
      int n;

      for (n = next_n; j < n; j++)
	next_n++;

      if (j != n)
	abort ();
    }
}

int
main (void)
{
  foo (2);
  exit (0);
}
// source: 20041214-1.c
/* { dg-require-effective-target indirect_jumps } */

typedef long unsigned int size_t;
extern void abort (void);
extern char *strcpy (char *, const char *);
extern int strcmp (const char *, const char *);
typedef __builtin_va_list va_list;
static const char null[] = "(null)";
int g (char *s, const char *format, va_list ap)
{
  const char *f;
  const char *string;
  char spec;
  static const void *step0_jumps[] = {
    &&do_precision,
    &&do_form_integer,
    &&do_form_string,
  };
  f = format;
  if (*f == '\0')
    goto all_done;
  do
    {
      spec = (*++f);
      goto *(step0_jumps[2]);

    /* begin switch table. */
    do_precision:
      ++f;
      __builtin_va_arg (ap, int);
      spec = *f;
      goto *(step0_jumps[2]);

      do_form_integer:
	__builtin_va_arg (ap, unsigned long int);
	goto end;

      do_form_string:
	string = __builtin_va_arg (ap, const char *);
	strcpy (s, string);

      /* End of switch table. */
      end:
      ++f;
    }
  while (*f != '\0');

all_done:
  return 0;
}

void
f (char *s, const char *f, ...)
{
  va_list ap;
  __builtin_va_start (ap, f);
  g (s, f, ap);
  __builtin_va_end (ap);
}

int
main (void)
{
  char buf[10];
  f (buf, "%s", "asdf", 0);
  if (strcmp (buf, "asdf"))
    abort ();
  return 0;
}
// source: 20041218-1.c
/* PR rtl-optimization/16968 */
/* Testcase by Jakub Jelinek  <jakub@redhat.com> */

struct T
{
  unsigned int b, c, *d;
  unsigned char e;
};
struct S
{
  unsigned int a;
  struct T f;
};
struct U
{
  struct S g, h;
};
struct V
{
  unsigned int i;
  struct U j;
};

extern void exit (int);
extern void abort (void);

void *
dummy1 (void *x)
{
  return "";
}

void *
dummy2 (void *x, void *y)
{
  exit (0);
}

struct V *
baz (unsigned int x)
{
  static struct V v;
  __builtin_memset (&v, 0x55, sizeof (v));
  return &v;
}

int
check (void *x, struct S *y)
{
  if (y->a || y->f.b || y->f.c || y->f.d || y->f.e)
    abort ();
  return 1;
}

static struct V *
bar (unsigned int x, void *y)
{
  const struct T t = { 0, 0, (void *) 0, 0 };
  struct V *u;
  void *v;
  v = dummy1 (y);
  if (!v)
    return (void *) 0;

  u = baz (sizeof (struct V));
  u->i = x;
  u->j.g.a = 0;
  u->j.g.f = t;
  u->j.h.a = 0;
  u->j.h.f = t;

  if (!check (v, &u->j.g) || !check (v, &u->j.h))
    return (void *) 0;
  return u;
}

int
foo (unsigned int *x, unsigned int y, void **z)
{
  void *v;
  unsigned int i, j;

  *z = v = (void *) 0;

  for (i = 0; i < y; i++)
    {
      struct V *c;

      j = *x;

      switch (j)
	{
	case 1:
	  c = bar (j, x);
	  break;
	default:
	  c = 0;
	  break;
	}
      if (c)
	v = dummy2 (v, c);
      else
        return 1;
    }

  *z = v;
  return 0;
}

int
main (void)
{
  unsigned int one = 1;
  void *p;
  foo (&one, 1, &p);
  abort ();
}
// source: 20041218-2.c
extern void abort (void);

int test(int n)
{
  struct s { char b[n]; } __attribute__((packed));
  n++;
  return sizeof(struct s);
}

int main()
{
  if (test(123) != 123)
    abort ();
  return 0;
}
// source: 20050104-1.c
/* PR tree-optimization/19060 */

void abort (void);

static
long long min ()
{
  return -__LONG_LONG_MAX__ - 1;
}

void
foo (long long j)
{
  if (j > 10 || j < min ())
    abort ();
}

int
main (void)
{
  foo (10);
  return 0;
}
// source: 20050106-1.c
/* PR tree-optimization/19283 */

void abort (void);

static inline unsigned short
foo (unsigned int *p)
{
  return *p;
};

unsigned int u;

int
main ()
{
  if ((foo (&u) & 0x8000) != 0)
    abort ();
  return 0;
}
// source: 20050107-1.c
typedef enum { C = 1, D = 2 } B;
extern void abort (void);

struct S
{
  B __attribute__ ((mode (byte))) a;
  B __attribute__ ((mode (byte))) b;
};

void
foo (struct S *x)
{
  if (x->a != C || x->b != D)
    abort ();
}

int
main (void)
{
  struct S s;
  s.a = C;
  s.b = D;
  foo (&s);
  return 0;
}
// source: 20050111-1.c
/* PR middle-end/19084, rtl-optimization/19348 */

unsigned int
foo (unsigned long long x)
{
  unsigned int u;

  if (x == 0)
    return 0;
  u = (unsigned int) (x >> 32);
  return u;
}

unsigned long long
bar (unsigned short x)
{
  return (unsigned long long) x << 32;
}

extern void abort (void);

int
main (void)
{
  if (sizeof (long long) != 8)
    return 0;

  if (foo (0) != 0)
    abort ();
  if (foo (0xffffffffULL) != 0)
    abort ();
  if (foo (0x25ff00ff00ULL) != 0x25)
    abort ();
  if (bar (0) != 0)
    abort ();
  if (bar (0x25) != 0x2500000000ULL)
    abort ();
  return 0;
}
// source: 20050119-1.c
/* PR c/19342 */
typedef enum { A, B, C, D } E;

struct S {
  E __attribute__ ((mode (__byte__))) a;
  E __attribute__ ((mode (__byte__))) b;
  E __attribute__ ((mode (__byte__))) c;
  E __attribute__ ((mode (__byte__))) d;
};

extern void abort (void);
extern void exit (int);

void
foo (struct S *s)
{
  if (s->a != s->b)
    abort ();
  if (s->c != C)
    abort ();
}

int
main (void)
{
  struct S s[2];
  s[0].a = B;
  s[0].b = B;
  s[0].c = C;
  s[0].d = D;
  s[1].a = D;
  s[1].b = C;
  s[1].c = B;
  s[1].d = A;
  foo (s);
  exit (0);
}
// source: 20050119-2.c
/* PR middle-end/19874 */
typedef enum { A, B, C, D } E;

struct S {
  E __attribute__ ((mode (__byte__))) a;
  E __attribute__ ((mode (__byte__))) b;
  E __attribute__ ((mode (__byte__))) c;
  E __attribute__ ((mode (__byte__))) d;
};

extern void abort (void);
extern void exit (int);

E
foo (struct S *s)
{
  if (s->a != s->b)
    abort ();
  if (s->c != C)
    abort ();
  return s->d;
}

int
main (void)
{
  struct S s[2];
  s[0].a = B;
  s[0].b = B;
  s[0].c = C;
  s[0].d = D;
  s[1].a = D;
  s[1].b = C;
  s[1].c = B;
  s[1].d = A;
  if (foo (s) != D)
    abort ();
  exit (0);
}
// source: 20050121-1.c
/* PR middle-end/19551 */

extern void abort ();

#define T(type, name) \
__attribute__((pure)) _Complex type		\
foo_##name (int x)				\
{						\
  _Complex type r;				\
  __real r = x + 1;				\
  __imag r = x - 1;				\
  return r;					\
}						\
						\
void						\
bar_##name (type *x)				\
{						\
  *x = __real foo_##name (5);			\
}						\
						\
void						\
baz_##name (type *x)				\
{						\
  *x = __imag foo_##name (5);			\
}

typedef long double ldouble_t;
typedef long long llong;

T (float, float)
T (double, double)
T (long double, ldouble_t)
T (char, char)
T (short, short)
T (int, int)
T (long, long)
T (long long, llong)
#undef T

int
main (void)
{
#define T(type, name) \
  {						\
    type var = 0;				\
    bar_##name (&var);				\
    if (var != 6)				\
      abort ();					\
    var = 0;					\
    baz_##name (&var);				\
    if (var != 4)				\
      abort ();					\
  }
  T (float, float)
  T (double, double)
  T (long double, ldouble_t)
  T (char, char)
  T (short, short)
  T (int, int)
  T (long, long)
  T (long long, llong)
  return 0;
}
// source: 20050124-1.c
/* PR rtl-optimization/19579 */

extern void abort (void);

int
foo (int i, int j)
{
  int k = i + 1;

  if (j)
    {
      if (k > 0)
	k++;
      else if (k < 0)
	k--;
    }

  return k;
}

int
main (void)
{
  if (foo (-2, 0) != -1)
    abort ();
  if (foo (-1, 0) != 0)
    abort ();
  if (foo (0, 0) != 1)
    abort ();
  if (foo (1, 0) != 2)
    abort ();
  if (foo (-2, 1) != -2)
    abort ();
  if (foo (-1, 1) != 0)
    abort ();
  if (foo (0, 1) != 2)
    abort ();
  if (foo (1, 1) != 3)
    abort ();
  return 0;
}
// source: 20050125-1.c
/* Verify that the CALL sideeffect isn't optimized away.  */
/* Contributed by Greg Parker  25 Jan 2005  <gparker@apple.com> */

#include <stdlib.h>
#include <stdio.h>

struct parse {
  char *next;
  char *end;
  int error;
};

int seterr(struct parse *p, int err)
{
  p->error = err;
  return 0;
}

void bracket_empty(struct parse *p)
{
  if (((p->next < p->end) && (*p->next++) == ']')  ||  seterr(p, 7)) { }
}

int main(int argc __attribute__((unused)), char **argv __attribute__((unused)))
{
  struct parse p;
  p.next = p.end = (char *)0x12345;

  p.error = 0;
  bracket_empty(&p);
  if (p.error != 7)
    abort ();

  return 0;
}
// source: 20050131-1.c
/* Verify that we do not lose side effects on a MOD expression.  */

#include <stdlib.h>
#include <stdio.h>

int
foo (int a)
{
  int x = 0 % a++;
  return a;
}

main()
{
  if (foo (9) != 10)
    abort ();
  exit (0);
}
// source: 20050203-1.c
/* Reduced testcase extracted from Samba source code.  */

#include <stdlib.h>

static void __attribute__((__noinline__))
     foo (unsigned char *p) {
  *p = 0x81;
}

static void __attribute__((__noinline__))
     bar (int x) {
  asm ("");
}

int main() {
  unsigned char b;

  foo(&b);
  if (b & 0x80)
    {
      bar (b & 0x7f);
      exit (0);
    }
  else
    {
      bar (b & 1);
      abort ();
    }
}
// source: 20050215-1.c
/* PR middle-end/19857 */

typedef struct { char c[8]; } V
#ifdef __ELF__
  __attribute__ ((aligned (8)))
#endif
  ;
typedef __SIZE_TYPE__ size_t;
V v;
void abort (void);

int
main (void)
{
  V *w = &v;
  if (((size_t) ((float *) ((size_t) w & ~(size_t) 3)) % 8) != 0
      || ((size_t) w & 1))
    {
#ifndef __ELF__
      if (((size_t) &v & 7) == 0)
#endif
	abort ();
    }
  return 0;
}
// source: 20050218-1.c
/* PR tree-optimization/19828 */
typedef __SIZE_TYPE__ size_t;
extern size_t strlen (const char *s);
extern int strncmp (const char *s1, const char *s2, size_t n);
extern void abort (void);

const char *a[16] = { "a", "bc", "de", "fgh" };

int
foo (char *x, const char *y, size_t n)
{
  size_t i, j = 0;
  for (i = 0; i < n; i++)
    {
      if (strncmp (x + j, a[i], strlen (a[i])) != 0)
        return 2;
      j += strlen (a[i]);
      if (y)
        j += strlen (y);
    }
  return 0;
}

int
main (void)
{
  if (foo ("abcde", (const char *) 0, 3) != 0)
    abort ();
  return 0;
}
// source: 20050224-1.c
/* Origin: Mikael Pettersson <mikpe@csd.uu.se> and the Linux kernel.  */

extern void abort (void);
unsigned long a = 0xc0000000, b = 0xd0000000;
unsigned long c = 0xc01bb958, d = 0xc0264000;
unsigned long e = 0xc0288000, f = 0xc02d4378;

void
foo (int x, int y, int z)
{
  if (x != 245 || y != 36 || z != 444)
    abort ();
}

int
main (void)
{
  unsigned long g;
  int h = 0, i = 0, j = 0;

  if (sizeof (unsigned long) < 4)
    return 0;

  for (g = a; g < b; g += 0x1000)
    if (g < c)
      h++;
    else if (g >= d && g < e)
      j++;
    else if (g < f)
      i++;
  foo (i, j, h);
  return 0;
}
// source: 20050316-1.c
/* PR rtl-optimization/16104 */
/* { dg-require-effective-target int32plus } */
/* { dg-options "-Wno-psabi" } */

extern void abort (void);

typedef int V2SI __attribute__ ((vector_size (8)));
typedef unsigned int V2USI __attribute__ ((vector_size (8)));
typedef short V2HI __attribute__ ((vector_size (4)));
typedef unsigned int V2UHI __attribute__ ((vector_size (4)));

int
test1 (void)
{
  return (long long) (V2SI) 0LL;
}

int
test2 (V2SI x)
{
  return (long long) x;
}

V2SI
test3 (void)
{
  return (V2SI) (long long) (int) (V2HI) 0;
}

V2SI
test4 (V2HI x)
{
  return (V2SI) (long long) (int) x;
}

V2SI
test5 (V2USI x)
{
  return (V2SI) x;
}

int
main (void)
{
  if (sizeof (short) != 2 || sizeof (int) != 4 || sizeof (long long) != 8)
    return 0;

  if (test1 () != 0)
    abort ();

  V2SI x = { 2, 2 };
  if (test2 (x) != 2)
    abort ();

  union { V2SI x; int y[2]; V2USI z; long long l; } u;
  u.x = test3 ();
  if (u.y[0] != 0 || u.y[1] != 0)
    abort ();

  V2HI y = { 4, 4 };
  union { V2SI x; long long y; } v;
  v.x = test4 (y);
  if (v.y != 0x40004)
    abort ();

  V2USI z = { 6, 6 };
  u.x = test5 (z);
  if (u.y[0] != 6 || u.y[1] != 6)
    abort ();
  return 0;
}
// source: 20050316-2.c
/* This testcase generates MMX instructions together with x87 instructions.
   Currently, there is no "emms" generated to switch between register sets,
   so the testcase fails for targets where MMX insns are enabled.  */
/* { dg-options "-mno-mmx -Wno-psabi" { target { x86_64-*-* i?86-*-* } } } */

extern void abort (void);

typedef int V2SI __attribute__ ((vector_size (8)));
typedef unsigned int V2USI __attribute__ ((vector_size (8)));
typedef float V2SF __attribute__ ((vector_size (8)));
typedef short V2HI __attribute__ ((vector_size (4)));
typedef unsigned int V2UHI __attribute__ ((vector_size (4)));

long long
test1 (V2SF x)
{
  return (long long) (V2SI) x;
}

long long
test2 (V2SF x)
{
  return (long long) x;
}

long long
test3 (V2SI x)
{
  return (long long) (V2SF) x;
}

int
main (void)
{
  if (sizeof (short) != 2 || sizeof (int) != 4 || sizeof (long long) != 8)
    return 0;

  V2SF x = { 2.0, 2.0 };
  union { long long l; float f[2]; int i[2]; } u;
  u.l = test1 (x);
  if (u.f[0] != 2.0 || u.f[1] != 2.0)
    abort ();

  V2SF y = { 6.0, 6.0 };
  u.l = test2 (y);
  if (u.f[0] != 6.0 || u.f[1] != 6.0)
    abort ();

  V2SI z = { 4, 4 };
  u.l = test3 (z);
  if (u.i[0] != 4 || u.i[1] != 4)
    abort ();
  return 0;
}
// source: 20050316-3.c
/* { dg-options "-Wno-psabi" } */
extern void abort (void);

typedef int V2SI __attribute__ ((vector_size (8)));
typedef unsigned int V2USI __attribute__ ((vector_size (8)));
typedef short V2HI __attribute__ ((vector_size (4)));
typedef unsigned int V2UHI __attribute__ ((vector_size (4)));

V2USI
test1 (V2SI x)
{
  return (V2USI) (V2SI) (long long) x;
}

long long
test2 (V2SI x)
{
  return (long long) (V2USI) (V2SI) (long long) x;
}

int
main (void)
{
  if (sizeof (short) != 2 || sizeof (int) != 4 || sizeof (long long) != 8)
    return 0;

  union { V2SI x; int y[2]; V2USI z; long long l; } u;
  V2SI a = { -3, -3 };
  u.z = test1 (a);
  if (u.y[0] != -3 || u.y[1] != -3)
    abort ();

  u.l = test2 (a);
  if (u.y[0] != -3 || u.y[1] != -3)
    abort ();
  return 0;
}
// source: 20050410-1.c
int s = 200;
int __attribute__((noinline))
foo (void)
{
  return (signed char) (s - 100) - 5;
}
int
main (void)
{
  if (foo () != 95)
    abort ();
  exit (0);
}
// source: 20050502-1.c
/* PR rtl-optimization/21330 */

extern void abort (void);
extern int strcmp (const char *, const char *);

int
__attribute__((noinline))
bar (const char **x)
{
  return *(*x)++;
}

int
__attribute__((noinline))
baz (int c)
{
  return c != '@';
}

void
__attribute__((noinline))
foo (const char **w, char *x, _Bool y, _Bool z)
{
  char c = bar (w);
  int i = 0;

  while (1)
    {
      x[i++] = c;
      c = bar (w);
      if (y && c == '\'')
        break;
      if (z && c == '\"')
        break;
      if (!y && !z && !baz (c))
        break;
    }
   x[i] = 0;
}

int
main (void)
{
  char buf[64];
  const char *p;
  p = "abcde'fgh";
  foo (&p, buf, 1, 0);
  if (strcmp (p, "fgh") != 0 || strcmp (buf, "abcde") != 0)
    abort ();
  p = "ABCDEFG\"HI";
  foo (&p, buf, 0, 1);
  if (strcmp (p, "HI") != 0 || strcmp (buf, "ABCDEFG") != 0)
    abort ();
  p = "abcd\"e'fgh";
  foo (&p, buf, 1, 1);
  if (strcmp (p, "e'fgh") != 0 || strcmp (buf, "abcd") != 0)
    abort ();
  p = "ABCDEF'G\"HI";
  foo (&p, buf, 1, 1);
  if (strcmp (p, "G\"HI") != 0 || strcmp (buf, "ABCDEF") != 0)
    abort ();
  p = "abcdef@gh";
  foo (&p, buf, 0, 0);
  if (strcmp (p, "gh") != 0 || strcmp (buf, "abcdef") != 0)
    abort ();
  return 0;
}
// source: 20050502-2.c
/* PR target/21297 */
typedef __SIZE_TYPE__ size_t;
extern int memcmp (const char *, const char *, size_t);
extern void abort ();

void
foo (char *x)
{
  int i;
  for (i = 0; i < 2; i++);
  x[i + i] = '\0';
}

void
bar (char *x)
{
  int i;
  for (i = 0; i < 2; i++);
  x[i + i + i + i] = '\0';
}

int
main (void)
{
  char x[] = "IJKLMNOPQR";
  foo (x);
  if (memcmp (x, "IJKL\0NOPQR", sizeof x) != 0)
    abort ();
  x[4] = 'M';
  bar (x);
  if (memcmp (x, "IJKLMNOP\0R", sizeof x) != 0)
    abort ();
  return 0;
}
// source: 20050604-1.c
/* PR regression/21897 */
/* This testcase generates MMX instructions together with x87 instructions.
   Currently, there is no "emms" generated to switch between register sets,
   so the testcase fails for targets where MMX insns are enabled.  */
/* { dg-options "-mno-mmx" { target { x86_64-*-* i?86-*-* } } } */

extern void abort (void);

typedef unsigned short v4hi __attribute__ ((vector_size (8)));
typedef float v4sf __attribute__ ((vector_size (16)));

union
{
  v4hi v;
  short s[4];
} u;

union
{
  v4sf v;
  float f[4];
} v;

void
foo (void)
{
  unsigned int i;
  for (i = 0; i < 2; i++)
    u.v += (v4hi) { 12, 32768 };
  for (i = 0; i < 2; i++)
    v.v += (v4sf) { 18.0, 20.0, 22 };
}

int
main (void)
{
  foo ();
  if (u.s[0] != 24 || u.s[1] != 0 || u.s[2] || u.s[3])
    abort ();
  if (v.f[0] != 36.0 || v.f[1] != 40.0 || v.f[2] != 44.0 || v.f[3] != 0.0)
    abort ();
  return 0;
}
// source: 20050607-1.c
/* PR middle-end/21850 */

extern void abort (void);

typedef int V2SI __attribute__ ((vector_size (8)));

int
main (void)
{
#if (__INT_MAX__ == 2147483647) \
    && (__LONG_LONG_MAX__ == 9223372036854775807LL)
  if (((int)(long long)(V2SI){ 2, 2 }) != 2)
    abort ();
#endif
  return 0;
}
// source: 20050613-1.c
/* PR tree-optimization/22043 */

extern void abort (void);

struct A { int i; int j; int k; int l; };
struct B { struct A a; int r[1]; };
struct C { struct A a; int r[0]; };
struct D { struct A a; int r[]; };

void
foo (struct A *x)
{
  if (x->i != 0 || x->j != 5 || x->k != 0 || x->l != 0)
    abort ();
}

int
main ()
{
  struct B b = { .a.j = 5 };
  struct C c = { .a.j = 5 };
  struct D d = { .a.j = 5 };
  foo (&b.a);
  foo (&c.a);
  foo (&d.a);
  return 0;
}
// source: 20050713-1.c
/* Test that sibling call is not used if there is an argument overlap.  */

extern void abort (void);

struct S
{
  int a, b, c;
};

int
foo2 (struct S x, struct S y)
{
  if (x.a != 3 || x.b != 4 || x.c != 5)
    abort ();
  if (y.a != 6 || y.b != 7 || y.c != 8)
    abort ();
  return 0;
}

int
foo3 (struct S x, struct S y, struct S z)
{
  foo2 (x, y);
  if (z.a != 9 || z.b != 10 || z.c != 11)
    abort ();
  return 0;
}

int
bar2 (struct S x, struct S y)
{
  return foo2 (y, x);
}

int
bar3 (struct S x, struct S y, struct S z)
{
  return foo3 (y, x, z);
}

int
baz3 (struct S x, struct S y, struct S z)
{
  return foo3 (y, z, x);
}

int
main (void)
{
  struct S a = { 3, 4, 5 }, b = { 6, 7, 8 }, c = { 9, 10, 11 };

  bar2 (b, a);
  bar3 (b, a, c);
  baz3 (c, a, b);
  return 0;
}
// source: 20050826-1.c
/* PR rtl-optimization/23561 */

struct A
{
  char a1[1];
  char a2[5];
  char a3[1];
  char a4[2048 - 7];
} a;

typedef __SIZE_TYPE__ size_t;
extern void *memset (void *, int, size_t);
extern void *memcpy (void *, const void *, size_t);
extern int memcmp (const void *, const void *, size_t);
extern void abort (void);

void
bar (struct A *x)
{
  size_t i;
  if (memcmp (x, "\1HELLO\1", sizeof "\1HELLO\1"))
    abort ();
  for (i = 0; i < sizeof (x->a4); i++)
    if (x->a4[i])
      abort ();
}

int
foo (void)
{
  memset (&a, 0, sizeof (a));
  a.a1[0] = 1;
  memcpy (a.a2, "HELLO", sizeof "HELLO");
  a.a3[0] = 1;
  bar (&a);
  return 0;
}

int
main (void)
{
  foo ();
  return 0;
}
// source: 20050826-2.c
/* PR rtl-optimization/23560 */

struct rtattr
{
  unsigned short rta_len;
  unsigned short rta_type;
};

__attribute__ ((noinline))
int inet_check_attr (void *r, struct rtattr **rta)
{
  int i;

  for (i = 1; i <= 14; i++)
    {
      struct rtattr *attr = rta[i - 1];
      if (attr)
	{
	  if (attr->rta_len - sizeof (struct rtattr) < 4)
	    return -22;
	  if (i != 9 && i != 8)
	    rta[i - 1] = attr + 1;
	}
    }
  return 0;
}

extern void abort (void);

int
main (void)
{
  struct rtattr rt[2];
  struct rtattr *rta[14];
  int i;

  rt[0].rta_len = sizeof (struct rtattr) + 8;
  rt[0].rta_type = 0;
  rt[1] = rt[0];
  for (i = 0; i < 14; i++)
    rta[i] = &rt[0];
  if (inet_check_attr (0, rta) != 0)
    abort ();
  for (i = 0; i < 14; i++)
    if (rta[i] != &rt[i != 7 && i != 8])
      abort ();
  for (i = 0; i < 14; i++)
    rta[i] = &rt[0];
  rta[1] = 0;
  rt[1].rta_len -= 8;
  rta[5] = &rt[1];
  if (inet_check_attr (0, rta) != -22)
    abort ();
  for (i = 0; i < 14; i++)
    if (i == 1 && rta[i] != 0)
      abort ();
    else if (i != 1 && i <= 5 && rta[i] != &rt[1])
      abort ();
    else if (i > 5 && rta[i] != &rt[0])
      abort ();
  return 0;
}
// source: 20050929-1.c
/* PR middle-end/24109 */

extern void abort (void);

struct A { int i; int j; };
struct B { struct A *a; struct A *b; };
struct C { struct B *c; struct A *d; };
struct C e = { &(struct B) { &(struct A) { 1, 2 }, &(struct A) { 3, 4 } }, &(struct A) { 5, 6 } };

int
main (void)
{
  if (e.c->a->i != 1 || e.c->a->j != 2)
    abort ();
  if (e.c->b->i != 3 || e.c->b->j != 4)
    abort ();
  if (e.d->i != 5 || e.d->j != 6)
    abort ();
  return 0;
}
// source: 20051012-1.c
/* { dg-require-effective-target untyped_assembly } */
extern void abort (void);

struct type
{
  int *a;

  int b:16;
  unsigned int p:9;
} t;

unsigned int
foo ()
{
  return t.p;
}

int
main (void)
{
  t.p = 8;
  if (foo (t) != 8)
    abort ();
  return 0;
}
// source: 20051021-1.c
/* Verify that TRUTH_AND_EXPR is not wrongly changed to TRUTH_ANDIF_EXPR.  */

extern void abort (void);

int count = 0;

int foo1(void)
{
  count++;
  return 0;
}

int foo2(void)
{
  count++;
  return 0;
}

int main(void)
{
  if ((foo1() == 1) & (foo2() == 1))
    abort ();

  if (count != 2)
    abort ();

  return 0;
}
// source: 20051104-1.c
/* PR rtl-optimization/23567 */

struct
{
  int len;
  char *name;
} s;

int
main (void)
{
  s.len = 0;
  s.name = "";
  if (s.name [s.len] != 0)
    s.name [s.len] = 0;
  return 0;
}
// source: 20051110-1.c
void add_unwind_adjustsp (long);
void abort (void);

unsigned char bytes[5];

void
add_unwind_adjustsp (long offset)
{
  int n;
  unsigned long o;

  o = (long) ((offset - 0x204) >> 2);

  n = 0;
  while (o)
    {
      bytes[n] = o & 0x7f;
      o >>= 7;
      if (o)
	bytes[n] |= 0x80;
      n++;
    }
}

int main(void)
{
  add_unwind_adjustsp (4132);
  if (bytes[0] != 0x88 || bytes[1] != 0x07)
    abort ();
  return 0;
}
// source: 20051110-2.c
void add_unwind_adjustsp (long);
void abort (void);

unsigned char bytes[5];

int flag;

void
add_unwind_adjustsp (long offset)
{
  int n;
  unsigned long o;

  o = (long) ((offset - 0x204) >> 2);

  n = 0;
  do
    {
a:
      bytes[n] = o & 0x7f;
      o >>= 7;
      if (o)
        {
	  bytes[n] |= 0x80;
	  if (flag)
	    goto a;
	}
      n++;
    }
  while (o);
}

int main(void)
{
  add_unwind_adjustsp (4132);
  if (bytes[0] != 0x88 || bytes[1] != 0x07)
    abort ();
  return 0;
}
// source: 20051113-1.c
extern void *malloc(__SIZE_TYPE__);
extern void *memset(void *, int, __SIZE_TYPE__);
typedef struct
{
  short a;
  unsigned short b;
  unsigned short c;
  unsigned long long Count;
  long long Count2;
} __attribute__((packed)) Struct1;

typedef struct
{
  short a;
  unsigned short b;
  unsigned short c;
  unsigned long long d;
  long long e;
  long long f;
} __attribute__((packed)) Struct2;

typedef union
{
  Struct1 a;
  Struct2 b;
} Union;

typedef struct
{
  int Count;
  Union List[0];
} __attribute__((packed)) Struct3;

unsigned long long Sum (Struct3 *instrs) __attribute__((noinline));
unsigned long long Sum (Struct3 *instrs)
{
    unsigned long long  count = 0;
    int     i;

    for (i = 0; i < instrs->Count; i++) {
        count += instrs->List[i].a.Count;
    }
    return count;
}
long long Sum2 (Struct3 *instrs) __attribute__((noinline));
long long Sum2 (Struct3 *instrs)
{
    long long  count = 0;
    int     i;

    for (i = 0; i < instrs->Count; i++) {
        count += instrs->List[i].a.Count2;
    }
    return count;
}
main() {
  Struct3 *p = malloc (sizeof (int) + 3 * sizeof(Union));
  memset(p, 0, sizeof(int) + 3*sizeof(Union));
  p->Count = 3;
  p->List[0].a.Count = 555;
  p->List[1].a.Count = 999;
  p->List[2].a.Count = 0x101010101ULL;
  p->List[0].a.Count2 = 555;
  p->List[1].a.Count2 = 999;
  p->List[2].a.Count2 = 0x101010101LL;
  if (Sum(p) != 555 + 999 + 0x101010101ULL)
    abort();
  if (Sum2(p) != 555 + 999 + 0x101010101LL)
    abort();
  return 0;
}
// source: 20051215-1.c
/* PR rtl-optimization/24899 */

extern void abort (void);

__attribute__ ((noinline)) int
foo (int x, int y, int *z)
{
  int a, b, c, d;

  a = b = 0;
  for (d = 0; d < y; d++)
    {
      if (z)
	b = d * *z;
      for (c = 0; c < x; c++)
	a += b;
    }

  return a;
}

int
main (void)
{
  if (foo (3, 2, 0) != 0)
    abort ();
  return 0;
}
// source: 20060102-1.c
extern void abort ();

int f(int x)
{
  return (x >> (sizeof (x) * __CHAR_BIT__ - 1)) ? -1 : 1;
}

volatile int one = 1;
int main (void)
{
  /* Test that the function above returns different values for
     different signs.  */
  if (f(one) == f(-one))
    abort ();
  return 0;
}
// source: 20060110-1.c
extern void abort (void);

long long
f (long long a)
{
  return (a << 32) >> 32;
}
long long a = 0x1234567876543210LL;
long long b = (0x1234567876543210LL << 32) >> 32;
int
main ()
{
  if (f (a) != b)
    abort ();
  return 0;
}
// source: 20060110-2.c
extern void abort (void);

long long
f (long long a, long long b)
{
  return ((a + b) << 32) >> 32;
}

long long a = 0x1234567876543210LL;
long long b = 0x2345678765432101LL;
long long c = ((0x1234567876543210LL + 0x2345678765432101LL) << 32) >> 32;

int
main ()
{
  if (f (a, b) != c)
    abort ();
  return 0;
}
// source: 20060127-1.c
void abort ();

void
f (long long a)
{
  if ((a & 0xffffffffLL) != 0)
    abort ();
}

long long a = 0x1234567800000000LL;

int
main ()
{
  f (a);
  return 0;
}
// source: 20060412-1.c
extern void abort (void);

struct S
{
  long o;
};

struct T
{
  long o;
  struct S m[82];
};

struct T t;

int
main ()
{
  struct S *p, *q;

  p = (struct S *) &t;
  p = &((struct T *) p)->m[0];
  q = p + 82;
  while (--q > p)
    q->o = -1;
  q->o = 0;

  if (q > p)
    abort ();
  if (q - p > 0)
    abort ();
  return 0;
}
// source: 20060420-1.c
extern void abort (void);

typedef float v4flt __attribute__ ((vector_size (16)));

void __attribute__ ((noinline)) foo (float *dst, float **src, int a, int n)
{
  int i, j;
  int z = sizeof (v4flt) / sizeof (float);
  unsigned m = sizeof (v4flt) - 1;

  for (j = 0; j < n && (((unsigned long) dst + j) & m); ++j)
    {
      float t = src[0][j];
      for (i = 1; i < a; ++i)
	t += src[i][j];
      dst[j] = t;
    }

  for (; j < (n - (4 * z - 1)); j += 4 * z)
    {
      v4flt t0 = *(v4flt *) (src[0] + j + 0 * z);
      v4flt t1 = *(v4flt *) (src[0] + j + 1 * z);
      v4flt t2 = *(v4flt *) (src[0] + j + 2 * z);
      v4flt t3 = *(v4flt *) (src[0] + j + 3 * z);
      for (i = 1; i < a; ++i)
	{
	  t0 += *(v4flt *) (src[i] + j + 0 * z);
	  t1 += *(v4flt *) (src[i] + j + 1 * z);
	  t2 += *(v4flt *) (src[i] + j + 2 * z);
	  t3 += *(v4flt *) (src[i] + j + 3 * z);
	}
      *(v4flt *) (dst + j + 0 * z) = t0;
      *(v4flt *) (dst + j + 1 * z) = t1;
      *(v4flt *) (dst + j + 2 * z) = t2;
      *(v4flt *) (dst + j + 3 * z) = t3;
    }
  for (; j < n; ++j)
    {
      float t = src[0][j];
      for (i = 1; i < a; ++i)
	t += src[i][j];
      dst[j] = t;
    }
}

float buffer[64];

int
main (void)
{
  int i;
  float *dst, *src[2];
  char *cptr;

  cptr = (char *)buffer;
  cptr += (-(long int) buffer & (16 * sizeof (float) - 1));
  dst = (float *)cptr;
  src[0] = dst + 16;
  src[1] = dst + 32;
  for (i = 0; i < 16; ++i)
    {
      src[0][i] = (float) i + 11 * (float) i;
      src[1][i] = (float) i + 12 * (float) i;
    }
  foo (dst, src, 2, 16);
  for (i = 0; i < 16; ++i)
    {
      float e = (float) i + 11 * (float) i + (float) i + 12 * (float) i;
      if (dst[i] != e)
	abort ();
    }
  return 0;
}
// source: 20060905-1.c
/* PR rtl-optimization/28386 */
/* Origin: Volker Reichelt <reichelt@gcc.gnu.org> */

extern void abort(void);

volatile char s[256][3];

char g;

static void dummy(char a)
{
  g = a;
}

static int foo(void)
{
  int i, j=0;

  for (i = 0; i < 256; i++)
    if (i >= 128 && i < 256)
      {
	dummy (s[i - 128][0]);
	++j;
      }

  return j;
}

int main(void)
{
  if (foo () != 128)
    abort ();

  return 0;
}
// source: 20060910-1.c
/* PR rtl-optimization/28636 */
/* Origin: Andreas Schwab <schwab@suse.de> */

extern void abort(void);

struct input_ty
{
  unsigned char *buffer_position;
  unsigned char *buffer_end;
};

int input_getc_complicated (struct input_ty *x) { return 0; }

int check_header (struct input_ty *deeper)
{
  unsigned len;
  for (len = 0; len < 6; len++)
    if (((deeper)->buffer_position < (deeper)->buffer_end
         ? *((deeper)->buffer_position)++
         : input_getc_complicated((deeper))) < 0)
      return 0;
  return 1;
}

struct input_ty s;
unsigned char b[6];

int main (void)
{
  s.buffer_position = b;
  s.buffer_end = b + sizeof b;
  if (!check_header(&s))
    abort();
  if (s.buffer_position != s.buffer_end)
    abort();
  return 0;
}
// source: 20060929-1.c
/* PR c/29154 */

extern void abort (void);

void
foo (int **p, int *q)
{
  *(*p++)++ = *q++;
}

void
bar (int **p, int *q)
{
  **p = *q++;
  *(*p++)++;
}

void
baz (int **p, int *q)
{
  **p = *q++;
  (*p++)++;
}

int
main (void)
{
  int i = 42, j = 0;
  int *p = &i;
  foo (&p, &j);
  if (p - 1 != &i || j != 0 || i != 0)
    abort ();
  i = 43;
  p = &i;
  bar (&p, &j);
  if (p - 1 != &i || j != 0 || i != 0)
    abort ();
  i = 44;
  p = &i;
  baz (&p, &j);
  if (p - 1 != &i || j != 0 || i != 0)
    abort ();
  return 0;
}
// source: 20060930-1.c
/* PR rtl-optimization/28096 */
/* Origin: Jan Stein <jan@gatespacetelematics.com> */

extern void abort (void);

int bar (int, int) __attribute__((noinline));
int bar (int a, int b)
{
  if (b != 1)
    abort ();
}

void foo(int, int) __attribute__((noinline));
void foo (int e, int n)
{
  int i, bb2, bb5;

  if (e > 0)
    e = -e;

  for (i = 0; i < n; i++)
    {
      if (e >= 0)
	{
	  bb2 = 0;
	  bb5 = 0;
	}
      else
	{
	  bb5 = -e;
	  bb2 = bb5;
	}

      bar (bb5, bb2);
    }
}

int main(void)
{
  foo (1, 1);
  return 0;
}
// source: 20060930-2.c
/* PR middle-end/29272 */

extern void abort (void);

struct S { struct S *s; } s;
struct T { struct T *t; } t;

static inline void
foo (void *s)
{
  struct T *p = s;
  __builtin_memcpy (&p->t, &t.t, sizeof (t.t));
}

void *
__attribute__((noinline))
bar (void *p, struct S *q)
{
  q->s = &s;
  foo (p);
  return q->s;
}

int
main (void)
{
  t.t = &t;
  if (bar (&s, &s) != (void *) &t)
    abort ();
  return 0;
}
// source: 20061031-1.c
/* PR rtl-optimization/29631 */
/* Origin: Falk Hueffner <falk@debian.org> */

const signed char nunmap[] = { 17, -1, 1 };

__attribute__((noinline))
void ff(int i) {
    asm volatile("");
}

__attribute__((noinline))
void f(short delta)
{
    short p0 = 2, s;
    for (s = 0; s < 2; s++)
    {
        p0 += delta;
        ff(s);
        if (nunmap[p0] == 17)
            asm volatile("");
    }
}

int main(void)
{
    f(-1);
    return 0;
}
// source: 20061101-1.c
/* PR rtl-optimization/28970 */
/* Origin: Peter Bergner <bergner@vnet.ibm.com> */
/* { dg-require-effective-target int32plus } */

extern void abort (void);

int tar (int i)
{
  if (i != 36863)
    abort ();

  return -1;
}

void bug(int q, int bcount)
{
  int j = 0;
  int outgo = 0;

  while(j != -1)
    {
      outgo++;
      if (outgo > q-1)
        outgo = q-1;
      j = tar (outgo*bcount);
    }
}

int main(void)
{
  bug(5, 36863);
  return 0;
}
// source: 20061101-2.c
/* PR rtl-optimization/28970 */
/* Origin: Peter Bergner <bergner@vnet.ibm.com> */

extern void abort (void);

int tar (long i)
{
  if (i != 36863)
    abort ();

  return -1;
}

void bug(int q, long bcount)
{
  int j = 0;
  int outgo = 0;

  while(j != -1)
    {
      outgo++;
      if (outgo > q-1)
        outgo = q-1;
      j = tar (outgo*bcount);
    }
}

int main(void)
{
  bug(5, 36863);
  return 0;
}
// source: 20061220-1.c
/* PR middle-end/30262 */
/* { dg-skip-if "asm statements do not work as expected" { rl78-*-* } } */
extern void abort (void);

int
foo (void)
{
  unsigned int x = 0;

  void nested (void)
  {
    x = 254;
  }

  nested ();
  asm volatile ("" :: "r" (x));
  asm volatile ("" :: "m" (x));
  asm volatile ("" :: "mr" (x));
  asm volatile ("" : "=r" (x) : "0" (x));
  asm volatile ("" : "=m" (x) : "m" (x));
  return x;
}

int
bar (void)
{
  unsigned int x = 0;

  void nested (void)
  {
    asm volatile ("" :: "r" (x));
    asm volatile ("" :: "m" (x));
    asm volatile ("" :: "mr" (x));
    x += 4;
    asm volatile ("" : "=r" (x) : "0" (x));
    asm volatile ("" : "=m" (x) : "m" (x));
  }

  nested ();
  return x;
}

int
baz (void)
{
  unsigned int x = 0;

  void nested (void)
  {
    void nested2 (void)
    {
      asm volatile ("" :: "r" (x));
      asm volatile ("" :: "m" (x));
      asm volatile ("" :: "mr" (x));
      x += 4;
      asm volatile ("" : "=r" (x) : "0" (x));
      asm volatile ("" : "=m" (x) : "m" (x));
    }
    nested2 ();
    nested2 ();
  }

  nested ();
  return x;
}

int
main (void)
{
  if (foo () != 254 || bar () != 4 || baz () != 8)
    abort ();
  return 0;
}
// source: 20070201-1.c
/* PR middle-end/30473 */

extern int sprintf (char *, const char *, ...);
extern void abort (void);

char *
foo (char *buf, char *p)
{
  sprintf (buf, "abcde", p++);
  return p;
}

int
main (void)
{
  char buf[6];
  if (foo (buf, &buf[2]) != &buf[3])
    abort ();
  return 0;
}
// source: 20070212-1.c
struct f
{
  int i;
};

int g(int i, int c, struct f *ff, int *p)
{
  int *t;
  if (c)
   t = &i;
  else
   t = &ff->i;
  *p = 0;
  return *t;
}

extern void abort(void);

int main()
{
  struct f f;
  f.i = 1;
  if (g(5, 0, &f, &f.i) != 0)
    abort ();
  return 0;
}
// source: 20070212-2.c
int f(int k, int i1, int j1)
{
  int *f1;
  if(k)
   f1 = &i1;
  else
   f1 = &j1;
  i1 = 0;
  return *f1;
}

extern void abort (void);

int main()
{
  if (f(1, 1, 2) != 0)
    abort ();
  return 0;
}
// source: 20070212-3.c
struct foo { int i; int j; };

int bar (struct foo *k, int k2, int f, int f2)
{
  int *p, *q;
  int res;
  if (f)
    p = &k->i;
  else
    p = &k->j;
  res = *p;
  k->i = 1;
  if (f2)
    q = p;
  else
    q = &k2;
  return res + *q;
}

extern void abort (void);

int main()
{
  struct foo k;
  k.i = 0;
  k.j = 1;
  if (bar (&k, 1, 1, 1) != 1)
    abort ();
  return 0;
}
// source: 20070424-1.c
extern void abort (void);
extern void exit (int);

void do_exit (void) { exit (0); }
void do_abort (void) { abort (); }

void foo (int x, int a)
{
  if (x < a)
    goto doit;
  do_exit ();
  if (x != a)
    goto doit;

  /* else */
  do_abort ();
  return;

doit:
  do_abort ();
}

int main()
{
  foo (1, 0);
  return 0;
}
// source: 20070517-1.c
/* PR rtl-optimization/31691 */
/* Origin: Chi-Hua Chen <stephaniechc-gccbug@yahoo.com> */

extern void abort (void);

static int get_kind(int) __attribute__ ((noinline));

static int get_kind(int v)
{
  volatile int k = v;
  return k;
}

static int some_call(void) __attribute__ ((noinline));

static int some_call(void)
{
  return 0;
}

static void example (int arg)
{
  int tmp, kind = get_kind (arg);

  if (kind == 9 || kind == 10 || kind == 5)
    {
      if (some_call() == 0)
        {
          if (kind == 9 || kind == 10)
            tmp = arg;
          else
            abort();
        }
    }
}

int main(void)
{
  example(10);
  return 0;
}
// source: 20070614-1.c
extern void abort (void);

_Complex v = 3.0 + 1.0iF;

void
foo (_Complex z, int *x)
{
  if (z != v)
    abort ();
}

_Complex bar (_Complex z) __attribute__ ((pure));
_Complex
bar (_Complex z)
{
  return v;
}

int
baz (void)
{
  int a, i;
  for (i = 0; i < 6; i++)
    foo (bar (1.0iF * i), &a);
  return 0;
}

int
main ()
{
  baz ();
  return 0;
}
// source: 20070623-1.c
#include <limits.h>

int __attribute__((noinline)) nge(int a, int b) {return -(a >= b);}
int __attribute__((noinline)) ngt(int a, int b) {return -(a > b);}
int __attribute__((noinline)) nle(int a, int b) {return -(a <= b);}
int __attribute__((noinline)) nlt(int a, int b) {return -(a < b);}
int __attribute__((noinline)) neq(int a, int b) {return -(a == b);}
int __attribute__((noinline)) nne(int a, int b) {return -(a != b);}
int __attribute__((noinline)) ngeu(unsigned a, unsigned b) {return -(a >= b);}
int __attribute__((noinline)) ngtu(unsigned a, unsigned b) {return -(a > b);}
int __attribute__((noinline)) nleu(unsigned a, unsigned b) {return -(a <= b);}
int __attribute__((noinline)) nltu(unsigned a, unsigned b) {return -(a < b);}


int main()
{
  if (nge(INT_MIN, INT_MAX) !=  0) abort();
  if (nge(INT_MAX, INT_MIN) != -1) abort();
  if (ngt(INT_MIN, INT_MAX) !=  0) abort();
  if (ngt(INT_MAX, INT_MIN) != -1) abort();
  if (nle(INT_MIN, INT_MAX) != -1) abort();
  if (nle(INT_MAX, INT_MIN) !=  0) abort();
  if (nlt(INT_MIN, INT_MAX) != -1) abort();
  if (nlt(INT_MAX, INT_MIN) !=  0) abort();

  if (neq(INT_MIN, INT_MAX) !=  0) abort();
  if (neq(INT_MAX, INT_MIN) !=  0) abort();
  if (nne(INT_MIN, INT_MAX) != -1) abort();
  if (nne(INT_MAX, INT_MIN) != -1) abort();

  if (ngeu(0, ~0U) !=  0) abort();
  if (ngeu(~0U, 0) != -1) abort();
  if (ngtu(0, ~0U) !=  0) abort();
  if (ngtu(~0U, 0) != -1) abort();
  if (nleu(0, ~0U) != -1) abort();
  if (nleu(~0U, 0) !=  0) abort();
  if (nltu(0, ~0U) != -1) abort();
  if (nltu(~0U, 0) !=  0) abort();

  exit(0);
}
// source: 20070724-1.c
void abort (void);

static unsigned char magic[] = "\235";
static unsigned char value = '\235';

int main()
{
  if (value != magic[0])
    abort ();
  return 0;
}
// source: 20070824-1.c
/* PR tree-optimization/33136 */
/* { dg-require-effective-target alloca } */

extern void abort (void);

struct S
{
  struct S *a;
  int b;
};

int
main (void)
{
  struct S *s = (struct S *) 0, **p, *n;
  for (p = &s; *p; p = &(*p)->a);
  n = (struct S *) __builtin_alloca (sizeof (*n));
  n->a = *p;
  n->b = 1;
  *p = n;

  if (!s)
    abort ();
  return 0;
}
// source: 20070919-1.c
/* PR c/33238 */
/* { dg-require-effective-target alloca } */

typedef __SIZE_TYPE__ size_t;
int memcmp (const void *, const void *, size_t);
void abort (void);

void
__attribute__((noinline))
bar (void *x, void *y)
{
  struct S { char w[8]; } *p = x, *q = y;
  if (memcmp (p->w, "zyxwvut", 8) != 0)
    abort ();
  if (memcmp (q[0].w, "abcdefg", 8) != 0)
    abort ();
  if (memcmp (q[1].w, "ABCDEFG", 8) != 0)
    abort ();
  if (memcmp (q[2].w, "zyxwvut", 8) != 0)
    abort ();
  if (memcmp (q[3].w, "zyxwvut", 8) != 0)
    abort ();
}

void
__attribute__((noinline))
foo (void *x, int y)
{
  struct S { char w[y]; } *p = x, a;
  int i;
  a = ({ struct S b; b = p[2]; p[3] = b; });
  bar (&a, x);
}

int
main (void)
{
  struct S { char w[8]; } p[4]
    = { "abcdefg", "ABCDEFG", "zyxwvut", "ZYXWVUT" };
  foo (p, 8);
  return 0;
}
// source: 20071011-1.c
extern void abort(void);
void foo(int *p)
{
  int x;
  int y;
  x = *p;
  *p = 0;
  y = *p;
  if (x != y)
    return;
  abort ();
}

int main()
{
  int a = 1;
  foo(&a);
  return 0;
}
// source: 20071018-1.c
extern void abort(void);

struct foo {
  int rank;
  char *name;
};

struct mem {
  struct foo *x[4];
};

void __attribute__((noinline)) bar(struct foo **f)
{
  *f = __builtin_malloc(sizeof(struct foo));
}
struct foo * __attribute__((noinline, noclone)) foo(int rank)
{
  void *x = __builtin_malloc(sizeof(struct mem));
  struct mem *as = x;
  struct foo **upper = &as->x[rank * 8 - 5];
  *upper = 0;
  bar(upper);
  return *upper;
}

int main()
{
  if (foo(1) == 0)
    abort ();
  return 0;
}
// source: 20071029-1.c
extern void exit (int);
extern void abort (void);

typedef union
{
  struct
  {
    int f1, f2, f3, f4, f5, f6, f7, f8;
    long int f9, f10;
    int f11;
  } f;
  char s[56];
  long int a;
} T;

__attribute__((noinline))
void
test (T *t)
{
  static int i = 11;
  if (t->f.f1 != i++)
    abort ();
  if (t->f.f2 || t->f.f3 || t->f.f4 || t->f.f5 || t->f.f6
      || t->f.f7 || t->f.f8 || t->f.f9 || t->f.f10 || t->f.f11)
    abort ();
  if (i == 20)
    exit (0);
}

__attribute__((noinline))
void
foo (int i)
{
  T t;
again:
  t = (T) { { ++i, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
  test (&t);
  goto again;
}

int
main (void)
{
  T *t1, *t2;
  int cnt = 0;
  t1 = (T *) 0;
loop:
  t2 = t1;
  t1 = & (T) { .f.f9 = cnt++ };
  if (cnt < 3)
    goto loop;
  if (t1 != t2 || t1->f.f9 != 2)
    abort ();
  foo (10);
  return 0;
}
// source: 20071030-1.c
/* PR target/11044 */
/* Originator: Tim McGrath <misty-@charter.net> */
/* Testcase contributed by Eric Botcazou <ebotcazou@libertysurf.fr> */

/* Testcase copied from gcc.target/i386/loop-3.c */

extern void *memset (void *, int, __SIZE_TYPE__);
extern void abort (void);

typedef struct
{
        unsigned char colormod;
} entity_state_t;

typedef struct
{
        int num_entities;
        entity_state_t *entities;
} packet_entities_t;

typedef struct
{
        double senttime;
        float ping_time;
        packet_entities_t entities;
} client_frame_t;

typedef enum
{
        cs_free,
        cs_server,
        cs_zombie,
        cs_connected,
        cs_spawned
} sv_client_state_t;

typedef struct client_s
{
        sv_client_state_t state;
        int ping;
        client_frame_t frames[64];
} client_t;

int CalcPing (client_t *cl)
{
        float ping;
        int count, i;
        register client_frame_t *frame;

        if (cl->state == cs_server)
                return cl->ping;
        ping = 0;
        count = 0;
        for (frame = cl->frames, i = 0; i < 64; i++, frame++) {
                if (frame->ping_time > 0) {
                        ping += frame->ping_time;
                        count++;
                }
        }
        if (!count)
                return 9999;
        ping /= count;

        return ping * 1000;
}

int main(void)
{
   client_t cl;

   memset(&cl, 0, sizeof(cl));

   cl.frames[0].ping_time = 1.0f;

   if (CalcPing(&cl) != 1000)
     abort();

   return 0;
}
// source: 20071108-1.c
/* PR tree-optimization/32575 */

extern void abort (void);

struct S
{
  void *s1, *s2;
  unsigned char s3, s4, s5;
};

__attribute__ ((noinline))
void *
foo (void)
{
  static struct S s;
  return &s;
}

__attribute__ ((noinline))
void *
bar ()
{
  return (void *) 0;
}

__attribute__ ((noinline))
struct S *
test (void *a, void *b)
{
  struct S *p, q;
  p = foo ();
  if (p == 0)
    {
      p = &q;
      __builtin_memset (p, 0, sizeof (*p));
    }
  p->s1 = a;
  p->s2 = b;
  if (p == &q)
    p = 0;
  return p;
}

int
main (void)
{
  int a;
  int b;
  struct S *z = test ((void *) &a, (void *) &b);
  if (z == 0 || z->s1 != (void *) &a || z->s2 != (void *) &b || z->s3 || z->s4)
    abort ();
  return 0;
}
// source: 20071120-1.c
extern void abort (void);

void __attribute__((noinline,noreturn))
vec_assert_fail (void)
{
    abort ();
}

struct ggc_root_tab {
    void *base;
};

typedef struct deferred_access_check {} VEC_deferred_access_check_gc;

typedef struct deferred_access {
    VEC_deferred_access_check_gc* deferred_access_checks;
    int deferring_access_checks_kind;
} deferred_access;

typedef struct VEC_deferred_access_base {
    unsigned num;
    deferred_access vec[1];
} VEC_deferred_access_base;

static __inline__ deferred_access *
VEC_deferred_access_base_last (VEC_deferred_access_base *vec_)
{
    (void)((vec_ && vec_->num) ? 0 : (vec_assert_fail (), 0));
    return &vec_->vec[vec_->num - 1];
}

static __inline__  void
VEC_deferred_access_base_pop (VEC_deferred_access_base *vec_)
{
    (void)((vec_->num) ? 0 : (vec_assert_fail (), 0));
    --vec_->num;
}

void __attribute__((noinline))
perform_access_checks (VEC_deferred_access_check_gc* p)
{
    abort ();
}

typedef struct VEC_deferred_access_gc {
    VEC_deferred_access_base base;
} VEC_deferred_access_gc;

static VEC_deferred_access_gc *deferred_access_stack;
static unsigned deferred_access_no_check;

const struct ggc_root_tab gt_pch_rs_gt_cp_semantics_h[] = {
    {
	&deferred_access_no_check
    }
};

void __attribute__((noinline)) pop_to_parent_deferring_access_checks (void)
{
    if (deferred_access_no_check)
	deferred_access_no_check--;
    else
    {
        VEC_deferred_access_check_gc *checks;
        deferred_access *ptr;
	checks = (VEC_deferred_access_base_last(deferred_access_stack ? &deferred_access_stack->base : 0))->deferred_access_checks;
        VEC_deferred_access_base_pop(deferred_access_stack ? &deferred_access_stack->base : 0);
        ptr = VEC_deferred_access_base_last(deferred_access_stack ? &deferred_access_stack->base : 0);
        if (ptr->deferring_access_checks_kind == 0)
	    perform_access_checks (checks);
    }
}

int main()
{
    deferred_access_stack = __builtin_malloc (sizeof(VEC_deferred_access_gc) + sizeof(deferred_access) * 8);
    deferred_access_stack->base.num = 2;
    deferred_access_stack->base.vec[0].deferring_access_checks_kind = 1;
    pop_to_parent_deferring_access_checks ();
    return 0;
}
// source: 20071202-1.c
extern void abort (void);
struct T { int t; int r[8]; };
struct S { int a; int b; int c[6]; struct T d; };

__attribute__((noinline)) void
foo (struct S *s)
{
  *s = (struct S) { s->b, s->a, { 0, 0, 0, 0, 0, 0 }, s->d };
}

int
main (void)
{
  struct S s = { 6, 12, { 1, 2, 3, 4, 5, 6 },
		 { 7, { 8, 9, 10, 11, 12, 13, 14, 15 } } };
  foo (&s);
  if (s.a != 12 || s.b != 6
      || s.c[0] || s.c[1] || s.c[2] || s.c[3] || s.c[4] || s.c[5])
    abort ();
  if (s.d.t != 7 || s.d.r[0] != 8 || s.d.r[1] != 9 || s.d.r[2] != 10
      || s.d.r[3] != 11 || s.d.r[4] != 12 || s.d.r[5] != 13
      || s.d.r[6] != 14 || s.d.r[7] != 15)
    abort ();
  return 0;
}
// source: 20071205-1.c
/* PR middle-end/34337 */

extern void abort (void);

int
foo (int x)
{
  return ((x << 8) & 65535) | 255;
}

int
main (void)
{
  if (foo (0x32) != 0x32ff || foo (0x174) != 0x74ff)
    abort ();
  return 0;
}
// source: 20071210-1.c
/* PR rtl-optimization/34302 */
/* { dg-require-effective-target label_values } */
/* { dg-require-effective-target indirect_jumps } */

extern void abort (void);

struct S
{
  int n1, n2, n3, n4;
};

__attribute__((noinline)) struct S
foo (int x, int y, int z)
{
  if (x != 10 || y != 9 || z != 8)
    abort ();
  struct S s = { 1, 2, 3, 4 };
  return s;
}

__attribute__((noinline)) void **
bar (void **u, int *v)
{
  void **w = u;
  int *s = v, x, y, z;
  void **p, **q;
  static void *l[] = { &&lab1, &&lab1, &&lab2, &&lab3, &&lab4 };

  if (!u)
    return l;

  q = *w++;
  goto *q;
lab2:
  p = q;
  q = *w++;
  x = s[2];
  y = s[1];
  z = s[0];
  s -= 1;
  struct S r = foo (x, y, z);
  s[3] = r.n1;
  s[2] = r.n2;
  s[1] = r.n3;
  s[0] = r.n4;
  goto *q;
lab3:
  p = q;
  q = *w++;
  s += 1;
  s[0] = 23;
lab1:
  goto *q;
lab4:
  return 0;
}

int
main (void)
{
  void **u = bar ((void **) 0, (int *) 0);
  void *t[] = { u[2], u[4] };
  int s[] = { 7, 8, 9, 10, 11, 12 };
  if (bar (t, &s[1]) != (void **) 0
      || s[0] != 4 || s[1] != 3 || s[2] != 2 || s[3] != 1
      || s[4] != 11 || s[5] != 12)
    abort ();
  return 0;
}
// source: 20071211-1.c
extern void abort() __attribute__ ((noreturn));

struct s
{
  unsigned long long f1 : 40;
#if(__SIZEOF_INT__ >= 4)
  unsigned int f2 : 24;
#else
  unsigned long int f2 : 24;
#endif
} sv;

int main()
{
  int f2;
  sv.f2 = (1 << 24) - 1;
  __asm__ volatile ("" : : : "memory");
  ++sv.f2;
  f2 = sv.f2;
  if (f2 != 0)
    abort();
  return 0;
}
// source: 20071213-1.c
/* PR target/34281 */

#include <stdarg.h>

extern void abort (void);

void
h (int x, va_list ap)
{
  switch (x)
    {
    case 1:
      if (va_arg (ap, int) != 3 || va_arg (ap, int) != 4)
	abort ();
      return;
    case 5:
      if (va_arg (ap, int) != 9 || va_arg (ap, int) != 10)
	abort ();
      return;
    default:
      abort ();
    }
}

void
f1 (int i, long long int j, ...)
{
  va_list ap;
  va_start (ap, j);
  h (i, ap);
  if (i != 1 || j != 2)
    abort ();
  va_end (ap);
}

void
f2 (int i, int j, int k, long long int l, ...)
{
  va_list ap;
  va_start (ap, l);
  h (i, ap);
  if (i != 5 || j != 6 || k != 7 || l != 8)
    abort ();
  va_end (ap);
}

int
main ()
{
  f1 (1, 2, 3, 4);
  f2 (5, 6, 7, 8, 9, 10);
  return 0;
}
// source: 20071216-1.c
/* PR rtl-optimization/34490 */

extern void abort (void);

static int x;

int
__attribute__((noinline))
bar (void)
{
  return x;
}

int
foo (void)
{
  long int b = bar ();
  if ((unsigned long) b < -4095L)
    return b;
  if (-b != 38)
    b = -2;
  return b + 1;
}

int
main (void)
{
  x = 26;
  if (foo () != 26)
    abort ();
  x = -39;
  if (foo () != -1)
    abort ();
  x = -38;
  if (foo () != -37)
    abort ();
  return 0;
}
// source: 20071219-1.c
/* PR c++/34459 */

extern void abort (void);
extern void *memset (void *s, int c, __SIZE_TYPE__ n);

struct S
{
  char s[25];
};

struct S *p;

void __attribute__((noinline,noclone))
foo (struct S *x, int set)
{
  int i;
  for (i = 0; i < sizeof (x->s); ++i)
    if (x->s[i] != 0)
      abort ();
    else if (set)
      x->s[i] = set;
  p = x;
}

void __attribute__((noinline,noclone))
test1 (void)
{
  struct S a;
  memset (&a.s, '\0', sizeof (a.s));
  foo (&a, 0);
  struct S b = a;
  foo (&b, 1);
  b = a;
  b = b;
  foo (&b, 0);
}

void __attribute__((noinline,noclone))
test2 (void)
{
  struct S a;
  memset (&a.s, '\0', sizeof (a.s));
  foo (&a, 0);
  struct S b = a;
  foo (&b, 1);
  b = a;
  b = *p;
  foo (&b, 0);
}

void __attribute__((noinline,noclone))
test3 (void)
{
  struct S a;
  memset (&a.s, '\0', sizeof (a.s));
  foo (&a, 0);
  struct S b = a;
  foo (&b, 1);
  *p = a;
  *p = b;
  foo (&b, 0);
}

int
main (void)
{
  test1 ();
  test2 ();
  test3 ();
  return 0;
}
// source: 20071220-1.c
/* PR tree-optimization/29484 */
/* { dg-require-effective-target label_values } */
/* { dg-require-effective-target indirect_jumps } */

extern void abort (void);

void *__attribute__((noinline))
baz (void **lab)
{
  asm volatile ("" : "+r" (lab));
  return *lab;
}

static inline
int bar (void)
{
  static void *b[] = { &&addr };
  void *p = baz (b);
  goto *p;
addr:
  return 17;
}

int __attribute__((noinline))
f1 (void)
{
  return bar ();
}

int __attribute__((noinline))
f2 (void)
{
  return bar ();
}

int
main (void)
{
  if (f1 () != 17 || f1 () != 17 || f2 () != 17 || f2 () != 17)
    abort ();
  return 0;
}
// source: 20071220-2.c
/* PR tree-optimization/29484 */
/* { dg-require-effective-target label_values } */

extern void abort (void);

void *__attribute__((noinline))
baz (void **lab)
{
  asm volatile ("" : "+r" (lab));
  return *lab;
}

static inline
int bar (void)
{
  static void *b[] = { &&addr };
  baz (b);
addr:
  return 17;
}

int __attribute__((noinline))
f1 (void)
{
  return bar ();
}

int __attribute__((noinline))
f2 (void)
{
  return bar ();
}

int
main (void)
{
  if (f1 () != 17 || f1 () != 17 || f2 () != 17 || f2 () != 17)
    abort ();
  return 0;
}
// source: 20080117-1.c
typedef struct gs_imager_state_s {
  struct {
    int half_width;
    int cap;
    float miter_limit;
  } line_params;
} gs_imager_state;
static const gs_imager_state gstate_initial = { { 1 } };
void gstate_path_memory(gs_imager_state *pgs) {
  *pgs = gstate_initial;
}
int gs_state_update_overprint(void)
{
  return gstate_initial.line_params.half_width;
}

extern void abort (void);
int main()
{
  if (gs_state_update_overprint() != 1)
    abort ();
  return 0;
}
// source: 20080122-1.c
/* PR rtl-optimization/34628 */
/* Origin: Martin Michlmayr <tbm@cyrius.com> */

typedef unsigned short u16;
typedef unsigned char u8;

static void
do_segfault(u8 in_buf[], const u8 out_buf[], const int len)
{
  int i;

  for (i = 0; i < len; i++) {
    asm("");

    in_buf[2*i] = (   out_buf[2*i] | out_buf[(2*i)+1]<<8  ) & 0xFF;

    asm("");

    in_buf[(2*i)+1] =  ( out_buf[2*i] | out_buf[(2*i)+1]<<8 ) >> 8;

    asm("");
  }
}

int main(int argc, char *argv[])
{
  u8 outbuf[32] = "buffer     ";
  u8 inbuf[32] = "\f";

  asm("");
  do_segfault(inbuf, outbuf, 12);
  asm("");

  return 0;
}
// source: 20080222-1.c
extern void abort (void);

struct container
{
  unsigned char data[1];
};

unsigned char space[6] = {1, 2, 3, 4, 5, 6};

int
foo (struct container *p)
{
  return p->data[4];
}

int
main ()
{
  if (foo ((struct container *) space) != 5)
    abort ();
  return 0;
}
// source: 20080408-1.c
extern void abort (void);
int main ()
{
  short ssi = 126;
  unsigned short usi = 65280;
  int fail = !(ssi < usi);
  if (fail)
    abort ();
  return 0;
}
// source: 20080424-1.c
/* PR tree-optimization/36008 */

extern void abort (void);

int g[48][3][3];

void __attribute__ ((noinline))
bar (int x[3][3], int y[3][3])
{
  static int i;
  if (x != g[i + 8] || y != g[i++])
    abort ();
}

static inline void __attribute__ ((always_inline))
foo (int x[][3][3])
{
  int i;
  for (i = 0; i < 8; i++)
    {
      int k = i + 8;
      bar (x[k], x[k - 8]);
    }
}

int
main ()
{
  foo (g);
  return 0;
}
// source: 20080502-1.c
/* PR target/36090 */

extern void abort (void);

long double __attribute__ ((noinline)) foo (long double x)
{
  return __builtin_signbit (x) ? 3.1415926535897932384626433832795029L : 0.0;
}

int
main (void)
{
  if (foo (-1.0L) != 3.1415926535897932384626433832795029L)
    abort ();
  return 0;
}
// source: 20080506-1.c
/* PR middle-end/36137 */
extern void abort (void);

#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))

int
main ()
{
  unsigned int u;
  int i = -1;

  u = MAX ((unsigned int) MAX (i, 0), 1);
  if (u != 1)
    abort ();

  u = MIN ((unsigned int) MAX (i, 0), (unsigned int) i);
  if (u != 0)
    abort ();
  return 0;
}
// source: 20080506-2.c
/* PR middle-end/36013 */

extern void abort (void);

void __attribute__((noinline))
foo (int **__restrict p, int **__restrict q)
{
  *p[0] = 1;
  *q[0] = 2;
  if (*p[0] != 2)
    abort ();
}

int
main (void)
{
  int a;
  int *p1 = &a, *p2 = &a;
  foo (&p1, &p2);
  return 0;
}
// source: 20080519-1.c
extern void abort (void);

typedef unsigned long HARD_REG_SET[2];
HARD_REG_SET reg_class_contents[2];

struct du_chain
{
  struct du_chain *next_use;
  int cl;
};

void __attribute__((noinline))
merge_overlapping_regs (HARD_REG_SET *p)
{
  if ((*p)[0] != -1 || (*p)[1] != -1)
    abort ();
}

void __attribute__((noinline))
regrename_optimize (struct du_chain *this)
{
  HARD_REG_SET this_unavailable;
  unsigned long *scan_fp_;
  int n_uses;
  struct du_chain *last;

  this_unavailable[0] = 0;
  this_unavailable[1] = 0;

  n_uses = 0;
  for (last = this; last->next_use; last = last->next_use)
    {
      scan_fp_ = reg_class_contents[last->cl];
      n_uses++;
      this_unavailable[0] |= ~ scan_fp_[0];
      this_unavailable[1] |= ~ scan_fp_[1];
    }
  if (n_uses < 1)
    return;

  scan_fp_ = reg_class_contents[last->cl];
  this_unavailable[0] |= ~ scan_fp_[0];
  this_unavailable[1] |= ~ scan_fp_[1];

  merge_overlapping_regs (&this_unavailable);
}

int main()
{
  struct du_chain du1 = { 0, 0 };
  struct du_chain du0 = { &du1, 1 };
  reg_class_contents[0][0] = -1;
  reg_class_contents[0][1] = -1;
  reg_class_contents[1][0] = 0;
  reg_class_contents[1][1] = 0;
  regrename_optimize (&du0);
  return 0;
}
// source: 20080522-1.c
/* This testcase is to make sure we have i in referenced vars and that we
   properly compute aliasing for the loads and stores.  */

extern void abort (void);

static int i;
static int *p = &i;

int __attribute__((noinline))
foo(int *q)
{
  *p = 1;
  *q = 2;
  return *p;
}

int __attribute__((noinline))
bar(int *q)
{
  *q = 2;
  *p = 1;
  return *q;
}

int main()
{
  int j = 0;

  if (foo(&i) != 2)
    abort ();
  if (bar(&i) != 1)
    abort ();
  if (foo(&j) != 1)
    abort ();
  if (j != 2)
    abort ();
  if (bar(&j) != 2)
    abort ();
  if (j != 2)
    abort ();

  return 0;
}
// source: 20080529-1.c
/* PR target/36362 */

extern void abort (void);

int
test (float c)
{
  return !!c * 7LL == 0;
}

int
main (void)
{
  if (test (1.0f) != 0)
    abort ();
  return 0;
}
// source: 20080604-1.c
struct barstruct { char const* some_string; } x;
extern void abort (void);
void __attribute__((noinline))
foo(void)
{
  if (!x.some_string)
    abort ();
}
void baz(int b)
{
  struct barstruct bar;
  struct barstruct* barptr;
  if (b)
    barptr = &bar;
  else
    {
      barptr = &x + 1;
      barptr = barptr - 1;
    }
  barptr->some_string = "Everything OK";
  foo();
  barptr->some_string = "Everything OK";
}
int main()
{
  x.some_string = (void *)0;
  baz(0);
  if (!x.some_string)
    abort ();
  return 0;
}
// source: 20080719-1.c
typedef unsigned int u32;

static const u32 deadfish = 0xdeadf155;

static const u32 cfb_tab8_be[] = {
    0x00000000,0x000000ff,0x0000ff00,0x0000ffff,
    0x00ff0000,0x00ff00ff,0x00ffff00,0x00ffffff,
    0xff000000,0xff0000ff,0xff00ff00,0xff00ffff,
    0xffff0000,0xffff00ff,0xffffff00,0xffffffff
};

static const u32 cfb_tab8_le[] = {
    0x00000000,0xff000000,0x00ff0000,0xffff0000,
    0x0000ff00,0xff00ff00,0x00ffff00,0xffffff00,
    0x000000ff,0xff0000ff,0x00ff00ff,0xffff00ff,
    0x0000ffff,0xff00ffff,0x00ffffff,0xffffffff
};

static const u32 cfb_tab16_be[] = {
    0x00000000, 0x0000ffff, 0xffff0000, 0xffffffff
};

static const u32 cfb_tab16_le[] = {
    0x00000000, 0xffff0000, 0x0000ffff, 0xffffffff
};

static const u32 cfb_tab32[] = {
 0x00000000, 0xffffffff
};






const u32 *xxx(int bpp)
{
 const u32 *tab;

if (0) return &deadfish;

 switch (bpp) {
 case 8:
  tab = cfb_tab8_be;
  break;
 case 16:
  tab = cfb_tab16_be;
  break;
 case 32:
 default:
  tab = cfb_tab32;
  break;
 }

 return tab;
}

int main(void)
{
  const u32 *a = xxx(8);
  int b = a[0];
  if (b != cfb_tab8_be[0])
    __builtin_abort ();
  return 0;
}
// source: 20080813-1.c
/* PR middle-end/37103 */

extern void abort (void);

void
foo (unsigned short x)
{
  signed char y = -1;
  if (x == y)
    abort ();
}

void
bar (unsigned short x)
{
  unsigned char y = -1;
  if (x == y)
    abort ();
}

int
main (void)
{
  if (sizeof (int) == sizeof (short))
    return 0;
  foo (-1);
  if (sizeof (short) > 1)
    bar (-1);
  return 0;
}
// source: 20081103-1.c
struct S { char c; char arr[4]; float f; };

char A[4] = { '1', '2', '3', '4' };

void foo (struct S s)
{
  if (__builtin_memcmp (s.arr, A, 4))
    __builtin_abort ();
}

int main (void)
{
  struct S s;
  __builtin_memcpy (s.arr, A, 4);
  foo (s);
  return 0;
}
// source: 20081112-1.c
#include <limits.h>

extern void abort (void);

static __attribute__((noinline)) void foo (int a)
{
  int b = (a - 1) + INT_MIN;

  if (b != INT_MIN)
    abort ();
}

int main (void)
{
  foo (1);
  return 0;
}
// source: 20081117-1.c
/* { dg-require-effective-target int32plus } */
extern void abort (void);

struct s
{
  unsigned long long a:16;
  unsigned long long b:32;
  unsigned long long c:16;
};

__attribute__ ((noinline)) unsigned
f (struct s s, unsigned i)
{
  return s.b == i;
}

struct s s = { 1, 0x87654321u, 2};

int
main ()
{
  if (!f (s, 0x87654321u))
    abort ();
  return 0;
}
// source: 20081218-1.c
struct A { int i, j; char pad[512]; } a;

int __attribute__((noinline))
foo (void)
{
  __builtin_memset (&a, 0x26, sizeof a);
  return a.i;
}

void __attribute__((noinline))
bar (void)
{
  __builtin_memset (&a, 0x36, sizeof a);
  a.i = 0x36363636;
  a.j = 0x36373636;
}

int
main (void)
{
  int i;
  if (sizeof (int) != 4 || __CHAR_BIT__ != 8)
    return 0;

  if (foo () != 0x26262626)
    __builtin_abort ();
  for (i = 0; i < sizeof a; i++)
    if (((char *)&a)[i] != 0x26)
      __builtin_abort ();

  bar ();
  if (a.j != 0x36373636)
    __builtin_abort ();
  a.j = 0x36363636;
  for (i = 0; i < sizeof a; i++)
    if (((char *)&a)[i] != 0x36)
      __builtin_abort ();
  return 0;
}
// source: 20090113-1.c
typedef struct descriptor_dimension
{
  int stride;
  int lbound;
  int ubound;
} descriptor_dimension;
typedef struct {
    int *data;
    int dtype;
    descriptor_dimension dim[7];
} gfc_array_i4;

void
msum_i4 (gfc_array_i4 * const retarray,
	 gfc_array_i4 * const array,
	 const int * const pdim)
{
  int count[7];
  int extent[7];
  int * dest;
  const int * base;
  int dim;
  int n;
  int len;

  dim = (*pdim) - 1;
  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;

  for (n = 0; n < dim; n++)
    {
      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;
      count[n] = 0;
    }

  dest = retarray->data;
  base = array->data;

  do
    {
      int result = 0;

      for (n = 0; n < len; n++, base++)
	result += *base;
      *dest = result;

      count[0]++;
      dest += 1;
    }
  while (count[0] != extent[0]);
}

int main()
{
  int rdata[3];
  int adata[9];
  gfc_array_i4 retarray = { rdata, 265, { { 1, 1, 3 } } };
  gfc_array_i4 array = { adata, 266, { { 1, 1, 3 }, { 3, 1, 3 } } };
  int dim = 2;
  msum_i4 (&retarray, &array, &dim);
  return 0;
}
// source: 20090113-2.c
struct obstack {};
struct bitmap_head_def;
typedef struct bitmap_head_def *bitmap;
typedef const struct bitmap_head_def *const_bitmap;
typedef unsigned long BITMAP_WORD;
typedef struct bitmap_obstack
{
  struct bitmap_element_def *elements;
  struct bitmap_head_def *heads;
  struct obstack obstack;
} bitmap_obstack;
typedef struct bitmap_element_def
{
  struct bitmap_element_def *next;
  struct bitmap_element_def *prev;
  unsigned int indx;
  BITMAP_WORD bits[((128 + (8 * 8 * 1u) - 1) / (8 * 8 * 1u))];
} bitmap_element;

struct bitmap_descriptor;

typedef struct bitmap_head_def {
    bitmap_element *first;
    bitmap_element *current;
    unsigned int indx;
    bitmap_obstack *obstack;
} bitmap_head;

bitmap_element bitmap_zero_bits;

typedef struct
{
  bitmap_element *elt1;
  bitmap_element *elt2;
  unsigned word_no;
  BITMAP_WORD bits;
} bitmap_iterator;

static void __attribute__((noinline))
bmp_iter_set_init (bitmap_iterator *bi, const_bitmap map,
		   unsigned start_bit, unsigned *bit_no)
{
  bi->elt1 = map->first;
  bi->elt2 = ((void *)0);

  while (1)
    {
      if (!bi->elt1)
	{
	  bi->elt1 = &bitmap_zero_bits;
	  break;
	}

      if (bi->elt1->indx >= start_bit / (((128 + (8 * 8 * 1u) - 1) / (8 * 8 * 1u)) * (8 * 8 * 1u)))
	break;
      bi->elt1 = bi->elt1->next;
    }

  if (bi->elt1->indx != start_bit / (((128 + (8 * 8 * 1u) - 1) / (8 * 8 * 1u)) * (8 * 8 * 1u)))
    start_bit = bi->elt1->indx * (((128 + (8 * 8 * 1u) - 1) / (8 * 8 * 1u)) * (8 * 8 * 1u));

  bi->word_no = start_bit / (8 * 8 * 1u) % ((128 + (8 * 8 * 1u) - 1) / (8 * 8 * 1u));
  bi->bits = bi->elt1->bits[bi->word_no];
  bi->bits >>= start_bit % (8 * 8 * 1u);

  start_bit += !bi->bits;

  *bit_no = start_bit;
}

static void __attribute__((noinline))
bmp_iter_next (bitmap_iterator *bi, unsigned *bit_no)
{
  bi->bits >>= 1;
  *bit_no += 1;
}

static unsigned char __attribute__((noinline))
bmp_iter_set_tail (bitmap_iterator *bi, unsigned *bit_no)
{
  while (!(bi->bits & 1))
    {
      bi->bits >>= 1;
      *bit_no += 1;
    }
  return 1;
}

static __inline__ unsigned char
bmp_iter_set (bitmap_iterator *bi, unsigned *bit_no)
{
  unsigned bno = *bit_no;
  BITMAP_WORD bits = bi->bits;
  bitmap_element *elt1;

  if (bits)
    {
      while (!(bits & 1))
	{
	  bits >>= 1;
	  bno += 1;
	}
      *bit_no = bno;
      return 1;
    }

  *bit_no = ((bno + 64 - 1) / 64 * 64);
  bi->word_no++;

  elt1 = bi->elt1;
  while (1)
    {
      while (bi->word_no != 2)
	{
	  bi->bits = elt1->bits[bi->word_no];
	  if (bi->bits)
	    {
	      bi->elt1 = elt1;
	      return bmp_iter_set_tail (bi, bit_no);
	    }
	  *bit_no += 64;
	  bi->word_no++;
	}

      elt1 = elt1->next;
      if (!elt1)
	{
	  bi->elt1 = elt1;
	  return 0;
	}
      *bit_no = elt1->indx * (2 * 64);
      bi->word_no = 0;
    }
}

extern void abort (void);

static void __attribute__((noinline)) catchme(int i)
{
  if (i != 0 && i != 64)
    abort ();
}
static void __attribute__((noinline)) foobar (bitmap_head *chain)
{
  bitmap_iterator rsi;
  unsigned int regno;
  for (bmp_iter_set_init (&(rsi), (chain), (0), &(regno));
       bmp_iter_set (&(rsi), &(regno));
       bmp_iter_next (&(rsi), &(regno)))
    catchme(regno);
}

int main()
{
  bitmap_element elem = { (void *)0, (void *)0, 0, { 1, 1 } };
  bitmap_head live_throughout = { &elem, &elem, 0, (void *)0 };
  foobar (&live_throughout);
  return 0;
}
// source: 20090113-3.c
struct obstack {};
struct bitmap_head_def;
typedef struct bitmap_head_def *bitmap;
typedef const struct bitmap_head_def *const_bitmap;
typedef unsigned long BITMAP_WORD;

typedef struct bitmap_obstack
{
  struct bitmap_element_def *elements;
  struct bitmap_head_def *heads;
  struct obstack obstack;
} bitmap_obstack;
typedef struct bitmap_element_def
{
  struct bitmap_element_def *next;
  struct bitmap_element_def *prev;
  unsigned int indx;
  BITMAP_WORD bits[(2)];
} bitmap_element;

struct bitmap_descriptor;

typedef struct bitmap_head_def {
    bitmap_element *first;
    bitmap_element *current;
    unsigned int indx;
    bitmap_obstack *obstack;
} bitmap_head;

bitmap_element bitmap_zero_bits;

typedef struct
{
  bitmap_element *elt1;
  bitmap_element *elt2;
  unsigned word_no;
  BITMAP_WORD bits;
} bitmap_iterator;

static __attribute__((noinline)) void
bmp_iter_set_init (bitmap_iterator *bi, const_bitmap map,
		   unsigned start_bit, unsigned *bit_no)
{
  bi->elt1 = map->first;
  bi->elt2 = ((void *)0);

  while (1)
    {
      if (!bi->elt1)
	{
	  bi->elt1 = &bitmap_zero_bits;
	  break;
	}

      if (bi->elt1->indx >= start_bit / (128u))
	break;
      bi->elt1 = bi->elt1->next;
    }

  if (bi->elt1->indx != start_bit / (128u))
    start_bit = bi->elt1->indx * (128u);

  bi->word_no = start_bit / 64u % (2);
  bi->bits = bi->elt1->bits[bi->word_no];
  bi->bits >>= start_bit % 64u;

  start_bit += !bi->bits;

  *bit_no = start_bit;
}

static __inline__ __attribute__((always_inline)) void
bmp_iter_next (bitmap_iterator *bi, unsigned *bit_no)
{
  bi->bits >>= 1;
  *bit_no += 1;
}

static __inline__ __attribute__((always_inline)) unsigned char
bmp_iter_set (bitmap_iterator *bi, unsigned *bit_no)
{
  if (bi->bits)
    {
      while (!(bi->bits & 1))
	{
	  bi->bits >>= 1;
	  *bit_no += 1;
	}
      return 1;
    }

  *bit_no = ((*bit_no + 64u - 1) / 64u * 64u);
  bi->word_no++;

  while (1)
    {
      while (bi->word_no != (2))
	{
	  bi->bits = bi->elt1->bits[bi->word_no];
	  if (bi->bits)
	    {
	      while (!(bi->bits & 1))
		{
		  bi->bits >>= 1;
		  *bit_no += 1;
		}
	      return 1;
	    }
	  *bit_no += 64u;
	  bi->word_no++;
	}

      bi->elt1 = bi->elt1->next;
      if (!bi->elt1)
	return 0;
      *bit_no = bi->elt1->indx * (128u);
      bi->word_no = 0;
    }
}

static void __attribute__((noinline))
foobar (bitmap_head *live_throughout)
{
  bitmap_iterator rsi;
  unsigned int regno;
  for (bmp_iter_set_init (&(rsi), (live_throughout), (0), &(regno));
       bmp_iter_set (&(rsi), &(regno));
       bmp_iter_next (&(rsi), &(regno)))
    ;
}
int main()
{
  bitmap_element elem = { (void *)0, (void *)0, 0, { 1, 1 } };
  bitmap_head live_throughout = { &elem, &elem, 0, (void *)0 };
  foobar (&live_throughout);
  return 0;
}
// source: 20090207-1.c
int foo(int i)
{
  int a[32];
  a[1] = 3;
  a[0] = 1;
  a[i] = 2;
  return a[0];
}
extern void abort (void);
int main()
{
  if (foo (0) != 2
      || foo (1) != 1)
    abort ();
  return 0;
}
// source: 20090219-1.c
/* On ARM, BAR used to get a bogus number in E due to stack
   misalignment.  */

extern void abort (void);
extern void exit (int);

void
foo (void)
{
  int f = 0;

  void bar (int a, int b, int c, int d, int e)
    {
      if (e != 0)
	{
	  f = 1;
	  abort ();
	}
    }

  bar (0, 0, 0, 0, 0);
}

int
main (void)
{
  foo ();
  exit (0);
}
// source: 20090527-1.c
typedef enum { POSITION_ASIS, POSITION_UNSPECIFIED } unit_position;

typedef enum { STATUS_UNKNOWN, STATUS_UNSPECIFIED } unit_status;

typedef struct
{
  unit_position position;
  unit_status status;
} unit_flags;

extern void abort (void);

void
new_unit (unit_flags * flags)
{
  if (flags->status == STATUS_UNSPECIFIED)
    flags->status = STATUS_UNKNOWN;

  if (flags->position == POSITION_UNSPECIFIED)
    flags->position = POSITION_ASIS;

  switch (flags->status)
    {
    case STATUS_UNKNOWN:
      break;

    default:
      abort ();
    }
}

int main()
{
  unit_flags f;
  f.status = STATUS_UNSPECIFIED;
  new_unit (&f);
  return 0;
}
// source: 20090623-1.c
int * __restrict__ x;

int foo (int y)
{
  *x = y;
  return *x;
}

extern void abort (void);

int main()
{
  int i = 0;
  x = &i;
  if (foo(1) != 1)
    abort ();
  return 0;
}
// source: 20090711-1.c
/* Used to be miscompiled at -O0 due to incorrect choice of sign extension
   vs. zero extension.  __attribute__ ((noinline)) added to try to make it
   fail at higher optimization levels too.  */

extern void abort (void);

long long __attribute__ ((noinline))
div (long long val)
{
  return val / 32768;
}

int main (void)
{
  long long d1 = -990000000;
  long long d2 = div(d1);
  if (d2 != -30212)
    abort ();
  return 0;
}
// source: 20090814-1.c
int __attribute__((noinline))
bar (int *a)
{
  return *a;
}
int i;
int __attribute__((noinline))
foo (int (*a)[2])
{
  return bar (&(*a)[i]);
}

extern void abort (void);
int a[2];
int main()
{
  a[0] = -1;
  a[1] = 42;
  i = 1;
  if (foo (&a) != 42)
    abort ();
  return 0;
}
// source: 20091229-1.c
long long foo(long long v) { return v / -0x080000000LL; }
int main(int argc, char **argv) { if (foo(0x080000000LL) != -1) abort(); exit (0); }
// source: 20100209-1.c
int bar(int foo)
{
  return (int)(((unsigned long long)(long long)foo) / 8);
}
extern void abort (void);
int main()
{
  if (sizeof (long long) > sizeof (int)
      && bar(-1) != -1)
    abort ();
  return 0;
}
// source: 20100316-1.c
struct Foo {
  int i;
  unsigned precision : 10;
  unsigned blah : 3;
} f;

int __attribute__((noinline,noclone))
foo (struct Foo *p)
{
  struct Foo *q = p;
  return (*q).precision;
}

extern void abort (void);

int main()
{
  f.i = -1;
  f.precision = 0;
  f.blah = -1;
  if (foo (&f) != 0)
    abort ();
  return 0;
}
// source: 20100416-1.c
void abort(void);

int
movegt(int x, int y, long long a)
{
  int i;
  int ret = 0;
  for (i = 0; i < y; i++)
    {
      if (a >= (long long) 0xf000000000000000LL)
	ret = x;
      else
	ret = y;
    }
  return ret;
}

struct test
{
  long long val;
  int ret;
} tests[] = {
  { 0xf000000000000000LL, -1 },
  { 0xefffffffffffffffLL, 1 },
  { 0xf000000000000001LL, -1 },
  { 0x0000000000000000LL, -1 },
  { 0x8000000000000000LL, 1 },
};

int
main()
{
  int i;
  for (i = 0; i < sizeof (tests) / sizeof (tests[0]); i++)
    {
      if (movegt (-1, 1, tests[i].val) != tests[i].ret)
	abort ();
    }
  return 0;
}
// source: 20100430-1.c
/* This used to generate unaligned accesses at -O2 because of IVOPTS.  */

struct packed_struct
{
  struct packed_struct1
  {
    unsigned char cc11;
    unsigned char cc12;
  } __attribute__ ((packed)) pst1;
  struct packed_struct2
  {
    unsigned char cc21;
    unsigned char cc22;
    unsigned short ss[104];
    unsigned char cc23[13];
  } __attribute__ ((packed)) pst2[4];
} __attribute__ ((packed));

typedef struct
{
  int ii;
  struct packed_struct buf;
} info_t;

static unsigned short g;

static void __attribute__((noinline))
dummy (unsigned short s)
{
  g = s;
}

static int
foo (info_t *info)
{
  int i, j;

  for (i = 0; i < info->buf.pst1.cc11; i++)
    for (j = 0; j < info->buf.pst2[i].cc22; j++)
      dummy (info->buf.pst2[i].ss[j]);

  return 0;
}

int main(void)
{
  info_t info;
  info.buf.pst1.cc11 = 2;
  info.buf.pst2[0].cc22 = info.buf.pst2[1].cc22 = 8;
  return foo (&info);
}
// source: 20100708-1.c
/* PR middle-end/44843 */
/* Verify that we don't use the alignment of struct S for inner accesses.  */

struct S
{
  double for_alignment;
  struct { int x, y, z; } a[16];
};

void f(struct S *s) __attribute__((noinline));

void f(struct S *s)
{
  unsigned int i;

  for (i = 0; i < 16; ++i)
    {
      s->a[i].x = 0;
      s->a[i].y = 0;
      s->a[i].z = 0;
    }
}

int main (void)
{
  struct S s;
  f (&s);
  return 0;
}
// source: 20100805-1.c
unsigned int foo (unsigned int a, unsigned int b)
{
  unsigned i;
  a = a & 1;
  for (i = 0; i < b; ++i)
    a = a << 1 | a >> (sizeof (unsigned int) * 8 - 1);
  return a;
}
extern void abort (void);
int main()
{
  if (foo (1, sizeof (unsigned int) * 8 + 1) != 2)
    abort ();
  return 0;
}
// source: 20100827-1.c
extern void abort (void);
int __attribute__((noinline,noclone))
foo (char *p)
{
  int h = 0;
  do
    {
      if (*p == '\0')
	break;
      ++h;
      if (p == 0)
	abort ();
      ++p;
    }
  while (1);
  return h;
}
int main()
{
  if (foo("a") != 1)
    abort ();
  return 0;
}
// source: 20101011-1.c
/* { dg-options "-fnon-call-exceptions" } */
/* With -fnon-call-exceptions 0 / 0 should not be eliminated.  */
/* { dg-additional-options "-DSIGNAL_SUPPRESS" { target { ! signal } } } */

#ifdef SIGNAL_SUPPRESS
# define DO_TEST 0
#elif defined (__powerpc__) || defined (__PPC__) || defined (__ppc__) || defined (__POWERPC__) || defined (__ppc)
  /* On PPC division by zero does not trap.  */
# define DO_TEST 0
#elif defined (__riscv)
  /* On RISC-V division by zero does not trap.  */
# define DO_TEST 0
#elif defined (__SPU__)
  /* On SPU division by zero does not trap.  */
# define DO_TEST 0
#elif defined (__sh__)
  /* On SH division by zero does not trap.  */
# define DO_TEST 0
#elif defined (__v850__)
  /* On V850 division by zero does not trap.  */
# define DO_TEST 0
#elif defined (__MSP430__)
  /* On MSP430 division by zero does not trap.  */
# define DO_TEST 0
#elif defined (__RL78__)
  /* On RL78 division by zero does not trap.  */
# define DO_TEST 0
#elif defined (__RX__)
  /* On RX division by zero does not trap.  */
# define DO_TEST 0
#elif defined (__aarch64__)
  /* On AArch64 integer division by zero does not trap.  */
# define DO_TEST 0
#elif defined (__TMS320C6X__)
  /* On TI C6X division by zero does not trap.  */
# define DO_TEST 0
#elif defined (__VISIUM__)
  /* On Visium division by zero does not trap.  */
# define DO_TEST 0
#elif defined (__mips__) && !defined(__linux__)
  /* MIPS divisions do trap by default, but libgloss targets do not
     intercept the trap and raise a SIGFPE.  The same is probably
     true of other bare-metal environments, so restrict the test to
     systems that use the Linux kernel.  */
# define DO_TEST 0
#elif defined (__mips16) && defined(__linux__)
  /* Not all Linux kernels deal correctly the breakpoints generated by
     MIPS16 divisions by zero.  They show up as a SIGTRAP instead.  */
# define DO_TEST 0
#elif defined (__MICROBLAZE__)
/* We cannot rely on division by zero generating a trap. */
# define DO_TEST 0
#elif defined (__epiphany__)
  /* Epiphany does not have hardware division, and the software implementation
     has truly undefined behavior for division by 0.  */
# define DO_TEST 0
#elif defined (__m68k__) && !defined(__linux__)
  /* Attempting to trap division-by-zero in this way isn't likely to work on
     bare-metal m68k systems.  */
# define DO_TEST 0
#elif defined (__CRIS__)
  /* No SIGFPE for CRIS integer division.  */
# define DO_TEST 0
#elif defined (__MMIX__)
/* By default we emit a sequence with DIVU, which "never signals an
   exceptional condition, even when dividing by zero".  */
# define DO_TEST 0
#elif defined (__arc__)
  /* No SIGFPE for ARC integer division.  */
# define DO_TEST 0
#elif defined (__arm__) && defined (__ARM_EABI__)
# ifdef __ARM_ARCH_EXT_IDIV__
  /* Hardware division instructions may not trap, and handle trapping
     differently anyway.  Skip the test if we have those instructions.  */
#  define DO_TEST 0
# else
#  include <signal.h>
  /* ARM division-by-zero behavior is to call a helper function, which
     can do several different things, depending on requirements.  Emulate
     the behavior of other targets here by raising SIGFPE.  */
int __attribute__((used))
__aeabi_idiv0 (int return_value)
{
  raise (SIGFPE);
  return return_value;
}
#  define DO_TEST 1
# endif
#elif defined (__nios2__)
  /* Nios II requires both hardware support and user configuration to
     raise an exception on divide by zero.  */
# define DO_TEST 0
#elif defined (__nvptx__)
/* There isn't even a signal function.  */
# define DO_TEST 0
#elif defined (__csky__)
  /* This presently doesn't raise SIGFPE even on csky-linux-gnu, much
     less bare metal.  See the implementation of __divsi3 in libgcc.  */
# define DO_TEST 0
#elif defined (__moxie__)
  /* Not all moxie configurations may raise exceptions.  */
# define DO_TEST 0
#elif defined (__or1k__)
  /* On OpenRISC division by zero does not trap.  */
# define DO_TEST 0
#elif defined (__pru__)
/* There isn't even a signal function.  */
# define DO_TEST 0
#else
# define DO_TEST 1
#endif

extern void abort (void);
extern void exit (int);

#if DO_TEST

#include <signal.h>

void
sigfpe (int signum __attribute__ ((unused)))
{
  exit (0);
}

#endif

/* When optimizing, the compiler is smart enough to constant fold the
   static unset variables i and j to produce 0 / 0, but it can't
   eliminate the assignment to the global k.  */
static int i;
static int j;
int k __attribute__ ((used));

int
main ()
{
#if DO_TEST
  signal (SIGFPE, sigfpe);
  k = i / j;
  abort ();
#else
  exit (0);
#endif
}
// source: 20101013-1.c
/* PR rtl-optimization/45912 */

extern void abort (void);

static void* __attribute__((noinline,noclone))
get_addr_base_and_unit_offset (void *base, long long *i)
{
  *i = 0;
  return base;
}

static void* __attribute__((noinline,noclone))
build_int_cst (void *base, long long offset)
{
  if (offset != 4)
    abort ();

  return base;
}

static void* __attribute__((noinline,noclone))
build_ref_for_offset (void *base, long long offset)
{
  long long base_offset;
  base = get_addr_base_and_unit_offset (base, &base_offset);
  return build_int_cst (base, base_offset + offset / 8);
}

int
main (void)
{
  void *ret = build_ref_for_offset ((void *)0, 32);
  if (ret != (void *)0)
    abort ();
  return 0;
}
// source: 20101025-1.c
static int g_7;
static int *volatile g_6 = &g_7;
int g_3;

static int f1 (int *p_58)
{
    return *p_58;
}

void f2 (int i) __attribute__ ((noinline));
void f2 (int i)
{
  g_3 = i;
}

int f3 (void) __attribute__ ((noinline));
int f3 (void)
{
    *g_6 = 1;
    f2 (f1 (&g_7));
    return 0;
}

int main ()
{
  f3 ();
  if (g_3 != 1)
    abort ();
  exit (0);
}
// source: 20110418-1.c
typedef unsigned long long uint64_t;
void f(uint64_t *a, uint64_t aa) __attribute__((noinline));
void f(uint64_t *a, uint64_t aa)
{
  uint64_t new_value = aa;
  uint64_t old_value = *a;
  int bit_size = 32;
    uint64_t mask = (uint64_t)(unsigned)(-1);
    uint64_t tmp = old_value & mask;
    new_value &= mask;
    /* On overflow we need to add 1 in the upper bits */
    if (tmp > new_value)
        new_value += 1ull<<bit_size;
    /* Add in the upper bits from the old value */
    new_value += old_value & ~mask;
    *a = new_value;
}
int main(void)
{
  uint64_t value, new_value, old_value;
  value = 0x100000001;
  old_value = value;
  new_value = (value+1)&(uint64_t)(unsigned)(-1);
  f(&value, new_value);
  if (value != old_value+1)
    __builtin_abort ();
  return 0;
}
// source: 20111208-1.c
/* PR tree-optimization/51315 */
/* Reported by Jurij Smakov <jurij@wooyd.org> */

typedef __SIZE_TYPE__ size_t;

extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strlen (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

typedef __INT16_TYPE__ int16_t;
typedef __INT32_TYPE__ int32_t;

extern void abort (void);

int a;

static void __attribute__ ((noinline,noclone))
do_something (int item)
{
  a = item;
}

int
pack_unpack (char *s, char *p)
{
  char *send, *pend;
  char type;
  int integer_size;

  send = s + strlen (s);
  pend = p + strlen (p);

  while (p < pend)
    {
      type = *p++;

      switch (type)
 {
 case 's':
   integer_size = 2;
   goto unpack_integer;

 case 'l':
   integer_size = 4;
   goto unpack_integer;

 unpack_integer:
   switch (integer_size)
     {
     case 2:
       {
  union
  {
    int16_t i;
    char a[sizeof (int16_t)];
  }
  v;
  memcpy (v.a, s, sizeof (int16_t));
  s += sizeof (int16_t);
  do_something (v.i);
       }
       break;

     case 4:
       {
  union
  {
    int32_t i;
    char a[sizeof (int32_t)];
  }
  v;
  memcpy (v.a, s, sizeof (int32_t));
  s += sizeof (int32_t);
  do_something (v.i);
       }
       break;
     }
   break;
 }
    }
  return (int) *s;
}

int
main (void)
{
  int n = pack_unpack ("\200\001\377\376\035\300", "sl");
  if (n != 0)
    abort ();
  return 0;
}
// source: 20111212-1.c
/* PR tree-optimization/50569 */
/* Reported by Paul Koning <pkoning@gcc.gnu.org> */
/* Reduced testcase by Mikael Pettersson <mikpe@it.uu.se> */

struct event {
    struct {
	unsigned int sec;
    } sent __attribute__((packed));
};

void __attribute__((noinline,noclone)) frob_entry(char *buf)
{
    struct event event;

    __builtin_memcpy(&event, buf, sizeof(event));
    if (event.sent.sec < 64) {
	event.sent.sec = -1U;
	__builtin_memcpy(buf, &event, sizeof(event));
    }
}

int main(void)
{
    union {
	char buf[1 + sizeof(struct event)];
	int align;
    } u;

    __builtin_memset(&u, 0, sizeof u);

    frob_entry(&u.buf[1]);

    return 0;
}
// source: 20111227-1.c
/* PR rtl-optimization/51667 */
/* Testcase by Uros Bizjak <ubizjak@gmail.com> */

extern void abort (void);

void __attribute__((noinline,noclone))
bar (int a)
{
  if (a != -1)
    abort ();
}

void __attribute__((noinline,noclone))
foo (short *a, int t)
{
  short r = *a;

  if (t)
    bar ((unsigned short) r);
  else
    bar ((signed short) r);
}

short v = -1;

int main(void)
{
  foo (&v, 0);
  return 0;
}
// source: 20120105-1.c
struct __attribute__((packed)) S
{
  int a, b, c;
};

static int __attribute__ ((noinline,noclone))
extract(const char *p)
{
  struct S s;
  __builtin_memcpy (&s, p, sizeof(struct S));
  return s.a;
}

volatile int i;

int main (void)
{
  char p[sizeof(struct S) + 1];

  __builtin_memset (p, 0, sizeof(struct S) + 1);
  i = extract (p + 1);

  return 0;
}
// source: 20120111-1.c
#include <stdlib.h>
#include <stdint.h>

uint32_t f0a (uint64_t arg2) __attribute__((noinline));

uint32_t
f0a (uint64_t arg)
{
  return ~((unsigned) (arg > -3));
}

int main() {
  uint32_t r1;
  r1 = f0a (12094370573988097329ULL);
  if (r1 != ~0U)
    abort ();
  return 0;
}
// source: 20120207-1.c
/* PR middle-end/51994 */
/* Testcase by Uros Bizjak <ubizjak@gmail.com> */

extern char *strcpy (char *, const char *);
extern void abort (void);

char __attribute__((noinline))
test (int a)
{
  char buf[16];
  char *output = buf;

  strcpy (&buf[0], "0123456789");

  output += a;
  output -= 1;

  return output[0];
}

int main ()
{
  if (test (2) != '1')
    abort ();

  return 0;
}
// source: 20120427-1.c
typedef struct sreal
{
  unsigned sig;		/* Significant.  */
  int exp;		/* Exponent.  */
} sreal;

sreal_compare (sreal *a, sreal *b)
{
  if (a->exp > b->exp)
    return 1;
  if (a->exp < b->exp)
    return -1;
  if (a->sig > b->sig)
    return 1;
  return -(a->sig < b->sig);
}

sreal a[] = {
   { 0, 0 },
   { 1, 0 },
   { 0, 1 },
   { 1, 1 }
};

int main()
{
  int i, j;
  for (i = 0; i <= 3; i++) {
    for (j = 0; j < 3; j++) {
      if (i < j && sreal_compare(&a[i], &a[j]) != -1) abort();
      if (i == j && sreal_compare(&a[i], &a[j]) != 0) abort();
      if (i > j && sreal_compare(&a[i], &a[j]) != 1) abort();
    }
  }
  return 0;
}
// source: 20120427-2.c
typedef struct sreal
{
  unsigned sig;		/* Significant.  */
  int exp;		/* Exponent.  */
} sreal;

sreal_compare (sreal *a, sreal *b)
{
  if (a->exp > b->exp)
    return 1;
  if (a->exp < b->exp)
    return -1;
  if (a->sig > b->sig)
    return 1;
  if (a->sig < b->sig)
    return -1;
  return 0;
}

sreal a[] = {
   { 0, 0 },
   { 1, 0 },
   { 0, 1 },
   { 1, 1 }
};

int main()
{
  int i, j;
  for (i = 0; i <= 3; i++) {
    for (j = 0; j < 3; j++) {
      if (i < j && sreal_compare(&a[i], &a[j]) != -1) abort();
      if (i == j && sreal_compare(&a[i], &a[j]) != 0) abort();
      if (i > j && sreal_compare(&a[i], &a[j]) != 1) abort();
    }
  }
  return 0;
}
// source: 20120615-1.c
extern void abort (void);

void __attribute__((noinline,noclone))
     test1(int i)
{
  if (i == 12)
    return;
  if (i != 17)
    {
      if (i == 15)
	return;
      abort ();
    }
}

int main() { test1 (15); return 0; }
// source: 20120808-1.c
extern void exit (int);
extern void abort (void);

volatile int i;
unsigned char *volatile cp;
unsigned char d[32] = { 0 };

int
main (void)
{
  unsigned char c[32] = { 0 };
  unsigned char *p = d + i;
  int j;
  for (j = 0; j < 30; j++)
    {
      int x = 0xff;
      int y = *++p;
      switch (j)
	{
	case 1: x ^= 2; break;
	case 2: x ^= 4; break;
	case 25: x ^= 1; break;
	default: break;
	}
      c[j] = y | x;
      cp = p;
    }
  if (c[0] != 0xff
      || c[1] != 0xfd
      || c[2] != 0xfb
      || c[3] != 0xff
      || c[4] != 0xff
      || c[25] != 0xfe
      || cp != d + 30)
    abort ();
  exit (0);
}
// source: 20120817-1.c
typedef unsigned long long u64;
unsigned long foo = 0;
u64 f() __attribute__((noinline));

u64 f() {
  return ((u64)40) + ((u64) 24) * (int)(foo - 1);
}

int main ()
{
  if (f () != 16)
    abort ();
  exit (0);
}
// source: 20120919-1.c
/* PR rtl-optimization/54290 */
/* Testcase by Eric Volk <eriksnga@gmail.com> */
/* { dg-require-effective-target int32plus } */

double vd[2] = {1., 0.};
int vi[2] = {1234567890, 0};
double *pd = vd;
int *pi = vi;

extern void abort(void);

void init (int *n, int *dummy) __attribute__ ((noinline,noclone));

void init (int *n, int *dummy)
{
  if(0 == n) dummy[0] = 0;
}

int main (void)
{
  int dummy[1532];
  int i = -1, n = 1, s = 0;
  init (&n, dummy);
  while (i < n) {
    if (i == 0) {
      if (pd[i] > 0) {
        if (pi[i] > 0) {
          s += pi[i];
        }
      }
      pd[i] = pi[i];
    }
    ++i;
  }
  if (s != 1234567890)
    abort ();
  return 0;
}
// source: 20121108-1.c
char temp[] = "192.168.190.160";
unsigned result = (((((192u<<8)|168u)<<8)|190u)<<8)|160u;

int strtoul1(const char *a, char **b, int c) __attribute__((noinline, noclone));
int strtoul1(const char *a, char **b, int c)
{
  *b = a+3;
  if (a == temp)
    return 192;
  else if (a == temp+4)
    return 168;
  else if (a == temp+8)
    return 190;
  else if (a == temp+12)
    return 160;
  __builtin_abort();
}

int string_to_ip(const char *s) __attribute__((noinline,noclone));
int string_to_ip(const char *s)
{
        int addr;
        char *e;
        int i;

        if (s == 0)
                return(0);

        for (addr=0, i=0; i<4; ++i) {
                int val = s ? strtoul1(s, &e, 10) : 0;
                addr <<= 8;
                addr |= (val & 0xFF);
                if (s) {
                        s = (*e) ? e+1 : e;
                }
        }

        return addr;
}

int main(void)
{
  int t = string_to_ip (temp);
  printf ("%x\n", t);
  printf ("%x\n", result);
  if (t != result)
    __builtin_abort ();
  printf ("WORKS.\n");
  return 0;
}
// source: 20131127-1.c
/* PR middle-end/59138 */
/* Testcase by John Regehr <regehr@cs.utah.edu> */

extern void abort (void);

#pragma pack(1)

struct S0 {
  int f0;
  int f1;
  int f2;
  short f3;
};

short a = 1;

struct S0 b = { 1 }, c, d, e;

struct S0 fn1() { return c; }

void fn2 (void)
{
  b = fn1 ();
  a = 0;
  d = e;
}

int main (void)
{
  fn2 ();
  if (a != 0)
    abort ();
  return 0;
}
// source: 20140212-1.c
/* PR rtl-optimization/60116 */
/* Reported by Zhendong Su <su@cs.ucdavis.edu> */

extern void abort (void);

int a, b, c, d = 1, e, f = 1, h, i, k;
char g, j;

void
fn1 (void)
{
  int l;
  e = 0;
  c = 0;
  for (;;)
    {
      k = a && b;
      j = k * 54;
      g = j * 147;
      l = ~g + (long long) e && 1;
      if (d)
	c = l;
      else
	h = i = l * 9UL;
      if (f)
	return;
    }
}

int
main (void)
{
  fn1 ();
  if (c != 1)
    abort ();
  return 0;
}
// source: 20140212-2.c
/* This used to fail as we would convert f into just return (unsigned int)usVlanID
   which is wrong. */

int f(unsigned short usVlanID) __attribute__((noinline,noclone));
int f(unsigned short usVlanID)
{
  unsigned int uiVlanID = 0xffffffff;
  int i;
  if ((unsigned short)0xffff != usVlanID)
    uiVlanID = (unsigned int)usVlanID;
  return uiVlanID;
}

int main(void)
{
  if (f(1) != 1)
    __builtin_abort ();
  if (f(0xffff) != -1)
    __builtin_abort ();
  return 0;
}
// source: 20140326-1.c
int a;

int
main (void)
{
  char e[2] = { 0, 0 }, f = 0;
  if (a == 131072)
    f = e[a];
  return f;
}
// source: 20140425-1.c
/* PR target/60941 */
/* Reported by Martin Husemann <martin@netbsd.org> */

extern void abort (void);

static void __attribute__((noinline))
set (unsigned long *l)
{
  *l = 31;
}

int main (void)
{
  unsigned long l;
  int i;

  set (&l);
  i = (int) l;
  l = (unsigned long)(2U << i);
  if (l != 0)
    abort ();
  return 0;
}
// source: 20140622-1.c
unsigned p;

long __attribute__((noinline, noclone))
test (unsigned a)
{
  return (long)(p + a) - (long)p;
}

int
main ()
{
  p = (unsigned) -2;
  if (test (0) != 0)
    __builtin_abort ();
  if (test (1) != 1)
    __builtin_abort ();
  if (test (2) != -(long)(unsigned)-2)
    __builtin_abort ();
  p = (unsigned) -1;
  if (test (0) != 0)
    __builtin_abort ();
  if (test (1) != -(long)(unsigned)-1)
    __builtin_abort ();
  if (test (2) != -(long)(unsigned)-2)
    __builtin_abort ();
  return 0;
}
// source: 20140828-1.c
short *f(short *a, int b, int *d) __attribute__((noinline,noclone));

short *f(short *a, int b, int *d)
{
  short c = *a;
  a++;
  c = b << c;
  *d = c;
  return a;
}

int main(void)
{
  int d;
  short a[2];
  a[0] = 0;
  if (f(a, 1, &d) != &a[1])
    __builtin_abort ();
  if (d != 1)
    __builtin_abort ();
  return 0;
}
// source: 20141022-1.c
#define ABORT() do { __builtin_printf("assert.\n");  __builtin_abort (); }while(0)
int f(int a) __attribute__((noinline));
int f(int a)
{
  int fem_key_src;
  int D2930 = a & 4294967291;
  fem_key_src = a == 6 ? 0 : 15;
  fem_key_src = D2930 != 1 ? fem_key_src : 0;
  return fem_key_src;
}

int main(void)
{
  if (f(0) != 15)
    ABORT ();
  if (f(1) != 0)
    ABORT ();
  if (f(6) != 0)
    ABORT ();
  if (f(5) != 0)
    ABORT ();
  if (f(15) != 15)
    ABORT ();
  return 0;
}
// source: 20141107-1.c
#define bool _Bool

bool f(int a, bool c) __attribute__((noinline));
bool f(int a, bool c)
{
  if (!a)
    c = !c;
  return c;
}

void checkf(int a, bool b)
{
  bool c = f(a, b);
  char d;
  __builtin_memcpy (&d, &c, 1);
  if ( d != (a==0)^b)
    __builtin_abort();
}

int main(void)
{
  checkf(0, 0);
  checkf(0, 1);
  checkf(1, 1);
  checkf(1, 0);
  return 0;
}
// source: 20141125-1.c
int f(long long a) __attribute__((noinline,noclone));
int f(long long a)
{
  if (a & 0x3ffffffffffffffull)
    return 1;
  return 1024;
}

int main(void)
{
  if(f(0x48375d8000000000ull) != 1)
    __builtin_abort ();
  if (f(0xfc00000000000000ull) != 1024)
    __builtin_abort ();
  return 0;
}
// source: 20150611-1.c
int a, c, d;
short b;

int
main ()
{
  int e[1];
  for (; b < 2; b++)
    {
      a = 0;
      if (b == 28378)
        a = e[b];
      if (!(d || b))
        for (; c;)
          ;
    }
  return 0;
}
// source: 20170111-1.c
/* PR rtl-optimization/79032 */
/* Reported by Daniel Cederman <cederman@gaisler.com> */

extern void abort (void);

struct S {
  short a;
  long long b;
  short c;
  char d;
  unsigned short e;
  long *f;
};

static long foo (struct S *s) __attribute__((noclone, noinline));

static long foo (struct S *s)
{
  long a = 1;
  a /= s->e;
  s->f[a]--;
  return a;
}

int main (void)
{
  long val = 1;
  struct S s = { 0, 0, 0, 0, 2, &val };
  val = foo (&s);
  if (val != 0)
    abort ();
  return 0;
}
// source: 20170401-1.c
/* PR45070 */
extern void abort(void);

struct packed_ushort {
    unsigned short ucs;
} __attribute__((packed));

struct source {
    int pos, length;
};

static int flag;

static void __attribute__((noinline)) fetch(struct source *p)
{
    p->length = 128;
}

static struct packed_ushort __attribute__((noinline)) next(struct source *p)
{
    struct packed_ushort rv;

    if (p->pos >= p->length) {
	if (flag) {
	    flag = 0;
	    fetch(p);
	    return next(p);
	}
	flag = 1;
	rv.ucs = 0xffff;
	return rv;
    }
    rv.ucs = 0;
    return rv;
}

int main(void)
{
    struct source s;
    int i;

    s.pos = 0;
    s.length = 0;
    flag = 0;

    for (i = 0; i < 16; i++) {
	struct packed_ushort rv = next(&s);
	if ((i == 0 && rv.ucs != 0xffff)
	    || (i > 0 && rv.ucs != 0))
	    abort();
    }
    return 0;
}
// source: 20170401-2.c
void adjust_xy (short *, short *);

struct adjust_template
{
  short kx_x;
  short kx_y;
};

static struct adjust_template adjust = {1, 1};

main ()
{
  short x = 1, y = 1;

  adjust_xy (&x, &y);

  if (x != 2)
    abort ();

  exit (0);
}

void
adjust_xy (x, y)
     short  *x;
     short  *y;
{
  *x = adjust.kx_x * *x + adjust.kx_y * *y;
}
// source: 20170419-1.c
/* PR tree-optimization/80426 */
/* Testcase by <ishiura-compiler@ml.kwansei.ac.jp> */

#define INT_MAX 0x7fffffff
#define INT_MIN (-INT_MAX-1)

int x;

int main (void)
{
  volatile int a = 0;
  volatile int b = -INT_MAX;
  int j;

  for(j = 0; j < 18; j += 1) {
    x = ( (a == 0) != (b - (int)(INT_MIN) ) );
  }

  if (x != 0)
    __builtin_abort ();

  return 0;
}
// source: 20171008-1.c
struct S { char c1, c2, c3, c4; } __attribute__((aligned(4)));

static char bar (char **p) __attribute__((noclone, noinline));
static struct S foo (void) __attribute__((noclone, noinline));

int i;

static char
bar (char **p)
{
  i = 1;
  return 0;
}

static struct S
foo (void)
{
  struct S ret;
  char r, s, c1, c2;
  char *p = &r;

  s = bar (&p);
  if (s)
    c2 = *p;
  c1 = 0;

  ret.c1 = c1;
  ret.c2 = c2;
  return ret;
}

int main (void)
{
  struct S s = foo ();
  if (s.c1 != 0)
    __builtin_abort ();
  return 0;
}
// source: 20180112-1.c
/* PR rtl-optimization/83565 */
/* Testcase by Sergei Trofimovich <slyfox@inbox.ru> */

extern void abort (void);

typedef __UINT32_TYPE__ u32;

u32 bug (u32 * result) __attribute__((noinline));
u32 bug (u32 * result)
{
  volatile u32 ss = 0xFFFFffff;
  volatile u32 d  = 0xEEEEeeee;
  u32 tt = d & 0x00800000;
  u32 r  = tt << 8;

  r = (r >> 31) | (r <<  1);

  u32 u = r^ss;
  u32 off = u >> 1;

  *result = tt;
  return off;
}

int main(void)
{
  u32 l;
  u32 off = bug(&l);
  if (off != 0x7fffffff)
    abort ();
  return 0;
}
// source: 20180131-1.c
/* PR rtl-optimization/84071 */
/* Reported by Wilco <wilco@gcc.gnu.org> */

extern void abort (void);

typedef union
{
  signed short ss;
  unsigned short us;
  int x;
} U;

int f(int x, int y, int z, int a, U u) __attribute__((noclone, noinline));

int f(int x, int y, int z, int a, U u)
{
  return (u.ss <= 0) + u.us;
}

int main (void)
{
  U u = { .ss = -1 };

  if (f (0, 0, 0, 0, u) != (1 << sizeof (short) * 8))
    abort ();

  return 0;
}
// source: 20180226-1.c
/* PR rtl-optimization/83496 */
/* Reported by Hauke Mehrtens <gcc@hauke-m.de> */

extern void abort (void);

typedef unsigned long mp_digit;

typedef struct { int used, alloc, sign; mp_digit *dp; } mp_int;

int mytest(mp_int *a, mp_digit b) __attribute__((noclone, noinline));

int mytest(mp_int *a, mp_digit b)
{
  if (a->sign == 1)
    return -1;
  if (a->used > 1)
    return 1;
  if (a->dp[0] > b)
    return 1;
  if (a->dp[0] < b)
    return -1;
  return 0;
}

int main (void)
{
  mp_int i = { 2, 0, -1 };
  if (mytest (&i, 0) != 1)
    abort ();
  return 0;
}
// source: 20180921-1.c
/* PR tree-optimization/86990 */
/* Testcase by Zhendong Su <su@cs.ucdavis.edu> */

const char *ss;

int __attribute__((noipa)) dummy (const char *s, ...)
{
  ss = s;
}

int i[6];
static int j, v, e, f, h = 5, k, l, n, o, p, q, r, s, u, w, x, y, z, aa, ab, ac,
                       ad, ae, af, ag = 8, ah, ai, aj, ak, al;
char c;
struct a {
  unsigned b;
  int c : 9;
  int d;
} static g = {9, 5};
static short m[1], t = 95, am;
int an, ao, ap;
void aq(int ar) {
  j = j & 5 ^ i[j ^ v & 5];
  j = j & 5 ^ i[(j ^ v) & 5];
  j = j & 4095 ^ (j ^ v) & 5;
}
void as(int ar) {
  if (n)
    s = 0;
}
static unsigned at() {
  int au[] = {2080555007, 0};
  for (; al; al--) {
    if (r)
      --x;
    if (g.d)
      l++;
    dummy("", j);
    if (u)
      ae = n = au[al];
  }
  r = 0;
  return 0;
}
int aw(int ar) {
  int ax[] = {9, 5, 5, 9, 5}, ay = 3;
  struct a az = {1, 3};
av:
  an = (as((at(), ax)[2]), ax[4]);
  {
    int ba[] = {5, 5, 9, 8, 1, 0, 5, 5, 9, 8, 1, 0,
                5, 5, 9, 8, 1, 0, 5, 5, 9, 8, 1};
    int a[] = {8, 2, 8, 2, 8, 2, 8};
    int b[] = {1027239, 8, 1, 7, 9, 2, 9, 4, 4, 2, 8, 1, 0, 4, 4, 2,
               4,       4, 2, 9, 2, 9, 8, 1, 7, 9, 2, 9, 4, 4, 2};
    if (z) {
      struct a bc;
    bb:
      for (; e; e++)
        for (; q;)
          return ax[e];
      if (bc.c < g.d <= a[7])
        aa--;
    }
    {
      struct a bd = {5};
      int d[20] = {1, 9, 7, 7, 8, 4, 4, 4, 4, 8, 1, 9, 7, 7, 8, 4, 4, 4, 4};
      c = h | r % g.c ^ x;
      dummy("", g);
      am -= t | x;
      if (h)
        while (1) {
          if (a[o]) {
            struct a be;
            if (ar) {
              struct a bf = {908, 5, 3};
              int bg[3], bh = k, bj = ag | ae, bk = aj + 3, bl = u << e;
              if (f)
                if (ac)
                  ak = w;
              ag = -(ag & t);
              af = ag ^ af;
              if (8 < af)
                break;
              if (bj)
                goto bi;
              if (s)
                dummy("", 6);
              be.d = k;
              w = f - bh;
              dummy("", be);
              if (w)
                goto bb;
              ao = r - aa && g.b;
              if (y)
                k++;
              goto av;
            bi:
              if (aa)
                continue;
              if (f)
                if (k)
                  dummy("", g);
              aj = ac + k ^ g.c;
              g.c = bk;
              ah = 0;
              for (; ah < 3; ah++)
                if (s)
                  bg[ah] = 8;
              if (!ay)
                dummy("", ai);
              u = bl;
              g = bf;
            } else
              for (;; o += a[ap])
                ;
            int bm[] = {0};
            for (; p; p++)
              c = ad;
            ad = l;
            if (bd.c) {
              dummy(" ");
              goto bi;
            }
          }
          int bn[] = {5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5,
                      2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2,
                      2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2};
          struct a a[] = {3440025416, 2, 8, 4, 2, 8, 4, 4, 2, 8, 4};
          struct a b = {3075920};
          if (f) {
            aq(m[am + e]);
            dummy("", j);
            dummy("", e);
            ab--;
          }
          if (ax[4]) {
            if (l)
              goto av;
            ++f;
          } else
            ay = az.c && a;
          for (; ac; ac++)
            m[f] = 0;
        }
      h = 9;
      for (; y; y = 1)
        if (f)
          goto av;
    }
  }
  return 0;
}

int main (void)
{
  aw(1);
  if (g.c!= 5)
    __builtin_abort ();
  return 0;
}
// source: 20181120-1.c
/* PR rtl-optimization/85925 */
/* { dg-require-effective-target int32plus } */
/* Testcase by <sudi@gcc.gnu.org> */

int a, c, d;
volatile int b;
int *e = &d;

union U1 {
  unsigned f0;
  unsigned f1 : 15;
};
volatile union U1 u = { 0x4030201 };

int main (void)
{
  for (c = 0; c <= 1; c++) {
    union U1 f = {0x4030201};
    if (c == 1)
      b;
    *e = f.f1;
  }

  if (d != u.f1)
    __builtin_abort ();

  return 0;
}
// source: 20190228-1.c
/* PR tree-optimization/89536 */
/* Testcase by Zhendong Su <su@cs.ucdavis.edu> */

int a = 1;

int main (void)
{
  a = ~(a && 1);
  if (a < -1)
    a = ~a;

  if (!a)
    __builtin_abort ();

  return 0;
}
// source: 20190820-1.c
/* PR rtl-optimization/91347 */
/* Reported by John David Anglin <danglin@gcc.gnu.org> */

typedef unsigned short __u16;
typedef __signed__ int __s32;
typedef unsigned int __u32;
typedef __signed__ long long __s64;
typedef unsigned long long __u64;
typedef __u16 u16;
typedef __s32 s32;
typedef __u32 u32;
typedef __u64 u64;
typedef _Bool bool;
typedef s32 int32_t;
typedef u32 uint32_t;
typedef u64 uint64_t;

char hex_asc_upper[16];
u16 decpair[100];

static __attribute__ ((noipa)) void
put_dec_full4 (char *buf, unsigned r)
{
 unsigned q;
 q = (r * 0x147b) >> 19;
 *((u16 *)buf) = decpair[r - 100*q];
 buf += 2;
 *((u16 *)buf) = decpair[q];
}

static __attribute__ ((noipa)) unsigned
put_dec_helper4 (char *buf, unsigned x)
{
  uint32_t q = (x * (uint64_t)0x346DC5D7) >> 43;
  put_dec_full4(buf, x - q * 10000);
  return q;
}

static __attribute__ ((noipa)) char *
put_dec (char *buf, unsigned long long n)
{
 uint32_t d3, d2, d1, q, h;
 d1 = ((uint32_t)n >> 16);
 h = (n >> 32);
 d2 = (h ) & 0xffff;
 d3 = (h >> 16);
 q = 656 * d3 + 7296 * d2 + 5536 * d1 + ((uint32_t)n & 0xffff);
 q = put_dec_helper4(buf, q);
 q += 7671 * d3 + 9496 * d2 + 6 * d1;
 q = put_dec_helper4(buf+4, q);
 q += 4749 * d3 + 42 * d2;
 q = put_dec_helper4(buf+8, q);
 return buf;
}

struct printf_spec {
 unsigned int type:8;
 signed int field_width:24;
 unsigned int flags:8;
 unsigned int base:8;
 signed int precision:16;
} __attribute__((__packed__));

static __attribute__ ((noipa)) char *
number (char *buf, char *end, unsigned long long num, struct printf_spec spec)
{

 char tmp[3 * sizeof(num)] __attribute__((__aligned__(2)));
 char sign;
 char locase;
 int need_pfx = ((spec.flags & 64) && spec.base != 10);
 int i;
 bool is_zero = num == 0LL;
 int field_width = spec.field_width;
 int precision = spec.precision;

 i = 0;
 if (num < spec.base)
  tmp[i++] = hex_asc_upper[num] | locase;
 else if (spec.base != 10) {
  int mask = spec.base - 1;
  int shift = 3;
  if (spec.base == 16)
   shift = 4;
  else
    __builtin_abort ();
  do {
   tmp[i++] = (hex_asc_upper[((unsigned char)num) & mask] | locase);
   num >>= shift;
  } while (num);
 } else {
  i = put_dec(tmp, num) - tmp;
 }
 return buf;
}

static __attribute__ ((noipa)) char *
pointer_string (char *buf, char *end, const void *ptr, struct printf_spec spec)
{
 spec.base = 16;
 spec.flags = 0;
 return number(buf, end, 100, spec);
}

int
main (void)
{
  struct printf_spec spec;
  char *s = pointer_string (0, 0, 0, spec);
  return 0;
}
// source: 900409-1.c
long f1(long a){return a&0xff000000L;}
long f2 (long a){return a&~0xff000000L;}
long f3(long a){return a&0x000000ffL;}
long f4(long a){return a&~0x000000ffL;}
long f5(long a){return a&0x0000ffffL;}
long f6(long a){return a&~0x0000ffffL;}

main ()
{
  long a = 0x89ABCDEF;

  if (f1(a)!=0x89000000L||
      f2(a)!=0x00ABCDEFL||
      f3(a)!=0x000000EFL||
      f4(a)!=0x89ABCD00L||
      f5(a)!=0x0000CDEFL||
      f6(a)!=0x89AB0000L)
    abort();
  exit(0);
}
// source: 920202-1.c
static int rule_text_needs_stack_pop = 0;
static int input_stack_pos = 1;

f (void)
{
  rule_text_needs_stack_pop = 1;

  if (input_stack_pos <= 0)
    return 1;
  else
    return 0;
}

main ()
{
  f ();
  exit (0);
}
// source: 920302-1.c
/* { dg-require-effective-target label_values } */

short optab[5];
char buf[10];
execute (ip)
     register short *ip;
{
  register void *base = &&x;
  char *bp = buf;
  static void *tab[] = {&&x, &&y, &&z};
  if (ip == 0)
    {
      int i;
      for (i = 0; i < 3; ++i)
	optab[i] = (short)(tab[i] - base);
      return;
    }
x:  *bp++='x';
    goto *(base + *ip++);
y:  *bp++='y';
    goto *(base + *ip++);
z:  *bp++='z';
    *bp=0;
    return;
}

short p[5];

main ()
{
  execute ((short *) 0);
  p[0] = optab[1];
  p[1] = optab[0];
  p[2] = optab[1];
  p[3] = optab[2];
  execute (&p);
  if (strcmp (buf, "xyxyz"))
    abort ();
  exit (0);
}
// source: 920409-1.c
x(){signed char c=-1;return c<0;}main(){if(x()!=1)abort();exit(0);}
// source: 920410-1.c
/* { dg-require-stack-size "40000 * 4 + 256" } */

main(){int d[40000];d[0]=0;exit(0);}
// source: 920411-1.c
long f (w)
     char *w;
{
  long k, i, c = 0, x;
  char *p = (char*) &x;
  for (i = 0; i < 1; i++)
    {
      for (k = 0; k < sizeof (long); k++)
	p[k] = w[k];
      c += x;
    }
  return c;
}

main ()
{
  int i;
  char a[sizeof (long)];

  for (i = sizeof (long); --i >= 0;) a[i] = ' ';
  if (f (a) != ~0UL / (unsigned char) ~0 * ' ')
    abort ();
  exit (0);
}
// source: 920415-1.c
/* { dg-require-effective-target label_values } */
main(){__label__ l;void*x(){return&&l;}goto*x();abort();return;l:exit(0);}
// source: 920428-1.c
x(const char*s){char a[1];const char*ss=s;a[*s++]|=1;return(int)ss+1==(int)s;}
main(){if(x("")!=1)abort();exit(0);}
// source: 920428-2.c
/* { dg-require-effective-target label_values } */
/* { dg-require-effective-target trampolines } */

s(i){if(i>0){__label__ l1;int f(int i){if(i==2)goto l1;return 0;}return f(i);l1:;}return 1;}
x(){return s(0)==1&&s(1)==0&&s(2)==1;}
main(){if(x()!=1)abort();exit(0);}
// source: 920429-1.c
typedef unsigned char t;int i,j;
t*f(t*p){t c;c=*p++;i=((c&2)?1:0);j=(c&7)+1;return p;}
main(){t*p0="ab",*p1;p1=f(p0);if(p0+1!=p1)abort();exit(0);}
// source: 920501-1.c
/* { dg-require-effective-target untyped_assembly } */
int s[2];
x(){if(!s[0]){s[1+s[1]]=s[1];return 1;}}
main(){s[0]=s[1]=0;if(x(0)!=1)abort();exit(0);}
// source: 920501-2.c
unsigned long
gcd_ll (unsigned long long x, unsigned long long y)
{
  for (;;)
    {
      if (y == 0)
	return (unsigned long) x;
      x = x % y;
      if (x == 0)
	return (unsigned long) y;
      y = y % x;
    }
}

unsigned long long
powmod_ll (unsigned long long b, unsigned e, unsigned long long m)
{
  unsigned t;
  unsigned long long pow;
  int i;

  if (e == 0)
    return 1;

  /* Find the most significant bit in E.  */
  t = e;
  for (i = 0; t != 0; i++)
    t >>= 1;

  /* The most sign bit in E is handled outside of the loop, by beginning
     with B in POW, and decrementing I.  */
  pow = b;
  i -= 2;

  for (; i >= 0; i--)
    {
      pow = pow * pow % m;
      if ((1 << i) & e)
	pow = pow * b % m;
    }

  return pow;
}

unsigned long factab[10];

void
facts (t, a_int, x0, p)
     unsigned long long t;
     int a_int;
     int x0;
     unsigned p;
{
  unsigned long *xp = factab;
  unsigned long long x, y;
  unsigned long q = 1;
  unsigned long long a = a_int;
  int i;
  unsigned long d;
  int j = 1;
  unsigned long tmp;
  int jj = 0;

  x = x0;
  y = x0;

  for (i = 1; i < 10000; i++)
    {
      x = powmod_ll (x, p, t) + a;
      y = powmod_ll (y, p, t) + a;
      y = powmod_ll (y, p, t) + a;

      if (x > y)
	tmp = x - y;
      else
	tmp = y - x;
      q = (unsigned long long) q * tmp % t;

      if (i == j)
	{
	  jj += 1;
	  j += jj;
	  d = gcd_ll (q, t);
	  if (d != 1)
	    {
	      *xp++ = d;
	      t /= d;
	      if (t == 1)
		{
		  return;
		  *xp = 0;
		}
	    }
	}
    }
}

main ()
{
  unsigned long long t;
  unsigned x0, a;
  unsigned p;

  p = 27;
  t = (1ULL << p) - 1;

  a = -1;
  x0 = 3;

  facts (t, a, x0, p);
  if (factab[0] != 7 || factab[1] != 73 || factab[2] != 262657)
    abort();
  exit (0);
}
// source: 920501-3.c
/* { dg-require-effective-target label_values } */

int tab[9];
execute(oip, ip)
     unsigned short *oip, *ip;
{
  int x = 0;
  int *xp = tab;
base:
  x++;
  if (x == 4)
    {
      *xp = 0;
      return;
    }
  *xp++ = ip - oip;
  goto *(&&base + *ip++);
}

main()
{
  unsigned short ip[10];
  int i;
  for (i = 0; i < 10; i++)
    ip[i] = 0;
  execute(ip, ip);
  if (tab[0] != 0 || tab[1] != 1 || tab[2] != 2 || tab[3] != 0)
    abort();
  exit(0);
}
// source: 920501-4.c
/* { dg-require-effective-target label_values } */

int
x (int i)
{
  static const void *j[] = {&& x, && y, && z};

  goto *j[i];

 x: return 2;
 y: return 3;
 z: return 5;
}

int
main (void)
{
  if (   x (0) != 2
      || x (1) != 3
      || x (2) != 5)
    abort ();

  exit (0);
}
// source: 920501-5.c
/* { dg-require-effective-target label_values } */

x (int i)
{
  void *j[] = {&&x, &&y, &&z};
  goto *j[i];
 x:return 2;
 y:return 3;
 z:return 5;

}
main ()
{
  if (x (0) != 2 || x (1) != 3 || x (2) != 5)
    abort();
  exit(0);
}
// source: 920501-6.c
#include <stdio.h>

/* Convert a decimal string to a long long unsigned.  No error check is
   performed.  */

long long unsigned
str2llu (str)
     char *str;
{
  long long unsigned acc;
  int d;
  acc =  *str++ - '0';
  for (;;)
    {
      d = *str++;
      if (d == '\0')
	break;
      d -= '0';
      acc = acc * 10 + d;
    }

  return acc;
}

/* isqrt(t) - computes the square root of t. (tege 86-10-27) */

long unsigned
sqrtllu (long long unsigned t)
{
  long long unsigned s;
  long long unsigned b;

  for (b = 0, s = t;  b++, (s >>= 1) != 0; )
    ;

  s = 1LL << (b >> 1);

  if (b & 1)
    s += s >> 1;

  do
    {
      b = t / s;
      s = (s + b) >> 1;
    }
  while (b < s);

  return s;
}


int plist (p0, p1, tab)
     long long unsigned p0, p1;
     long long unsigned *tab;
{
  long long unsigned p;
  long unsigned d;
  long unsigned s;
  long long unsigned *xp = tab;

  for (p = p0;  p <= p1;  p += 2)
    {
      s = sqrtllu (p);

      for (d = 3;  d <= s;  d += 2)
	{
	  long long unsigned q = p % d;
	  if (q == 0)
	    goto not_prime;
	}

      *xp++ = p;
    not_prime:;
    }
  *xp = 0;
  return xp - tab;
}

main (argc, argv)
     int argc;
     char *argv[];
{
  long long tab[10];
  int nprimes;
  nprimes = plist (str2llu ("1234111111"), str2llu ("1234111127"), tab);

  if(tab[0]!=1234111117LL||tab[1]!=1234111121LL||tab[2]!=1234111127LL||tab[3]!=0)
    abort();

  exit(0);
}
// source: 920501-7.c
/* { dg-require-effective-target label_values } */
/* { dg-require-effective-target trampolines } */
/* { dg-add-options stack_size } */

#ifdef STACK_SIZE
#define DEPTH ((STACK_SIZE) / 512 + 1)
#else
#define DEPTH 1000
#endif

x(a)
{
  __label__ xlab;
  void y(a)
    {
      if (a==0)
	goto xlab;
      y (a-1);
    }
  y (a);
 xlab:;
  return a;
}

main ()
{
  if (x (DEPTH) != DEPTH)
    abort ();

  exit (0);
}
// source: 920501-8.c
/* { dg-additional-options "-Wl,-u,_printf_float" { target newlib_nano_io } } */

#include <stdio.h>
#include <stdarg.h>

char buf[50];
int
va (int a, double b, int c, ...)
{
  va_list ap;
  int d, e, f, g, h, i, j, k, l, m, n, o, p;
  va_start (ap, c);

  d = va_arg (ap, int);
  e = va_arg (ap, int);
  f = va_arg (ap, int);
  g = va_arg (ap, int);
  h = va_arg (ap, int);
  i = va_arg (ap, int);
  j = va_arg (ap, int);
  k = va_arg (ap, int);
  l = va_arg (ap, int);
  m = va_arg (ap, int);
  n = va_arg (ap, int);
  o = va_arg (ap, int);
  p = va_arg (ap, int);

  sprintf (buf,
	   "%d,%f,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
	   a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);
  va_end (ap);
}

main()
{
  va (1, 1.0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  if (strcmp ("1,1.000000,2,3,4,5,6,7,8,9,10,11,12,13,14,15", buf))
    abort();
  exit(0);
}
// source: 920501-9.c
#include <stdio.h>

long long proc1(){return 1LL;}
long long proc2(){return 0x12345678LL;}
long long proc3(){return 0xaabbccdd12345678LL;}
long long proc4(){return -1LL;}
long long proc5(){return 0xaabbccddLL;}

print_longlong(x,buf)
     long long x;
     char *buf;
{
  unsigned long l;
  l= (x >> 32) & 0xffffffff;
  if (l != 0)
    sprintf(buf,"%lx%08.lx",l,((unsigned long)x & 0xffffffff));
  else
    sprintf(buf,"%lx",((unsigned long)x & 0xffffffff));
}

main(){char buf[100];
print_longlong(proc1(),buf);if(strcmp("1",buf))abort();
print_longlong(proc2(),buf);if(strcmp("12345678",buf))abort();
print_longlong(proc3(),buf);if(strcmp("aabbccdd12345678",buf))abort();
print_longlong(proc4(),buf);if(strcmp("ffffffffffffffff",buf))abort();
print_longlong(proc5(),buf);if(strcmp("aabbccdd",buf))abort();
exit(0);}
// source: 920506-1.c
int l[]={0,1};
main(){int*p=l;switch(*p++){case 0:exit(0);case 1:break;case 2:break;case 3:case 4:break;}abort();}
// source: 920520-1.c
foo(int *bar)
{
  *bar = 8;
}

bugger()
{
  int oldDepth, newDepth;

  foo(&oldDepth);

  switch (oldDepth)
    {
    case 8:
    case 500:
      newDepth = 8;
      break;

    case 5000:
      newDepth = 500;
      break;

    default:
      newDepth = 17;
      break;
    }

  return newDepth - oldDepth;
}

main()
{
  if (bugger() != 0)
    abort ();
  exit (0);
}
// source: 920603-1.c
f(got){if(got!=0xffff)abort();}
main(){signed char c=-1;unsigned u=(unsigned short)c;f(u);exit(0);}
// source: 920604-1.c
long long
mod (a, b)
     long long a, b;
{
  return a % b;
}

int
main ()
{
  mod (1LL, 2LL);
  exit (0);
}
// source: 920612-1.c
/* { dg-options "-fwrapv" } */

extern void abort (void);
extern void exit (int);

int f(j)int j;{return++j>0;}
int main(){if(f((~0U)>>1))abort();exit(0);}
// source: 920612-2.c
/* { dg-require-effective-target trampolines } */

main ()
{
  int i = 0;
  int a (int x)
    {
      while (x)
	i++, x--;
      return x;
    }

  if (a (2) != 0)
    abort ();

  exit (0);
}
// source: 920618-1.c
main(){if(1.17549435e-38F<=1.1)exit(0);abort();}
// source: 920625-1.c
#include <stdarg.h>

typedef struct{double x,y;}point;
point pts[]={{1.0,2.0},{3.0,4.0},{5.0,6.0},{7.0,8.0}};
static int va1(int nargs,...)
{
  va_list args;
  int i;
  point pi;
  va_start(args,nargs);
  for(i=0;i<nargs;i++){
    pi=va_arg(args,point);
    if(pts[i].x!=pi.x||pts[i].y!=pi.y)abort();
  }
  va_end(args);
}

typedef struct{int x,y;}ipoint;
ipoint ipts[]={{1,2},{3,4},{5,6},{7,8}};
static int va2(int nargs,...)
{
  va_list args;
  int i;
  ipoint pi;
  va_start(args,nargs);
  for(i=0;i<nargs;i++){
    pi=va_arg(args,ipoint);
    if(ipts[i].x!=pi.x||ipts[i].y!=pi.y)abort();
  }
  va_end(args);
}

main()
{
va1(4,pts[0],pts[1],pts[2],pts[3]);
va2(4,ipts[0],ipts[1],ipts[2],ipts[3]);
exit(0);
}
// source: 920710-1.c
main()
{
  if ((double) 18446744073709551615ULL < 1.84467440737095e+19 ||
      (double) 18446744073709551615ULL > 1.84467440737096e+19)
    abort();

  if (16777217L != (float)16777217e0)
    abort();

  exit(0);
}
// source: 920711-1.c
/* { dg-options "-fwrapv" } */

extern void abort (void);
extern void exit (int);

int f(long a){return (--a > 0);}
int main(){if(f(0x80000000L)==0)abort();exit(0);}
// source: 920721-1.c
long f(short a,short b){return (long)a/b;}
main(){if(f(-32768,-1)!=32768L)abort();else exit(0);}
// source: 920721-2.c
/* { dg-skip-if "requires alloca" { ! alloca } { "-O0" } { "" } } */
f(){}
main(){int n=2;double x[n];f();exit(0);}
// source: 920721-3.c
static inline fu (unsigned short data)
{
  return data;
}
ru(i)
{
   if(fu(i++)!=5)abort();
   if(fu(++i)!=7)abort();
}
static inline fs (signed short data)
{
  return data;
}
rs(i)
{
   if(fs(i++)!=5)abort();
   if(fs(++i)!=7)abort();
}


main()
{
  ru(5);
  rs(5);
  exit(0);
}
// source: 920721-4.c
/* { dg-require-effective-target label_values } */

int try (int num) {
  __label__ lab1, lab2, lab3, lab4, lab5, lab6, default_lab;

  void *do_switch (int num) {
    switch(num) {
    case 1:
      return &&lab1;
    case 2:
      return &&lab2;
    case 3:
      return &&lab3;
    case 4:
      return &&lab4;
    case 5:
      return &&lab5;
    case 6:
      return &&lab6;
    default:
      return &&default_lab;
    }
  }

  goto *do_switch (num);

 lab1:
  return 1;

 lab2:
  return 2;

 lab3:
  return 3;

 lab4:
  return 4;

 lab5:
  return 5;

 lab6:
  return 6;

 default_lab:
  return -1;
}

main()
{
  int i;
  for (i = 1; i <= 6; i++)
    {
      if (try (i) != i)
	abort();
    }
  exit(0);
}
// source: 920726-1.c
#include <stdio.h>
#include <stdarg.h>

struct spurious
{
    int anumber;
};

int first(char *buf, char *fmt, ...)
{
  int pos, number;
  va_list args;
  int dummy;
  char *bp = buf;

  va_start(args, fmt);
  for (pos = 0; fmt[pos]; pos++)
    if (fmt[pos] == 'i')
      {
	number = va_arg(args, int);
	sprintf(bp, "%d", number);
	bp += strlen(bp);
      }
    else
      *bp++ = fmt[pos];

  va_end(args);
  *bp = 0;
  return dummy;
}

struct spurious second(char *buf,char *fmt, ...)
{
  int pos, number;
  va_list args;
  struct spurious dummy;
  char *bp = buf;

  va_start(args, fmt);
  for (pos = 0; fmt[pos]; pos++)
    if (fmt[pos] == 'i')
      {
	number = va_arg(args, int);
	sprintf(bp, "%d", number);
	bp += strlen(bp);
      }
    else
      *bp++ = fmt[pos];

  va_end(args);
  *bp = 0;
  return dummy;
}

main()
{
  char buf1[100], buf2[100];
  first(buf1, "i i ", 5, 20);
  second(buf2, "i i ", 5, 20);
  if (strcmp ("5 20 ", buf1) || strcmp ("5 20 ", buf2))
    abort();
  exit(0);
}
// source: 920728-1.c
typedef struct {int dims[0]; } *A;

f(unsigned long obj)
{
  unsigned char y = obj >> 24;
  y &= ~4;

  if ((y==0)||(y!=251  ))
    abort();

  if(((int)obj&7)!=7)return;

  REST_OF_CODE_JUST_HERE_TO_TRIGGER_THE_BUG:

  {
    unsigned char t = obj >> 24;
    if (!(t==0)&&(t<=0x03))
      return 0;
    return ((A)(obj&0x00FFFFFFL))->dims[1];
  }
}

long g(){return 0xff000000L;}
main (){int x;f(g());exit(0);}
// source: 920730-1.c
/* 920730-1.c */
#include <limits.h>
f1()
{
	int b=INT_MIN;
	return b>=INT_MIN;
}

f2()
{
	int b=INT_MIN+1;
	return b>= (unsigned)(INT_MAX+2);
}

f3()
{
	int b=INT_MAX;
	return b>=INT_MAX;
}

f4()
{
	int b=-1;
	return b>=UINT_MAX;
}

main ()
{
	if((f1()&f2()&f3()&f4())!=1)
		abort();
		exit(0);
}
// source: 920731-1.c
f(x){int i;for(i=0;i<8&&(x&1)==0;x>>=1,i++);return i;}
main(){if(f(4)!=2)abort();exit(0);}
// source: 920810-1.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct{void*super;int name;int size;}t;
t*f(t*clas,int size)
{
  t*child=(t*)malloc(size);
  memcpy(child,clas,clas->size);
  child->super=clas;
  child->name=0;
  child->size=size;
  return child;
}
main()
{
  t foo,*bar;
  memset(&foo,37,sizeof(t));
  foo.size=sizeof(t);
  bar=f(&foo,sizeof(t));
  if(bar->super!=&foo||bar->name!=0||bar->size!=sizeof(t))abort();
  exit(0);
}
// source: 920812-1.c
typedef int t;
f(t y){switch(y){case 1:return 1;}return 0;}
main(){if(f((t)1)!=1)abort();exit(0);}
// source: 920829-1.c
long long c=2863311530LL,c3=2863311530LL*3;
main(){if(c*3!=c3)abort();exit(0);}
// source: 920908-1.c
/* REPRODUCED:RUN:SIGNAL MACHINE:mips OPTIONS: */

#include <stdarg.h>

typedef struct{int A;}T;

T f(int x,...)
{
va_list ap;
T X;
va_start(ap,x);
X=va_arg(ap,T);
if(X.A!=10)abort();
X=va_arg(ap,T);
if(X.A!=20)abort();
va_end(ap);
return X;
}

main()
{
T X,Y;
int i;
X.A=10;
Y.A=20;
f(2,X,Y);
exit(0);
}
// source: 920908-2.c
/* The bit-field below would have a problem if __INT_MAX__ is too
   small.  */
#if __INT_MAX__ < 2147483647
int
main (void)
{
  exit (0);
}
#else
/*
CONF:m68k-sun-sunos4.1.1
OPTIONS:-O
*/
struct T
{
unsigned i:8;
unsigned c:24;
};
f(struct T t)
{
struct T s[1];
s[0]=t;
return(char)s->c;
}
main()
{
struct T t;
t.i=0xff;
t.c=0xffff11;
if(f(t)!=0x11)abort();
exit(0);
}
#endif
// source: 920909-1.c
f(a){switch(a){case 0x402:return a+1;case 0x403:return a+2;case 0x404:return a+3;case 0x405:return a+4;case 0x406:return 1;case 0x407:return 4;}return 0;}
main(){if(f(1))abort();exit(0);}
// source: 920922-1.c
unsigned long*
f(p)unsigned long*p;
{
  unsigned long a = (*p++) >> 24;
  return p + a;
}

main ()
{
  unsigned long x = 0x80000000UL;
  if (f(&x) != &x + 0x81)
    abort();
  exit(0);
}
// source: 920929-1.c
/* { dg-skip-if "requires alloca" { ! alloca } { "-O0" } { "" } } */
/* REPRODUCED:RUN:SIGNAL MACHINE:sparc OPTIONS: */
f(int n)
{
int i;
double v[n];
for(i=0;i<n;i++)
v[i]=0;
}
main()
{
f(100);
exit(0);
}
// source: 921006-1.c
/* REPRODUCED:RUN:SIGNAL MACHINE:i386 OPTIONS:-O */
main()
{
if(strcmp("X","")<0)abort();
exit(0);
}
// source: 921007-1.c
static int strcmp(){return-1;}
#define strcmp __builtin_strcmp
main()
{
if(strcmp("X","X\376")>=0)abort();
exit(0);
}
// source: 921013-1.c
f(d,x,y,n)
int*d;
float*x,*y;
int n;
{
  while(n--){*d++=*x++==*y++;}
}

main()
{
  int r[4];
  float a[]={5,1,3,5};
  float b[]={2,4,3,0};
  int i;
  f(r,a,b,4);
  for(i=0;i<4;i++)
    if((a[i]==b[i])!=r[i])
      abort();
  exit(0);
}
// source: 921016-1.c
main()
{
int j=1081;
struct
{
signed int m:11;
}l;
if((l.m=j)==j)abort();
exit(0);
}
// source: 921017-1.c
/* { dg-skip-if "requires alloca" { ! alloca } { "-O0" } { "" } } */
/* { dg-require-effective-target trampolines } */

f(n)
{
  int a[n];
  int g(i)
    {
      return a[i];
    }
  a[1]=4711;
  return g(1);
}
main()
{
  if(f(2)!=4711)abort();

  exit(0);
}
// source: 921019-1.c
void *foo[]={(void *)&("X"[0])};

main ()
{
  if (((char*)foo[0])[0] != 'X')
    abort ();
  exit (0);
}
// source: 921019-2.c
main()
{
  double x,y=0.5;
  x=y/0.2;
  if(x!=x)
    abort();
  exit(0);
}
// source: 921029-1.c
typedef unsigned long long ULL;
ULL back;
ULL hpart, lpart;
ULL
build(long h, long l)
{
  hpart = h;
  hpart <<= 32;
  lpart = l;
  lpart &= 0xFFFFFFFFLL;
  back = hpart | lpart;
  return back;
}

main()
{
  if (build(0, 1) != 0x0000000000000001LL)
    abort();
  if (build(0, 0) != 0x0000000000000000LL)
    abort();
  if (build(0, 0xFFFFFFFF) != 0x00000000FFFFFFFFLL)
    abort();
  if (build(0, 0xFFFFFFFE) != 0x00000000FFFFFFFELL)
    abort();
  if (build(1, 1) != 0x0000000100000001LL)
    abort();
  if (build(1, 0) != 0x0000000100000000LL)
    abort();
  if (build(1, 0xFFFFFFFF) != 0x00000001FFFFFFFFLL)
    abort();
  if (build(1, 0xFFFFFFFE) != 0x00000001FFFFFFFELL)
    abort();
  if (build(0xFFFFFFFF, 1) != 0xFFFFFFFF00000001LL)
    abort();
  if (build(0xFFFFFFFF, 0) != 0xFFFFFFFF00000000LL)
    abort();
  if (build(0xFFFFFFFF, 0xFFFFFFFF) != 0xFFFFFFFFFFFFFFFFLL)
    abort();
  if (build(0xFFFFFFFF, 0xFFFFFFFE) != 0xFFFFFFFFFFFFFFFELL)
    abort();
  exit(0);
}
// source: 921104-1.c
main ()
{
  unsigned long val = 1;

  if (val > (unsigned long) ~0)
    abort();
  exit (0);
}
// source: 921110-1.c
extern void abort(void);
typedef void (*frob)();
frob f[] = {abort};

int main(void)
{
  exit(0);
}
// source: 921112-1.c
union u {
  struct { int i1, i2; } t;
  double d;
} x[2], v;

f (x, v)
     union u *x, v;
{
  *++x = v;
}

main()
{
  x[1].t.i1 = x[1].t.i2 = 0;
  v.t.i1 = 1;
  v.t.i2 = 2;
  f (x, v);
  if (x[1].t.i1 != 1 || x[1].t.i2 != 2)
    abort ();
  exit (0);
}
// source: 921113-1.c
/* { dg-require-stack-size "128 * 128 * 4 + 1024" } */

typedef struct {
  float wsx;
} struct_list;

typedef struct_list *list_t;

typedef struct {
  float x, y;
} vector_t;

w(float x, float y) {}

f1(float x, float y)
{
  if (x != 0 || y != 0)
    abort();
}
f2(float x, float y)
{
  if (x != 1 || y != 1)
    abort();
}

gitter(int count, vector_t pos[], list_t list, int *nww, vector_t limit[2], float r)
{
  float d;
  int gitt[128][128];

  f1(limit[0].x, limit[0].y);
  f2(limit[1].x, limit[1].y);

  *nww = 0;

  d = pos[0].x;
  if (d <= 0.)
    {
      w(d, r);
      if (d <= r * 0.5)
	{
	  w(d, r);
	  list[0].wsx = 1;
	}
    }
}

vector_t pos[1] = {{0., 0.}};
vector_t limit[2] = {{0.,0.},{1.,1.}};

main()
{
  int nww;
  struct_list list;

  gitter(1, pos, &list, &nww, limit, 1.);
  exit(0);
}
// source: 921117-1.c
struct s {
  char text[11];
  int flag;
} cell;

int
check (struct s p)
{
  if (p.flag != 99)
    return 1;
  return strcmp (p.text, "0123456789");
}

main ()
{
  cell.flag = 99;
  strcpy (cell.text, "0123456789");

  if (check (cell))
    abort();
  exit (0);
}
// source: 921123-1.c
f(short *p)
{
  short x = *p;
  return (--x < 0);
}

main()
{
  short x = -10;
  if (!f(&x))
    abort();
  exit(0);
}
// source: 921123-2.c
typedef struct
{
  unsigned short b0, b1, b2, b3;
} four_quarters;

four_quarters x;
int a, b;

void f (four_quarters j)
{
  b = j.b2;
  a = j.b3;
}

main ()
{
  four_quarters x;
  x.b0 = x.b1 = x.b2 = 0;
  x.b3 = 38;
  f(x);
  if (a != 38)
    abort();
  exit (0);
}
// source: 921124-1.c
f(x, d1, d2, d3)
   double d1, d2, d3;
{
   return x;
}

g(b,s,x,y,i,j)
     char *b,*s;
     double x,y;
{
  if (x != 1.0 || y != 2.0 || i != 3 || j != 4)
    abort();
}

main()
{
  g("","", 1.0, 2.0, f(3, 0.0, 0.0, 0.0), f(4, 0.0, 0.0, 0.0));
  exit(0);
}
// source: 921202-1.c
/* { dg-require-effective-target untyped_assembly } */
/* { dg-add-options stack_size } */

#ifndef STACK_SIZE
#define	VLEN	2055
#else
#define VLEN ((STACK_SIZE/16) - 1)
#endif
main ()
{
  long dx[VLEN+1];
  long dy[VLEN+1];
  long s1[VLEN];
  int cyx, cyy;
  int i;
  long size;

  for (;;)
    {
      size = VLEN;
      mpn_random2 (s1, size);

      for (i = 0; i < 1; i++)
	;

      dy[size] = 0x12345678;

      for (i = 0; i < 1; i++)
	cyy = mpn_mul_1 (dy, s1, size);

      if (cyx != cyy || mpn_cmp (dx, dy, size + 1) != 0 || dx[size] != 0x12345678)
	{
	  foo ("", 8, cyy); mpn_print (dy, size);
	}
      exxit();
    }
}

foo (){}
mpn_mul_1(){}
mpn_print (){}
mpn_random2(){}
mpn_cmp(){}
exxit(){exit(0);}
// source: 921202-2.c
int
f(long long x)
{
  x >>= 8;
  return x & 0xff;
}

main()
{
  if (f(0x0123456789ABCDEFLL) != 0xCD)
    abort();
  exit (0);
}
// source: 921204-1.c
/* The bit-field below would have a problem if __INT_MAX__ is too
   small.  */
#if __INT_MAX__ < 2147483647
int
main (void)
{
  exit (0);
}
#else
typedef struct {
  unsigned b0:1, f1:17, b18:1, b19:1, b20:1, f2:11;
} bf;

typedef union {
  bf b;
  unsigned w;
} bu;

bu
f(bu i)
{
  bu o = i;

  if (o.b.b0)
    o.b.b18 = 1,
    o.b.b20 = 1;
  else
    o.b.b18 = 0,
    o.b.b20 = 0;

  return o;
}

main()
{
  bu a;
  bu r;

  a.w = 0x4000000;
  a.b.b0 = 0;
  r = f(a);
  if (a.w != r.w)
    abort();
  exit(0);
}
#endif
// source: 921207-1.c
f()
{
  unsigned b = 0;

  if (b > ~0U)
    b = ~0U;

  return b;
}
main()
{
  if (f()!=0)
    abort();
  exit (0);
}
// source: 921208-1.c
double
f(double x)
{
  return x*x;
}

double
Int(double (*f)(double), double a)
{
  return (*f)(a);
}

main()
{
  if (Int(&f,2.0) != 4.0)
    abort();
  exit (0);
}
// source: 921208-2.c
/* { dg-require-effective-target untyped_assembly } */
/* { dg-require-stack-size "100000 * 4 + 1024" } */

g(){}

f()
{
  int i;
  float a[100000];

  for (i = 0; i < 1; i++)
    {
      g(1.0, 1.0 + i / 2.0 * 3.0);
      g(2.0, 1.0 + i / 2.0 * 3.0);
    }
}

main ()
{
  f();
  exit(0);
}
// source: 921215-1.c
/* { dg-require-effective-target trampolines } */

main()
{
  void p(void ((*f) (void ())))
    {
      void r()
	{
	  foo ();
	}

      f(r);
    }

  void q(void ((*f)()))
    {
      f();
    }

  p(q);

  exit(0);
}

foo(){}
// source: 921218-1.c
f()
{
  return (unsigned char)("\377"[0]);
}

main()
{
  if (f() != (unsigned char)(0377))
    abort();
  exit (0);
}
// source: 921218-2.c
f()
{
  long l2;
  unsigned short us;
  unsigned long ul;
  short s2;

  ul = us = l2 = s2 = -1;
  return ul;
}

main()
{
  if (f()!=(unsigned short)-1)
    abort();
  exit(0);
}
// source: 930106-1.c
/* { dg-add-options stack_size } */

#if defined (STACK_SIZE)
#define DUMMY_SIZE 9
#else
#define DUMMY_SIZE 399999
#endif

double g()
{
  return 1.0;
}

f()
{
  char dummy[DUMMY_SIZE];
  double f1, f2, f3;
  f1 = g();
  f2 = g();
  f3 = g();
  return f1 + f2 + f3;
}

main()
{
  if (f() != 3.0)
    abort();
  exit(0);
}
// source: 930111-1.c
main()
{
  if (wwrite((long long) 0) != 123)
    abort();
  exit(0);
}

int
wwrite(long long i)
{
  switch(i)
    {
    case 3:
    case 10:
    case 23:
    case 28:
    case 47:
      return 0;
    default:
      return 123;
    }
}
// source: 930123-1.c
f(int *x)
{
  *x = 0;
}

main()
{
  int s, c, x;
  char a[] = "c";

  f(&s);
  a[c = 0] = s == 0 ? (x=1, 'a') : (x=2, 'b');
  if (a[c] != 'a')
    abort();
  exit (0);
}
// source: 930126-1.c
struct s {
  unsigned long long a:8, b:32;
};

struct s
f(struct s x)
{
  x.b = 0xcdef1234;
  return x;
}

main()
{
  static struct s i;
  i.a = 12;
  i = f(i);
  if (i.a != 12 || i.b != 0xcdef1234)
    abort();
  exit(0);
}
// source: 930208-1.c
typedef union {
  long l;
  struct { char b3, b2, b1, b0; } c;
} T;

f (T u)
{
  ++u.c.b0;
  ++u.c.b3;
  return (u.c.b1 != 2 || u.c.b2 != 2);
}

main ()
{
  T u;
  u.c.b1 = 2;
  u.c.b2 = 2;
  u.c.b0 = ~0;
  u.c.b3 = ~0;
  if (f (u))
    abort();
  exit (0);
}
// source: 930406-1.c
/* { dg-add-options stack_size } */

f()
{
  int x = 1;
#if defined(STACK_SIZE)
  char big[STACK_SIZE/2];
#else
  char big[0x1000];
#endif

  ({
    __label__ mylabel;
  mylabel:
    x++;
    if (x != 3)
      goto mylabel;
  });
  exit(0);
}

main()
{
  f();
}
// source: 930408-1.c
typedef enum foo E;
enum foo { e0, e1 };

struct {
  E eval;
} s;

p()
{
  abort();
}

f()
{
  switch (s.eval)
    {
    case e0:
      p();
    }
}

main()
{
  s.eval = e1;
  f();
  exit(0);
}
// source: 930429-1.c
char *
f (char *p)
{
  short x = *p++ << 16;
  return p;
}

main ()
{
  char *p = "";
  if (f (p) != p + 1)
    abort ();
  exit (0);
}
// source: 930429-2.c
int
f (b)
{
  return (b >> 1) > 0;
}

main ()
{
  if (!f (9))
    abort ();
  if (f (-9))
    abort ();
  exit (0);
}
// source: 930513-1.c
/* { dg-additional-options "-Wl,-u,_printf_float" { target newlib_nano_io } } */

#include <stdio.h>
char buf[2];

f (fp)
     int (*fp)(char *, const char *, ...);
{
  (*fp)(buf, "%.0f", 5.0);
}

main ()
{
  f (&sprintf);
  if (buf[0] != '5' || buf[1] != 0)
    abort ();
  exit (0);
}
// source: 930513-2.c
sub3 (i)
     const int *i;
{
}

eq (a, b)
{
  static int i = 0;
  if (a != i)
    abort ();
  i++;
}

main ()
{
  int i;

  for (i = 0; i < 4; i++)
    {
      const int j = i;
      int k;
      sub3 (&j);
      k = j;
      eq (k, k);
    }
  exit (0);
}
// source: 930518-1.c
int bar = 0;

f (p)
     int *p;
{
  int foo = 2;

  while (foo > bar)
    {
      foo -=  bar;
      *p++ = foo;
      bar = 1;
    }
}

main ()
{
  int tab[2];
  tab[0] = tab[1] = 0;
  f (tab);
  if (tab[0] != 2 || tab[1] != 1)
    abort ();
  exit (0);
}
// source: 930526-1.c
/* { dg-options "-fgnu89-inline" } */

extern void exit (int);

inline void
f (int x)
{
  int *(p[25]);
  int m[25*7];
  int i;

  for (i = 0; i < 25; i++)
    p[i] = m + x*i;

  p[1][0] = 0;
}

int
main ()
{
  f (7);
  exit (0);
}
// source: 930527-1.c
f (unsigned char x)
{
  return (0x50 | (x >> 4)) ^ 0xff;
}

main ()
{
  if (f (0) != 0xaf)
    abort ();
  exit (0);
}
// source: 930529-1.c
/* { dg-options { "-fwrapv" } } */

extern void abort (void);
extern void exit (int);

int dd (int x, int d) { return x / d; }

int
main ()
{
  int i;
  for (i = -3; i <= 3; i++)
    {
      if (dd (i, 1) != i / 1)
	abort ();
      if (dd (i, 2) != i / 2)
	abort ();
      if (dd (i, 3) != i / 3)
	abort ();
      if (dd (i, 4) != i / 4)
	abort ();
      if (dd (i, 5) != i / 5)
	abort ();
      if (dd (i, 6) != i / 6)
	abort ();
      if (dd (i, 7) != i / 7)
	abort ();
      if (dd (i, 8) != i / 8)
	abort ();
    }
  for (i = ((unsigned) ~0 >> 1) - 3; i <= ((unsigned) ~0 >> 1) + 3; i++)
    {
      if (dd (i, 1) != i / 1)
	abort ();
      if (dd (i, 2) != i / 2)
	abort ();
      if (dd (i, 3) != i / 3)
	abort ();
      if (dd (i, 4) != i / 4)
	abort ();
      if (dd (i, 5) != i / 5)
	abort ();
      if (dd (i, 6) != i / 6)
	abort ();
      if (dd (i, 7) != i / 7)
	abort ();
      if (dd (i, 8) != i / 8)
	abort ();
    }
  exit (0);
}
// source: 930603-1.c
float fx (x)
     float x;
{
  return 1.0 + 3.0 / (2.302585093 * x);
}

main ()
{
  float fx (), inita (), initc (), a, b, c;
  a = inita ();
  c = initc ();
  f ();
  b = fx (c) + a;
  f ();
  if (a != 3.0 || b < 4.3257 || b > 4.3258 || c != 4.0)
    abort ();
  exit (0);
}

float inita () { return 3.0; }
float initc () { return 4.0; }
f () {}
// source: 930603-2.c
int w[2][2];

f ()
{
  int i, j;

  for (i = 0; i < 2; i++)
    for (j = 0; j < 2; j++)
      if (i == j)
	w[i][j] = 1;
}

main ()
{
  f ();
  if (w[0][0] != 1 || w[1][1] != 1 || w[1][0] != 0 || w[0][1] != 0)
    abort ();
  exit (0);
}
// source: 930603-3.c
f (b, c)
     unsigned char *b;
     int c;
{
  unsigned long v = 0;
  switch (c)
    {
    case 'd':
      v = ((unsigned long)b[0] << 8) + b[1];
      v >>= 9;
      break;

    case 'k':
      v = b[3] >> 4;
      break;

    default:
      abort ();
    }

  return v;
}
main ()
{
  char buf[4];
  buf[0] = 170; buf[1] = 5;
  if (f (buf, 'd') != 85)
    abort ();
  exit (0);
}
// source: 930608-1.c
double f (double a) {}
double (* const a[]) (double) = {&f};

main ()
{
  double (*p) ();
  p = &f;
  if (p != a[0])
    abort ();
  exit (0);
}
// source: 930614-1.c
f (double *ty)
{
  *ty = -1.0;
}

main ()
{
  double foo[6];
  double tx = 0.0, ty, d;

  f (&ty);

  if (ty < 0)
    ty = -ty;
  d = (tx > ty) ? tx : ty;
  if (ty != d)
    abort ();
  exit (0);
}
// source: 930614-2.c
main ()
{
  int i, j, k, l;
  float x[8][2][8][2];

  for (i = 0; i < 8; i++)
    for (j = i; j < 8; j++)
      for (k = 0; k < 2; k++)
	for (l = 0; l < 2; l++)
	  {
	    if ((i == j) && (k == l))
	      x[i][k][j][l] = 0.8;
	    else
	      x[i][k][j][l] = 0.8;
	    if (x[i][k][j][l] < 0.0)
	      abort ();
	  }

  exit (0);
}
// source: 930621-1.c
/* The bit-field below would have a problem if __INT_MAX__ is too
   small.  */
#if __INT_MAX__ < 2147483647
int
main (void)
{
  exit (0);
}
#else
f ()
{
  struct {
    int x : 18;
    int y : 14;
  } foo;

  foo.x = 10;
  foo.y = 20;

  return foo.y;
}

main ()
{
  if (f () != 20)
    abort ();
  exit (0);
}
#endif
// source: 930622-1.c
int a = 1, b;

g () { return 0; }
h (x) {}

f ()
{
  if (g () == -1)
    return 0;
  a = g ();
  if (b >= 1)
    h (a);
  return 0;
}

main ()
{
  f ();
  if (a != 0)
    abort ();
  exit (0);
}
// source: 930622-2.c
long double
ll_to_ld (long long n)
{
  return n;
}

long long
ld_to_ll (long double n)
{
  return n;
}

main ()
{
  long long n;

  if (ll_to_ld (10LL) != 10.0)
    abort ();

  if (ld_to_ll (10.0) != 10)
    abort ();

  exit (0);
}
// source: 930628-1.c
f (double x[2], double y[2])
{
  if (x == y)
    abort ();
}

main ()
{
  struct { int f[3]; double x[1][2]; } tp[4][2];
  int i, j, ki, kj, mi, mj;
  float bdm[4][2][4][2];

  for (i = 0; i < 4; i++)
    for (j = i; j < 4; j++)
      for (ki = 0; ki < 2; ki++)
	for (kj = 0; kj < 2; kj++)
	  if ((j == i) && (ki == kj))
	    bdm[i][ki][j][kj] = 1000.0;
	  else
	    {
	      for (mi = 0; mi < 1; mi++)
		for (mj = 0; mj < 1; mj++)
		  f (tp[i][ki].x[mi], tp[j][kj].x[mj]);
	      bdm[i][ki][j][kj] = 1000.0;
	    }
  exit (0);
}
// source: 930630-1.c
/* The bit-field below would have a problem if __INT_MAX__ is too
   small.  */
#if __INT_MAX__ < 2147483647
int
main (void)
{
  exit (0);
}
#else
main ()
{
  struct
    {
      signed int bf0:17;
      signed int bf1:7;
    } bf;

  bf.bf1 = 7;
  f (bf.bf1);
  exit (0);
}

f (x)
     int x;
{
  if (x != 7)
    abort ();
}
#endif
// source: 930702-1.c
fp (double a, int b)
{
  if (a != 33 || b != 11)
    abort ();
}

main ()
{
  int (*f) (double, int) = fp;

  fp (33, 11);
  f (33, 11);
  exit (0);
}
// source: 930713-1.c
typedef struct
{
  char x;
} T;

T
f (s1)
     T s1;
{
  T s1a;
  s1a.x = 17;
  return s1a;
}

main ()
{
  T s1a, s1b;
  s1a.x = 13;
  s1b = f (s1a);
  if (s1a.x != 13 || s1b.x != 17)
    abort ();
  exit (0);
}
// source: 930718-1.c
typedef struct rtx_def
{
  int f1 :1;
  int f2 :1;
} *rtx;

static rtx
f (orig)
     register rtx orig;
{
  if (orig->f1 || orig->f2)
    return orig;
  orig->f2 = 1;
  return orig;
}

void
f2 ()
{
  abort ();
}

main ()
{
  struct rtx_def foo;
  rtx bar;

  foo.f1 = 1;
  foo.f2 = 0;
  bar = f (&foo);
  if (bar != &foo || bar->f2 != 0)
    abort ();
  exit (0);
}
// source: 930719-1.c
int
f (foo, bar, com)
{
  unsigned align;
  if (foo)
    return 0;
  while (1)
    {
      switch (bar)
	{
	case 1:
	  if (com != 0)
	    return align;
	  *(char *) 0 = 0;
	}
    }
}

main ()
{
  f (0, 1, 1);
  exit (0);
}
// source: 930725-1.c
int v;

char *
g ()
{
  return "";
}

char *
f ()
{
  return (v == 0 ? g () : "abc");
}

main ()
{
  v = 1;
  if (!strcmp (f (), "abc"))
    exit (0);
  abort();
}
// source: 930818-1.c
static double one = 1.0;

f()
{
  int colinear;
  colinear = (one == 0.0);
  if (colinear)
    abort ();
  return colinear;
}
main()
{
  if (f()) abort();
  exit (0);
}
// source: 930916-1.c
f (n)
     unsigned n;
{
  if ((int) n >= 0)
    abort ();
}

main ()
{
  unsigned x = ~0;
  f (x);
  exit (0);
}
// source: 930921-1.c
f (x)
     unsigned x;
{
  return (unsigned) (((unsigned long long) x * 0xAAAAAAAB) >> 32) >> 1;
}

main ()
{
  unsigned i;

  for (i = 0; i < 10000; i++)
    if (f (i) != i / 3)
      abort ();
  exit (0);
}
// source: 930929-1.c
sub1 (i)
     int i;
{
  return i - (5 - i);
}

sub2 (i)
     int i;
{
  return i + (5 + i);
}

sub3 (i)
     int i;
{
  return i - (5 + i);
}

sub4 (i)
     int i;
{
  return i + (5 - i);
}

main()
{
  if (sub1 (20) != 35)
    abort ();
  if (sub2 (20) != 45)
    abort ();
  if (sub3 (20) != -5)
    abort ();
  if (sub4 (20) != 5)
    abort ();
  exit (0);
}
// source: 930930-1.c
__extension__ typedef __PTRDIFF_TYPE__ ptr_t;
ptr_t *wm_TR;
ptr_t *wm_HB;
ptr_t *wm_SPB;

ptr_t mem[100];

f (mr_TR, mr_SPB, mr_HB, reg1, reg2)
     ptr_t *mr_TR;
     ptr_t *mr_SPB;
     ptr_t *mr_HB;
     ptr_t *reg1;
     ptr_t *reg2;
{
  ptr_t *x = mr_TR;

  for (;;)
    {
      if (reg1 < reg2)
	goto out;
      if ((ptr_t *) *reg1 < mr_HB && (ptr_t *) *reg1 >= mr_SPB)
	*--mr_TR = *reg1;
      reg1--;
    }
 out:

  if (x != mr_TR)
    abort ();
}

main ()
{
  mem[99] = (ptr_t) mem;
  f (mem + 100, mem + 6, mem + 8, mem + 99, mem + 99);
  exit (0);
}
// source: 930930-2.c
int
test_endianness()
{
  union doubleword
    {
      double d;
      unsigned long u[2];
    } dw;
  dw.d = 10;
  return dw.u[0] != 0 ? 1 : 0;
}

int
test_endianness_vol()
{
  union doubleword
    {
      volatile double d;
      volatile long u[2];
    } dw;
  dw.d = 10;
  return dw.u[0] != 0 ? 1 : 0;
}

main ()
{
  if (test_endianness () != test_endianness_vol ())
    abort ();
  exit (0);
}
// source: 931002-1.c
/* { dg-require-effective-target trampolines } */

f (void (*func) ())
{
  func ();
}

main ()
{
  void t0 ()
    {
    }

  void t1 ()
    {
      f (t0);
    }

  void t2 ()
    {
      t1 ();
    }

  t1 ();
  t1 ();
  t2 ();

  exit (0);
}
// source: 931004-1.c
struct tiny
{
  int c;
};

f (int n, struct tiny x, struct tiny y, struct tiny z, long l)
{
  if (x.c != 10)
    abort();

  if (y.c != 11)
    abort();

  if (z.c != 12)
    abort();

  if (l != 123)
    abort ();
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: 931004-10.c
#include <stdarg.h>

struct tiny
{
  char c;
  char d;
};

f (int n, ...)
{
  struct tiny x;
  int i;

  va_list ap;
  va_start (ap,n);
  for (i = 0; i < n; i++)
    {
      x = va_arg (ap,struct tiny);
      if (x.c != i + 10)
	abort();
      if (x.d != i + 20)
	abort();
    }
  {
    long x = va_arg (ap, long);
    if (x != 123)
      abort();
  }
  va_end (ap);
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  x[0].d = 20;
  x[1].d = 21;
  x[2].d = 22;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: 931004-11.c
struct tiny
{
  char c;
  char d;
  char e;
};

f (int n, struct tiny x, struct tiny y, struct tiny z, long l)
{
  if (x.c != 10)
    abort();
  if (x.d != 20)
    abort();
  if (x.e != 30)
    abort();

  if (y.c != 11)
    abort();
  if (y.d != 21)
    abort();
  if (y.e != 31)
    abort();

  if (z.c != 12)
    abort();
  if (z.d != 22)
    abort();
  if (z.e != 32)
    abort();

  if (l != 123)
    abort ();
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  x[0].d = 20;
  x[1].d = 21;
  x[2].d = 22;
  x[0].e = 30;
  x[1].e = 31;
  x[2].e = 32;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: 931004-12.c
#include <stdarg.h>

struct tiny
{
  char c;
  char d;
  char e;
};

f (int n, ...)
{
  struct tiny x;
  int i;

  va_list ap;
  va_start (ap,n);
  for (i = 0; i < n; i++)
    {
      x = va_arg (ap,struct tiny);
      if (x.c != i + 10)
	abort();
      if (x.d != i + 20)
	abort();
      if (x.e != i + 30)
	abort();
    }
  {
    long x = va_arg (ap, long);
    if (x != 123)
      abort();
  }
  va_end (ap);
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  x[0].d = 20;
  x[1].d = 21;
  x[2].d = 22;
  x[0].e = 30;
  x[1].e = 31;
  x[2].e = 32;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: 931004-13.c
struct tiny
{
  char c;
  char d;
  char e;
  char f;
};

f (int n, struct tiny x, struct tiny y, struct tiny z, long l)
{
  if (x.c != 10)
    abort();
  if (x.d != 20)
    abort();
  if (x.e != 30)
    abort();
  if (x.f != 40)
    abort();

  if (y.c != 11)
    abort();
  if (y.d != 21)
    abort();
  if (y.e != 31)
    abort();
  if (y.f != 41)
    abort();

  if (z.c != 12)
    abort();
  if (z.d != 22)
    abort();
  if (z.e != 32)
    abort();
  if (z.f != 42)
    abort();

  if (l != 123)
    abort ();
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  x[0].d = 20;
  x[1].d = 21;
  x[2].d = 22;
  x[0].e = 30;
  x[1].e = 31;
  x[2].e = 32;
  x[0].f = 40;
  x[1].f = 41;
  x[2].f = 42;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: 931004-14.c
#include <stdarg.h>

struct tiny
{
  char c;
  char d;
  char e;
  char f;
};

f (int n, ...)
{
  struct tiny x;
  int i;

  va_list ap;
  va_start (ap,n);
  for (i = 0; i < n; i++)
    {
      x = va_arg (ap,struct tiny);
      if (x.c != i + 10)
	abort();
      if (x.d != i + 20)
	abort();
      if (x.e != i + 30)
	abort();
      if (x.f != i + 40)
	abort();
    }
  {
    long x = va_arg (ap, long);
    if (x != 123)
      abort();
  }
  va_end (ap);
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  x[0].d = 20;
  x[1].d = 21;
  x[2].d = 22;
  x[0].e = 30;
  x[1].e = 31;
  x[2].e = 32;
  x[0].f = 40;
  x[1].f = 41;
  x[2].f = 42;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: 931004-2.c
#include <stdarg.h>

struct tiny
{
  int c;
};

f (int n, ...)
{
  struct tiny x;
  int i;

  va_list ap;
  va_start (ap,n);
  for (i = 0; i < n; i++)
    {
      x = va_arg (ap,struct tiny);
      if (x.c != i + 10)
	abort();
    }
  {
    long x = va_arg (ap, long);
    if (x != 123)
      abort();
  }
  va_end (ap);
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: 931004-3.c
struct tiny
{
  short c;
};

f (int n, struct tiny x, struct tiny y, struct tiny z, long l)
{
  if (x.c != 10)
    abort();

  if (y.c != 11)
    abort();

  if (z.c != 12)
    abort();

  if (l != 123)
    abort ();
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: 931004-4.c
#include <stdarg.h>

struct tiny
{
  short c;
};

f (int n, ...)
{
  struct tiny x;
  int i;

  va_list ap;
  va_start (ap,n);
  for (i = 0; i < n; i++)
    {
      x = va_arg (ap,struct tiny);
      if (x.c != i + 10)
	abort();
    }
  {
    long x = va_arg (ap, long);
    if (x != 123)
      abort();
  }
  va_end (ap);
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: 931004-5.c
struct tiny
{
  short c;
  short d;
};

f (int n, struct tiny x, struct tiny y, struct tiny z, long l)
{
  if (x.c != 10)
    abort();
  if (x.d != 20)
    abort();

  if (y.c != 11)
    abort();
  if (y.d != 21)
    abort();

  if (z.c != 12)
    abort();
  if (z.d != 22)
    abort();

  if (l != 123)
    abort ();
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  x[0].d = 20;
  x[1].d = 21;
  x[2].d = 22;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: 931004-6.c
#include <stdarg.h>

struct tiny
{
  short c;
  short d;
};

f (int n, ...)
{
  struct tiny x;
  int i;

  va_list ap;
  va_start (ap,n);
  for (i = 0; i < n; i++)
    {
      x = va_arg (ap,struct tiny);
      if (x.c != i + 10)
	abort();
      if (x.d != i + 20)
	abort();
    }
  {
    long x = va_arg (ap, long);
    if (x != 123)
      abort();
  }
  va_end (ap);
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  x[0].d = 20;
  x[1].d = 21;
  x[2].d = 22;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: 931004-7.c
struct tiny
{
  char c;
};

f (int n, struct tiny x, struct tiny y, struct tiny z, long l)
{
  if (x.c != 10)
    abort();

  if (y.c != 11)
    abort();

  if (z.c != 12)
    abort();

  if (l != 123)
    abort ();
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: 931004-8.c
#include <stdarg.h>

struct tiny
{
  char c;
};

f (int n, ...)
{
  struct tiny x;
  int i;

  va_list ap;
  va_start (ap,n);
  for (i = 0; i < n; i++)
    {
      x = va_arg (ap,struct tiny);
      if (x.c != i + 10)
	abort();
    }
  {
    long x = va_arg (ap, long);
    if (x != 123)
      abort();
  }
  va_end (ap);
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: 931004-9.c
struct tiny
{
  char c;
  char d;
};

f (int n, struct tiny x, struct tiny y, struct tiny z, long l)
{
  if (x.c != 10)
    abort();
  if (x.d != 20)
    abort();

  if (y.c != 11)
    abort();
  if (y.d != 21)
    abort();

  if (z.c != 12)
    abort();
  if (z.d != 22)
    abort();

  if (l != 123)
    abort ();
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  x[0].d = 20;
  x[1].d = 21;
  x[2].d = 22;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: 931005-1.c
typedef struct
{
  char x;
} T;

T
f (s1)
     T s1;
{
  T s1a;
  s1a.x = s1.x;
  return s1a;
}

main ()
{
  T s1a, s1b;
  s1a.x = 100;
  s1b = f (s1a);
  if (s1b.x != 100)
    abort ();
  exit (0);
}
// source: 931009-1.c
main ()
{
  f ();
  exit (0);
}

static
g (out, size, lo, hi)
     int *out, size, lo, hi;
{
  int j;

  for (j = 0; j < size; j++)
    out[j] = j * (hi - lo);
}


f ()
{
  int a[2];

  g (a, 2, 0, 1);

  if (a[0] != 0 || a[1] != 1)
    abort ();
}
// source: 931012-1.c
f (int b, int c)
{
  if (b != 0 && b != 1 && c != 0)
    b = 0;
  return b;
}

main ()
{
  if (!f (1, 2))
    abort();
  exit(0);
}
// source: 931017-1.c
int v;

main ()
{
  f ();
  exit (0);
}

h1 ()
{
  return 0;
}

h2 (e)
     int *e;
{
  if (e != &v)
    abort ();
  return 0;
}

g (c)
     char *c;
{
  int i;
  int b;

  do
    {
      i = h1 ();
      if (i == -1)
	return 0;
      else if (i == 1)
	h1 ();
    }
  while (i == 1);

  do
    b = h2 (&v);
  while (i == 5);

  if (i != 2)
    return b;
  *c = 'a';

  return 0;
}


f ()
{
  char c;
  g (&c);
}
// source: 931018-1.c
unsigned int a[0x1000];
extern const unsigned long v;

main ()
{
  f (v);
  f (v);
  exit (0);
}

f (a)
     unsigned long a;
{
  if (a != 0xdeadbeefL)
    abort();
}

const unsigned long v = 0xdeadbeefL;
// source: 931031-1.c
/* The bit-field below would have a problem if __INT_MAX__ is too
   small.  */
#if __INT_MAX__ < 2147483647
int
main (void)
{
  exit (0);
}
#else
struct foo
{
  unsigned y:1;
  unsigned x:32;
};

int
f (x)
     struct foo x;
{
  int t = x.x;
  if (t < 0)
    return 1;
  return t+1;
}

main ()
{
  struct foo x;
  x.x = -1;
  if (f (x) == 0)
    abort ();
  exit (0);
}
#endif
// source: 931102-1.c
typedef union
{
  struct
    {
      char h, l;
    } b;
} T;

f (x)
     int x;
{
  int num = 0;
  T reg;

  reg.b.l = x;
  while ((reg.b.l & 1) == 0)
    {
      num++;
      reg.b.l >>= 1;
    }
  return num;
}

main ()
{
  if (f (2) != 1)
    abort ();
  exit (0);
}
// source: 931102-2.c
typedef union
{
  long align;
  struct
    {
      short h, l;
    } b;
} T;

f (x)
     int x;
{
  int num = 0;
  T reg;

  reg.b.l = x;
  while ((reg.b.l & 1) == 0)
    {
      num++;
      reg.b.l >>= 1;
    }
  return num;
}

main ()
{
  if (f (2) != 1)
    abort ();
  exit (0);
}
// source: 931110-1.c
typedef struct
{
  short f:3, g:3, h:10;
} small;

struct
{
  int i;
  small s[10];
} x;

main ()
{
  int i;
  for (i = 0; i < 10; i++)
    x.s[i].f = 0;
  exit (0);
}
// source: 931110-2.c
main ()
{
  static int a[] = {3, 4};
  register int *b;
  int c;

  b = a;
  c = *b++ % 8;
  if (c != 3)
    abort ();
  exit (0);
}
// source: 931208-1.c
f ()
{
  unsigned long x, y = 1;

  x = ((y * 8192) - 216) / 16;
  return x;
}

main ()
{
  if (f () != 498)
    abort ();
  exit (0);
}
// source: 931228-1.c
f (x)
{
  x &= 010000;
  x &= 007777;
  x ^= 017777;
  x &= 017770;
  return x;
}

main ()
{
  if (f (-1) != 017770)
    abort ();
  exit (0);
}
// source: 940115-1.c
f (cp, end)
     char *cp;
     char *end;
{
  return (cp < end);
}

main ()
{
  if (! f ((char *) 0, (char *) 1))
    abort();
  exit (0);
}
// source: 940122-1.c
char *a = 0;
char *b = 0;

g (x)
     int x;
{
  if ((!!a) != (!!b))
    abort ();
}

f (x)
     int x;
{
  g (x * x);
}

main ()
{
  f (100);
  exit (0);
}
// source: 941014-1.c
int f (int a, int b) { }

main ()
{
  unsigned long addr1;
  unsigned long addr2;

  addr1 = (unsigned long) &f;
  addr1 += 5;
  addr2 = 5 + (unsigned long) &f;

  if (addr1 != addr2)
    abort ();
  exit (0);
}
// source: 941014-2.c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
  unsigned short a;
  unsigned short b;
} foo_t;

void a1 (unsigned long offset) {}

volatile foo_t *
f ()
{
  volatile foo_t *foo_p = (volatile foo_t *)malloc (sizeof (foo_t));

  a1((unsigned long)foo_p-30);
  if (foo_p->a & 0xf000)
    printf("%d\n", foo_p->a);
  foo_p->b = 0x0100;
  a1 ((unsigned long)foo_p + 2);
  a1 ((unsigned long)foo_p - 30);
  return foo_p;
}

main ()
{
  volatile foo_t *foo_p;

  foo_p = f ();
  if (foo_p->b != 0x0100)
    abort ();
  exit (0);
}
// source: 941015-1.c
int
foo1 (value)
     long long value;
{
  register const long long constant = 0xc000000080000000LL;

  if (value < constant)
    return 1;
  else
    return 2;
}

int
foo2 (value)
     unsigned long long value;
{
  register const unsigned long long constant = 0xc000000080000000LL;

  if (value < constant)
    return 1;
  else
    return 2;
}

main ()
{
  unsigned long long value = 0xc000000000000001LL;
  int x, y;

  x = foo1 (value);
  y = foo2 (value);
  if (x != y || x != 1)
    abort ();
  exit (0);
}
// source: 941021-1.c
double glob_dbl;

f (pdbl, value)
     double *pdbl;
     double value;
{
  if (pdbl == 0)
    pdbl = &glob_dbl;

  *pdbl = value;
}

main ()
{
  f ((void *) 0, 55.1);

  if (glob_dbl != 55.1)
    abort ();
  exit (0);
}
// source: 941025-1.c
long f (x, y)
     long x,y;
{
  return (x > 1) ? y : (y & 1);
}

main ()
{
  if (f (2L, 0xdecadeL) != 0xdecadeL)
    abort ();
  exit (0);
}
// source: 941031-1.c
typedef long mpt;

int
f (mpt us, mpt vs)
{
  long aus;
  long avs;

  aus = us >= 0 ? us : -us;
  avs = vs >= 0 ? vs : -vs;

  if (aus < avs)
    {
      long t = aus;
      aus = avs;
      avs = aus;
    }

  return avs;
}

main ()
{
  if (f ((mpt) 3, (mpt) 17) != 17)
    abort ();
  exit (0);
}
// source: 941101-1.c
f ()
{
  int var = 7;

  if ((var/7) == 1)
    return var/7;
  return 0;
}

main ()
{
  if (f () != 1)
    abort ();
  exit (0);
}
// source: 941110-1.c
f (const int x)
{
  int y = 0;
  y = x ? y : -y;
  {
    const int *p = &x;
  }
  return y;
}

main ()
{
  if (f (0))
    abort ();
  exit (0);
}
// source: 941202-1.c
/* { dg-skip-if "requires alloca" { ! alloca } { "-O0" } { "" } } */
g (x, y)
{
  if (x != 3)
    abort ();
}

static inline
f (int i)
{
  int *tmp;

  tmp = (int *) alloca (sizeof (i));
  *tmp = i;
  g (*tmp, 0);
}

main ()
{
  f (3);
  exit (0);
};
// source: 950221-1.c
/* { dg-add-options stack_size } */

struct parsefile
{
  long fd;
  char *buf;
};
struct parsefile basepf;
struct parsefile *parsefile = &basepf;
#ifdef STACK_SIZE
int filler[STACK_SIZE / (2*sizeof(int))];
#else
int filler[0x3000];
#endif
int el;

char *
g1 (a, b)
     int a;
     int *b;
{
}

g2 (a)
     long a;
{
  if (a != 0xdeadbeefL)
    abort ();
  exit (0);
}

f ()
{
  register char *p, *q;
  register int i;
  register int something;

  if (parsefile->fd == 0L && el)
    {
      const char *rl_cp;
      int len;
      rl_cp = g1 (el, &len);
      strcpy (p, rl_cp);
    }
  else
    {
    alabel:
      i = g2 (parsefile->fd);
    }
}

main ()
{
  el = 0;
  parsefile->fd = 0xdeadbeefL;
  f ();
}
// source: 950322-1.c
f (unsigned char *a)
{
  int i, j;
  int x, y;

  j = a[1];
  i = a[0] - j;
  if (i < 0)
    {
      x = 1;
      y = -i;
    }
  else
    {
      x = 0;
      y =  i;
    }
  return x + y;
}


main ()
{
  unsigned char a[2];
  a[0] = 8;
  a[1] = 9;
  if (f (a) != 2)
    abort ();
  exit (0);
}
// source: 950426-1.c

struct tag {
  int m1;
  char *m2[5];
} s1, *p1;

int i;

main()
{
  s1.m1 = -1;
  p1 = &s1;

  if ( func1( &p1->m1 ) == -1 )
    foo ("ok");
  else
    abort ();

  i = 3;
  s1.m2[3]= "123";

  if ( strlen( (p1->m2[i])++ ) == 3 )
    foo ("ok");
  else
    abort ();

  exit (0);
}

func1(int *p) { return(*p); }

foo (char *s) {}
// source: 950426-2.c
main()
{
  long int i = -2147483647L - 1L; /* 0x80000000 */
  char ca = 1;

  if (i >> ca != -1073741824L)
    abort ();

  if (i >> i / -2000000000L != -1073741824L)
    abort ();

  exit (0);
}
// source: 950503-1.c
main ()
{
  int tmp;
  unsigned long long utmp1, utmp2;

  tmp = 16;

  utmp1 = (~((unsigned long long) 0)) >> tmp;
  utmp2 = (~((unsigned long long) 0)) >> 16;

  if (utmp1 != utmp2)
    abort ();
  exit (0);
}
// source: 950511-1.c
main ()
{
  unsigned long long xx;
  unsigned long long *x = (unsigned long long *) &xx;

  *x = -3;
  *x = *x * *x;
  if (*x != 9)
    abort ();
  exit (0);
}
// source: 950512-1.c
unsigned
f1 (x)
{
  return ((unsigned) (x != 0) - 3) / 2;
}

unsigned long long
f2 (x)
{
  return ((unsigned long long) (x != 0) - 3) / 2;
}

main ()
{
  if (f1 (1) != (~(unsigned) 0) >> 1)
    abort ();
  if (f1 (0) != ((~(unsigned) 0) >> 1) - 1)
    abort ();
  if (f2 (1) != (~(unsigned long long) 0) >> 1)
    abort ();
  if (f2 (0) != ((~(unsigned long long) 0) >> 1) - 1)
    abort ();
  exit (0);
}
// source: 950605-1.c
f (c)
    unsigned char c;
{
  if (c != 0xFF)
    abort ();
}

main ()
{
  f (-1);
  exit (0);
}
// source: 950607-1.c
main ()
{
  struct { long status; } h;

  h.status = 0;
  if (((h.status & 128) == 1) && ((h.status & 32) == 0))
    abort ();
  exit (0);
}
// source: 950607-2.c
typedef struct {
  long int p_x, p_y;
} Point;

int
f (Point basePt, Point pt1, Point pt2)
{
  long long vector;

  vector =
    (long long) (pt1.p_x - basePt.p_x) * (long long) (pt2.p_y - basePt.p_y) -
      (long long) (pt1.p_y - basePt.p_y) * (long long) (pt2.p_x - basePt.p_x);

  if (vector > (long long) 0)
    return 0;
  else if (vector < (long long) 0)
    return 1;
  else
    return 2;
}

main ()
{
  Point b, p1, p2;
  int answer;

  b.p_x = -23250;
  b.p_y = 23250;

  p1.p_x = 23250;
  p1.p_y = -23250;

  p2.p_x = -23250;
  p2.p_y = -23250;

  answer = f (b, p1, p2);

  if (answer != 1)
    abort ();
  exit (0);
}
// source: 950612-1.c
unsigned int
f1 (int diff)
{
  return ((unsigned int) (diff < 0 ? -diff : diff));
}

unsigned int
f2 (unsigned int diff)
{
  return ((unsigned int) ((signed int) diff < 0 ? -diff : diff));
}

unsigned long long
f3 (long long diff)
{
  return ((unsigned long long) (diff < 0 ? -diff : diff));
}

unsigned long long
f4 (unsigned long long diff)
{
  return ((unsigned long long) ((signed long long) diff < 0 ? -diff : diff));
}

main ()
{
  int i;
  for (i = 0; i <= 10; i++)
    {
      if (f1 (i) != i)
	abort ();
      if (f1 (-i) != i)
	abort ();
      if (f2 (i) != i)
	abort ();
      if (f2 (-i) != i)
	abort ();
      if (f3 ((long long) i) != i)
	abort ();
      if (f3 ((long long) -i) != i)
	abort ();
      if (f4 ((long long) i) != i)
	abort ();
      if (f4 ((long long) -i) != i)
	abort ();
    }
  exit (0);
}
// source: 950621-1.c
struct s
{
  int a;
  int b;
  struct s *dummy;
};

f (struct s *sp)
{
  return sp && sp->a == -1 && sp->b == -1;
}

main ()
{
  struct s x;
  x.a = x.b = -1;
  if (f (&x) == 0)
    abort ();
  exit (0);
}
// source: 950628-1.c
typedef struct
{
  char hours, day, month;
  short year;
} T;

T g (void)
{
  T now;

  now.hours = 1;
  now.day = 2;
  now.month = 3;
  now.year = 4;
  return now;
}

T f (void)
{
  T virk;

  virk = g ();
  return virk;
}

main ()
{
  if (f ().hours != 1 || f ().day != 2 || f ().month != 3 || f ().year != 4)
    abort ();
  exit (0);
}
// source: 950704-1.c
int errflag;

long long
f (long long x, long long y)
{
  long long r;

  errflag = 0;
  r = x + y;
  if (x >= 0)
    {
      if ((y < 0) || (r >= 0))
	return r;
    }
  else
    {
      if ((y > 0) || (r < 0))
	return r;
    }
  errflag = 1;
  return 0;
}

main ()
{
  f (0, 0);
  if (errflag)
    abort ();

  f (1, -1);
  if (errflag)
    abort ();

  f (-1, 1);
  if (errflag)
    abort ();

  f (0x8000000000000000LL, 0x8000000000000000LL);
  if (!errflag)
    abort ();

  f (0x8000000000000000LL, -1LL);
  if (!errflag)
    abort ();

  f (0x7fffffffffffffffLL, 0x7fffffffffffffffLL);
  if (!errflag)
    abort ();

  f (0x7fffffffffffffffLL, 1LL);
  if (!errflag)
    abort ();

  f (0x7fffffffffffffffLL, 0x8000000000000000LL);
  if (errflag)
    abort ();

  exit (0);
}
// source: 950706-1.c
int
f (int n)
{
  return (n > 0) - (n < 0);
}

main ()
{
  if (f (-1) != -1)
    abort ();
  if (f (1) != 1)
    abort ();
  if (f (0) != 0)
    abort ();
  exit (0);
}
// source: 950710-1.c
struct twelve
{
  int a;
  int b;
  int c;
};

struct pair
{
  int first;
  int second;
};

struct pair
g ()
{
  struct pair p;
  return p;
}

static void
f ()
{
  int i;
  for (i = 0; i < 1; i++)
    {
      int j;
      for (j = 0; j < 1; j++)
	{
	  if (0)
	    {
	      int k;
	      for (k = 0; k < 1; k++)
		{
		  struct pair e = g ();
		}
	    }
	  else
	    {
	      struct twelve a, b;
	      if ((((char *) &b - (char *) &a) < 0
		   ? (-((char *) &b - (char *) &a))
		   : ((char *) &b - (char *) &a))  < sizeof (a))
		abort ();
	    }
	}
    }
}

main ()
{
  f ();
  exit (0);
}
// source: 950714-1.c
int array[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

main ()
{
  int i, j;
  int *p;

  for (i = 0; i < 10; i++)
    for (p = &array[0]; p != &array[9]; p++)
      if (*p == i)
	goto label;

 label:
  if (i != 1)
    abort ();
  exit (0);
}
// source: 950809-1.c
struct S
{
  int *sp, fc, *sc, a[2];
};

f (struct S *x)
{
  int *t = x->sc;
  int t1 = t[0];
  int t2 = t[1];
  int t3 = t[2];
  int a0 = x->a[0];
  int a1 = x->a[1];
  t[2] = t1;
  t[0] = a1;
  x->a[1] = a0;
  x->a[0] = t3;
  x->fc = t2;
  x->sp = t;
}

main ()
{
  struct S s;
  static int sc[3] = {2, 3, 4};
  s.sc = sc;
  s.a[0] = 10;
  s.a[1] = 11;
  f (&s);
  if (s.sp[2] != 2)
    abort ();
  exit (0);
}
// source: 950906-1.c
g (int i)
{
}

f (int i)
{
  g (0);
  while ( ({ i--; }) )
    g (0);
}

main ()
{
  f (10);
  exit (0);
}
// source: 950915-1.c
long int a = 100000;
long int b = 21475;

long
f ()
{
  return ((long long) a * (long long) b) >> 16;
}

main ()
{
  if (f () < 0)
    abort ();
  exit (0);
}
// source: 950929-1.c
int f (char *p) { }

main ()
{
  char c;
  char c2;
  int i = 0;
  char *pc = &c;
  char *pc2 = &c2;
  int *pi = &i;

  *pc2 = 1;
  *pi = 1;
  *pc2 &= *pi;
  f (pc2);
  *pc2 = 1;
  *pc2 &= *pi;
  if (*pc2 != 1)
    abort ();
  exit (0);
}
// source: 951003-1.c
int f (i) { return 12; }
int g () { return 0; }

main ()
{
  int i, s;

  for (i = 0; i < 32; i++)
    {
      s = f (i);

      if (i == g ())
	s = 42;
      if (i == 0 || s == 12)
	;
      else
	abort ();
    }

  exit (0);
}
// source: 951115-1.c
int var = 0;

g ()
{
  var = 1;
}

f ()
{
  int f2 = 0;

  if (f2 == 0)
    ;

  g ();
}

main ()
{
  f ();
  if (var != 1)
    abort ();
  exit (0);
}
// source: 951204-1.c
f (char *x)
{
  *x = 'x';
}

main ()
{
  int i;
  char x = '\0';

  for (i = 0; i < 100; ++i)
    {
      f (&x);
      if (*(const char *) &x != 'x')
	abort ();
    }
  exit (0);
}
// source: 960116-1.c
static inline
p (int *p)
{
  return !((long) p & 1);
}

int
f (int *q)
{
  if (p (q) && *q)
    return 1;
  return 0;
}

main ()
{
  if (f ((int*) 0xffffffff) != 0)
    abort ();
  exit (0);
}
// source: 960117-1.c
static char id_space[2] [32 +1];
typedef short COUNT;

typedef char TEXT;

union T_VALS
{
  TEXT   *id __attribute__ ((aligned (2), packed)) ;
};
typedef union T_VALS VALS;

struct T_VAL
{
  COUNT    pos __attribute__ ((aligned (2), packed)) ;
  VALS    vals __attribute__ ((aligned (2), packed)) ;
};
typedef struct T_VAL VAL;

VAL curval = {0};

static short idc = 0;
static int cur_line;
static int char_pos;

typedef unsigned short WORD;

WORD
get_id (char c)
{
  curval.vals.id[0] = c;
}

WORD
get_tok ()
{
  char c = 'c';
  curval.vals.id = id_space[idc];
  curval.pos = (cur_line << 10) | char_pos;
  return get_id (c);
}

main ()
{
  get_tok ();
  exit (0);
}
// source: 960209-1.c
struct a_struct
{
  unsigned char a_character;
};

struct a_struct an_array[5];
struct a_struct *a_ptr;
int yabba = 1;

int
f (a, b)
     unsigned char a;
     unsigned long b;
{
  long i, j, p, q, r, s;

  if (b != (unsigned long) 0)
    {
      if (yabba)
	return -1;
      s = 4000000 / b;
      for (i = 0; i < 11; i++)
	{
	  for (j = 0; j < 256; j++)
	    {
	      if (((p - s < 0) ? -s : 0) < (( q - s < 0) ? -s : q))
		r = i;
	    }
	}
    }

  if (yabba)
    return 0;
  a_ptr = &an_array[a];
  a_ptr->a_character = (unsigned char) r;
}

main ()
{
  if (f (1, 0UL) != 0)
    abort ();
  exit (0);
}
// source: 960215-1.c
long double C = 2;
long double U = 1;
long double Y2 = 3;
long double Y1 = 1;
long double X, Y, Z, T, R, S;
main ()
{
  X = (C + U) * Y2;
  Y = C - U - U;
  Z = C + U + U;
  T = (C - U) * Y1;
  X = X - (Z + U);
  R = Y * Y1;
  S = Z * Y2;
  T = T - Y;
  Y = (U - Y) + R;
  Z = S - (Z + U + U);
  R = (Y2 + U) * Y1;
  Y1 = Y2 * Y1;
  R = R - Y2;
  Y1 = Y1 - 0.5L;
  if (Z != 6)
    abort ();
  exit (0);
}
// source: 960218-1.c
int glob;

g (x)
{
  glob = x;
  return 0;
}

f (x)
{
  int a = ~x;
  while (a)
    a = g (a);
}

main ()
{
  f (3);
  if (glob != -4)
    abort ();
  exit (0);
}
// source: 960219-1.c
f (int i)
{
  if (((1 << i) & 1) == 0)
    abort ();
}

main ()
{
  f (0);
  exit (0);
}
// source: 960301-1.c
struct foo {
  unsigned : 12;
  unsigned field : 4;
} foo;
unsigned oldfoo;

int
bar (unsigned k)
{
  oldfoo = foo.field;
  foo.field = k;
  if (k)
    return 1;
  return 2;
}

main ()
{
  if (bar (1U) != 1)
    abort ();
  exit (0);
}
// source: 960302-1.c
long a = 1;

foo ()
{
  switch (a % 2 % 2 % 2 % 2 % 2 % 2 % 2 % 2)
    {
    case 0:
      return 0;
    case 1:
      return 1;
    default:
      return -1;
    }
}

main ()
{
  if (foo () != 1)
    abort ();
  exit (0);
}
// source: 960311-1.c
#include <stdio.h>

#ifdef DEBUG
#define abort() printf ("error, line %d\n", __LINE__)
#endif

int count;

void a1() { ++count; }

void
b (unsigned char data)
{
  if (data & 0x80) a1();
  data <<= 1;

  if (data & 0x80) a1();
  data <<= 1;

  if (data & 0x80) a1();
}

main ()
{
  count = 0;
  b (0);
  if (count != 0)
    abort ();

  count = 0;
  b (0x80);
  if (count != 1)
    abort ();

  count = 0;
  b (0x40);
  if (count != 1)
    abort ();

  count = 0;
  b (0x20);
  if (count != 1)
    abort ();

  count = 0;
  b (0xc0);
  if (count != 2)
    abort ();

  count = 0;
  b (0xa0);
  if (count != 2)
    abort ();

  count = 0;
  b (0x60);
  if (count != 2)
    abort ();

  count = 0;
  b (0xe0);
  if (count != 3)
    abort ();

#ifdef DEBUG
  printf ("Done.\n");
#endif
  exit (0);
}
// source: 960311-2.c
#include <stdio.h>

#ifdef DEBUG
#define abort() printf ("error, line %d\n", __LINE__)
#endif

int count;

void a1() { ++count; }

void
b (unsigned short data)
{
  if (data & 0x8000) a1();
  data <<= 1;

  if (data & 0x8000) a1();
  data <<= 1;

  if (data & 0x8000) a1();
}

main ()
{
  count = 0;
  b (0);
  if (count != 0)
    abort ();

  count = 0;
  b (0x8000);
  if (count != 1)
    abort ();

  count = 0;
  b (0x4000);
  if (count != 1)
    abort ();

  count = 0;
  b (0x2000);
  if (count != 1)
    abort ();

  count = 0;
  b (0xc000);
  if (count != 2)
    abort ();

  count = 0;
  b (0xa000);
  if (count != 2)
    abort ();

  count = 0;
  b (0x6000);
  if (count != 2)
    abort ();

  count = 0;
  b (0xe000);
  if (count != 3)
    abort ();

#ifdef DEBUG
  printf ("Done.\n");
#endif
  exit (0);
}
// source: 960311-3.c
#include <stdio.h>

#ifdef DEBUG
#define abort() printf ("error, line %d\n", __LINE__)
#endif

int count;

void a1() { ++count; }

void
b (unsigned long data)
{
  if (data & 0x80000000) a1();
  data <<= 1;

  if (data & 0x80000000) a1();
  data <<= 1;

  if (data & 0x80000000) a1();
}

main ()
{
  count = 0;
  b (0);
  if (count != 0)
    abort ();

  count = 0;
  b (0x80000000);
  if (count != 1)
    abort ();

  count = 0;
  b (0x40000000);
  if (count != 1)
    abort ();

  count = 0;
  b (0x20000000);
  if (count != 1)
    abort ();

  count = 0;
  b (0xc0000000);
  if (count != 2)
    abort ();

  count = 0;
  b (0xa0000000);
  if (count != 2)
    abort ();

  count = 0;
  b (0x60000000);
  if (count != 2)
    abort ();

  count = 0;
  b (0xe0000000);
  if (count != 3)
    abort ();

#ifdef DEBUG
  printf ("Done.\n");
#endif
  exit (0);
}
// source: 960312-1.c
struct S
{
  int *sp, fc, *sc, a[2];
};

f (struct S *x)
{
  int *t = x->sc;
  int t1 = t[0];
  int t2 = t[1];
  int t3 = t[2];
  int a0 = x->a[0];
  int a1 = x->a[1];
  asm("": :"r" (t2), "r" (t3));
  t[2] = t1;
  t[0] = a1;
  x->a[1] = a0;
  x->a[0] = t3;
  x->fc = t2;
  x->sp = t;
}

main ()
{
  struct S s;
  static int sc[3] = {2, 3, 4};
  s.sc = sc;
  s.a[0] = 10;
  s.a[1] = 11;
  f (&s);
  if (s.sp[2] != 2)
    abort ();
  exit (0);
}
// source: 960317-1.c
int
f (unsigned bitcount, int mant)
{
  int mask = -1 << bitcount;
  {
    if (! (mant & -mask))
      goto ab;
    if (mant & ~mask)
      goto auf;
  }
ab:
  return 0;
auf:
  return 1;
}

main ()
{
  if (f (0, -1))
    abort ();
  exit (0);
}
// source: 960321-1.c
char a[10] = "deadbeef";

char
acc_a (long i)
{
  return a[i-2000000000L];
}

main ()
{
  if (acc_a (2000000000L) != 'd')
    abort ();
  exit (0);
}
// source: 960326-1.c
struct s
{
  int a;
  int b;
  short c;
  int d[3];
};

struct s s = { .b = 3, .d = {2,0,0} };

main ()
{
  if (s.b != 3)
    abort ();
  exit (0);
}
// source: 960327-1.c
#include <stdio.h>
g ()
{
  return '\n';
}

f ()
{
  char s[] = "abcedfg012345";
  char *sp = s + 12;

  switch (g ())
    {
      case '\n':
        break;
    }

  while (*--sp == '0')
    ;
  sprintf (sp + 1, "X");

  if (s[12] != 'X')
    abort ();
}

main ()
{
  f ();
  exit (0);
}
// source: 960402-1.c
f (signed long long int x)
{
  return x > 0xFFFFFFFFLL || x < -0x80000000LL;
}

main ()
{
  if (f (0) != 0)
    abort ();
  exit (0);
}
// source: 960405-1.c
#define X  5.9486574767861588254287966331400356538172e4931L

long double x = X + X;
long double y = 2.0L * X;

main ()
{
#if ! defined (__vax__) && ! defined (_CRAY)
  if (x != y)
    abort ();
#endif
  exit (0);
}
// source: 960416-1.c
typedef unsigned long int st;
typedef unsigned long long dt;
typedef union
{
  dt d;
  struct
  {
    st h, l;
  }
  s;
} t_be;

typedef union
{
  dt d;
  struct
  {
    st l, h;
  }
  s;
} t_le;

#define df(f, t) \
int \
f (t afh, t bfh) \
{ \
  t hh; \
  t hp, lp, dp, m; \
  st ad, bd; \
  int s; \
  s = 0; \
  ad = afh.s.h - afh.s.l; \
  bd = bfh.s.l - bfh.s.h; \
  if (bd > bfh.s.l) \
    { \
      bd = -bd; \
      s = ~s; \
    } \
  lp.d = (dt) afh.s.l * bfh.s.l; \
  hp.d = (dt) afh.s.h * bfh.s.h; \
  dp.d = (dt) ad *bd; \
  dp.d ^= s; \
  hh.d = hp.d + hp.s.h + lp.s.h + dp.s.h; \
  m.d = (dt) lp.s.h + hp.s.l + lp.s.l + dp.s.l; \
  return hh.s.l + m.s.l; \
}

df(f_le, t_le)
df(f_be, t_be)

main ()
{
  t_be x;
  x.s.h = 0x10000000U;
  x.s.l = 0xe0000000U;
  if (x.d == 0x10000000e0000000ULL
      && f_be ((t_be) 0x100000000ULL, (t_be) 0x100000000ULL) != -1)
    abort ();
  if (x.d == 0xe000000010000000ULL
      && f_le ((t_le) 0x100000000ULL, (t_le) 0x100000000ULL) != -1)
    abort ();
  exit (0);
}
// source: 960419-1.c
static int i;

void
check(x)
     int x;
{
  if (!x)
    abort();
}

main()
{
  int *p = &i;

  check(p != (void *)0);
  exit (0);
}
// source: 960419-2.c
#define SIZE 8

main()
{
  int a[SIZE] = {1};
  int i;

  for (i = 1; i < SIZE; i++)
    if (a[i] != 0)
      abort();

  exit (0);
}
// source: 960512-1.c
__complex__
double f ()
{
  int a[40];
  __complex__ double c;

  a[9] = 0;
  c = a[9];
  return c;
}

main ()
{
  __complex__ double c;

  if (c = f ())
    abort ();
  exit (0);
}
// source: 960513-1.c
long double
f (d, i)
     long double d;
     int i;
{
  long double e;

  d = -d;
  e = d;
  if (i == 1)
    d *= 2;
  d -= e * d;
  d -= e * d;
  d -= e * d;
  d -= e * d;
  d -= e * d;
  return d;
}

main ()
{
  if (! (int) (f (2.0L, 1)))
    abort ();
  exit (0);
}
// source: 960521-1.c
/* { dg-add-options stack_size } */

#include <stdlib.h>

int *a, *b;
int n;

#ifdef STACK_SIZE
#define BLOCK_SIZE (STACK_SIZE / (sizeof (*a) + sizeof (*b)))
#else
#define BLOCK_SIZE 32768
#endif
foo ()
{
  int i;
  for (i = 0; i < n; i++)
    a[i] = -1;
  for (i = 0; i < BLOCK_SIZE - 1; i++)
    b[i] = -1;
}

main ()
{
  n = BLOCK_SIZE;
  a = malloc (n * sizeof(*a));
  b = malloc (n * sizeof(*b));
  *b++ = 0;
  foo ();
  if (b[-1])
    abort ();
  exit (0);
}
// source: 960608-1.c
typedef struct
{
  unsigned char a  : 2;
  unsigned char b  : 3;
  unsigned char c  : 1;
  unsigned char d  : 1;
  unsigned char e  : 1;
} a_struct;

foo (flags)
     a_struct *flags;
{
  return (flags->c != 0
	  || flags->d != 1
	  || flags->e != 1
	  || flags->a != 2
	  || flags->b != 3);
}

main ()
{
  a_struct flags;

  flags.c  = 0;
  flags.d  = 1;
  flags.e  = 1;
  flags.a  = 2;
  flags.b  = 3;

  if (foo (&flags) != 0)
    abort ();
  else
    exit (0);
}
// source: 960801-1.c
unsigned
f ()
{
  long long l2;
  unsigned short us;
  unsigned long long ul;
  short s2;

  ul = us = l2 = s2 = -1;
  return ul;
}

unsigned long long
g ()
{
  long long l2;
  unsigned short us;
  unsigned long long ul;
  short s2;

  ul = us = l2 = s2 = -1;
  return ul;
}

main ()
{
  if (f () != (unsigned short) -1)
    abort ();
  if (g () != (unsigned short) -1)
    abort ();
  exit (0);
}
// source: 960802-1.c
long val = 0x5e000000;

long
f1 (void)
{
  return 0x132;
}

long
f2 (void)
{
  return 0x5e000000;
}

void
f3 (long b)
{
  val = b;
}

void
f4 ()
{
  long v = f1 ();
  long o = f2 ();
  v = (v & 0x00ffffff) | (o & 0xff000000);
  f3 (v);
}

main ()
{
  f4 ();
  if (val != 0x5e000132)
    abort ();
  exit (0);
}
// source: 960830-1.c
#ifdef __i386__
f (rp)
     unsigned int *rp;
{
  __asm__ ("mull %3" : "=a" (rp[0]), "=d" (rp[1]) : "%0" (7), "rm" (7));
}

main ()
{
  unsigned int s[2];

  f (s);
  if (s[1] != 0 || s[0] != 49)
    abort ();
 exit (0);
}
#else
main ()
{
  exit (0);
}
#endif
// source: 960909-1.c
int
ffs (x)
     int x;
{
  int bit, mask;

  if (x == 0)
    return 0;

  for (bit = 1, mask = 1; !(x & mask); bit++, mask <<= 1)
    ;

  return bit;
}

f (x)
     int x;
{
  int y;
  y = ffs (x) - 1;
  if (y < 0)
    abort ();
}

main ()
{
  f (1);
  exit (0);
}
// source: 961004-1.c
int k = 0;

main()
{
  int i;
  int j;

  for (i = 0; i < 2; i++)
    {
      if (k)
	{
	  if (j != 2)
	    abort ();
	}
      else
	{
	  j = 2;
	  k++;
	}
    }
  exit (0);
}
// source: 961017-1.c
main ()
{
  unsigned char z = 0;

  do ;
  while (--z > 0);
  exit (0);
}
// source: 961017-2.c
main ()
{
  int i = 0;


  if (sizeof (unsigned long int) == 4)
    {
      unsigned long int z = 0;

      do {
	z -= 0x00004000;
	i++;
	if (i > 0x00040000)
	  abort ();
      } while (z > 0);
      exit (0);
    }
  else if (sizeof (unsigned int) == 4)
    {
      unsigned int z = 0;

      do {
	z -= 0x00004000;
	i++;
	if (i > 0x00040000)
	  abort ();
      } while (z > 0);
      exit (0);
    }
  else
    exit (0);
}
// source: 961026-1.c
int
test (arg)
     int arg;
{
  if (arg > 0 || arg == 0)
    return 0;
  return -1;
}

main ()
{
  if (test (0) != 0)
    abort ();
  if (test (-1) != -1)
    abort ();
  exit (0);
}
// source: 961112-1.c
f (x)
{
  if (x != 0 || x == 0)
    return 0;
  return 1;
}

main ()
{
  if (f (3))
    abort ();
  exit (0);
}
// source: 961122-1.c
long long acc;

addhi (short a)
{
  acc += (long long) a << 32;
}

subhi (short a)
{
  acc -= (long long) a << 32;
}

main ()
{
  acc = 0xffff00000000ll;
  addhi (1);
  if (acc != 0x1000000000000ll)
    abort ();
  subhi (1);
  if (acc != 0xffff00000000ll)
    abort ();
  exit (0);
}
// source: 961122-2.c
int
f (int a)
{
  return ((a >= 0 && a <= 10) && ! (a >= 0));
}

main ()
{
  if (f (0))
    abort ();
  exit (0);
}
// source: 961125-1.c
static char *
begfield (int tab, char *ptr, char *lim, int sword, int schar)
{
  if (tab)
    {
      while (ptr < lim && sword--)
	{
	  while (ptr < lim && *ptr != tab)
	    ++ptr;
	  if (ptr < lim)
	    ++ptr;
	}
    }
  else
    {
      while (1)
	;
    }

  if (ptr + schar <= lim)
    ptr += schar;

  return ptr;
}

main ()
{
  char *s = ":ab";
  char *lim = s + 3;
  if (begfield (':', s, lim, 1, 1) != s + 2)
    abort ();
  exit (0);
}
// source: 961206-1.c
int
sub1 (unsigned long long i)
{
  if (i < 0x80000000)
    return 1;
  else
    return 0;
}

int
sub2 (unsigned long long i)
{
  if (i <= 0x7FFFFFFF)
    return 1;
  else
    return 0;
}

int
sub3 (unsigned long long i)
{
  if (i >= 0x80000000)
    return 0;
  else
    return 1;
}

int
sub4 (unsigned long long i)
{
  if (i > 0x7FFFFFFF)
    return 0;
  else
    return 1;
}

main()
{
  if (sub1 (0x80000000ULL))
    abort ();

  if (sub2 (0x80000000ULL))
    abort ();

  if (sub3 (0x80000000ULL))
    abort ();

  if (sub4 (0x80000000ULL))
    abort ();

  exit (0);
}
// source: 961213-1.c
int
g (unsigned long long int *v, int n, unsigned int a[], int b)
{
  int cnt;
  *v = 0;
  for (cnt = 0; cnt < n; ++cnt)
    *v = *v * b + a[cnt];
  return n;
}

main ()
{
  int res;
  unsigned int ar[] = { 10, 11, 12, 13, 14 };
  unsigned long long int v;

  res = g (&v, sizeof(ar)/sizeof(ar[0]), ar, 16);
  if (v != 0xabcdeUL)
    abort ();

  exit (0);
}
// source: 961223-1.c
/* { dg-options "-fgnu89-inline" } */

extern void exit (int);
extern void abort (void);

struct s {
  double d;
};

inline struct s
sub (struct s s)
{
  s.d += 1.0;
  return s;
}

int
main ()
{
  struct s t = { 2.0 };
  t = sub (t);
  if (t.d != 3.0)
    abort ();
  exit (0);
}
// source: 970214-1.c
#define L 1
main ()
{
  exit (L'1' != L'1');
}
// source: 970214-2.c
#define m(L) (L'1' + (L))
main ()
{
  exit (m (0) != L'1');
}
// source: 970217-1.c
sub (int i, int array[i++])
{
  return i;
}

main()
{
  int array[10];
  exit (sub (10, array) != 11);
}
// source: 970923-1.c
int
ts(a)
     int a;
{
  if (a < 1000 && a > 2000)
    return 1;
  else
    return 0;
}

int
tu(a)
     unsigned int a;
{
  if (a < 1000 && a > 2000)
    return 1;
  else
    return 0;
}


main()
{
  if (ts (0) || tu (0))
    abort ();
  exit (0);
}
// source: 980205.c
#include <stdarg.h>

void fdouble (double one, ...)
{
  double value;
  va_list ap;

  va_start (ap, one);
  value = va_arg (ap, double);
  va_end (ap);

  if (one != 1.0 || value != 2.0)
    abort ();
}

int main ()
{
  fdouble (1.0, 2.0);
  exit (0);
}
// source: 980223.c
typedef struct { char *addr; long type; } object;

object bar (object blah)
{
  abort();
}

object foo (object x, object y)
{
  object z = *(object*)(x.addr);
  if (z.type & 64)
    {
      y = *(object*)(z.addr+sizeof(object));
      z = *(object*)(z.addr);
      if (z.type & 64)
        y = bar(y);
    }
  return y;
}

int nil;
object cons1[2] = { {(char *) &nil, 0}, {(char *) &nil, 0} };
object cons2[2] = { {(char *) &cons1, 64}, {(char *) &nil, 0} };

main()
{
  object x = {(char *) &cons2, 64};
  object y = {(char *) &nil, 0};
  object three = foo(x,y);
  return 0;
}
// source: 980424-1.c
int i, a[99];

void f (int one)
{
  if (one != 1)
    abort ();
}

void
g ()
{
  f (a[i & 0x3f]);
}

int
main ()
{
  a[0] = 1;
  i = 0x40;
  g ();
  exit (0);
}
// source: 980505-1.c
static int f(int) __attribute__((const));
int main()
{
   int f1, f2, x;
   x = 1; f1 = f(x);
   x = 2; f2 = f(x);
   if (f1 != 1 || f2 != 2)
     abort ();
   exit (0);
}
static int f(int x) { return x; }
// source: 980505-2.c
typedef unsigned short Uint16;
typedef unsigned int Uint;

Uint f ()
{
        Uint16 token;
        Uint count;
        static Uint16 values[1] = {0x9300};

        token = values[0];
        count = token >> 8;

        return count;
}

int
main ()
{
  if (f () != 0x93)
    abort ();
  exit (0);
}
// source: 980506-1.c
struct decision
{
  char enforce_mode;
  struct decision *next;
};


static void
clear_modes (p)
     register struct decision *p;
{
  goto blah;

foo:
  p->enforce_mode = 0;
blah:
  if (p)
    goto foo;
}

main()
{
  struct decision *p = 0;
  clear_modes (p);
  exit (0);
}
// source: 980506-2.c
static void *self(void *p){ return p; }

int
f()
{
  struct { int i; } s, *sp;
  int *ip = &s.i;

  s.i = 1;
  sp = self(&s);

  *ip = 0;
  return sp->i+1;
}

main()
{
  if (f () != 1)
    abort ();
  else
    exit (0);
}
// source: 980506-3.c
unsigned char lookup_table [257];

static int
build_lookup (pattern)
     unsigned char *pattern;
{
  int m;

  m = strlen (pattern) - 1;

  memset (lookup_table, ++m, 257);
  return m;
}

int main(argc, argv)
     int argc;
     char **argv;
{
  if (build_lookup ("bind") != 4)
    abort ();
  else
    exit (0);
}
// source: 980526-1.c
/* { dg-require-effective-target label_values } */

int expect_do1 = 1, expect_do2 = 2;

static int doit(int x){
  __label__ lbl1;
  __label__ lbl2;
  static int jtab_init = 0;
  static void *jtab[2];

  if(!jtab_init) {
    jtab[0] = &&lbl1;
    jtab[1] = &&lbl2;
    jtab_init = 1;
  }
  goto *jtab[x];
lbl1:
  return 1;
lbl2:
  return 2;
}

static void do1(void) {
  if (doit(0) != expect_do1)
    abort ();
}

static void do2(void){
  if (doit(1) != expect_do2)
    abort ();
}

int main(void){
  exit(0);
}
// source: 980526-2.c
typedef unsigned int dev_t;
typedef unsigned int kdev_t;

static inline kdev_t to_kdev_t(int dev)
{
	int major, minor;

	if (sizeof(kdev_t) == 16)
		return (kdev_t)dev;
	major = (dev >> 8);
	minor = (dev & 0xff);
	return ((( major ) << 22 ) | (  minor )) ;

}

void do_mknod(const char * filename, int mode, kdev_t dev)
{
	if (dev==0x15800078)
		exit(0);
	else
		abort();
}


char * getname(const char * filename)
{
	register unsigned int a1,a2,a3,a4,a5,a6,a7,a8,a9;
	a1 = (unsigned int)(filename) *5 + 1;
	a2 = (unsigned int)(filename) *6 + 2;
	a3 = (unsigned int)(filename) *7 + 3;
	a4 = (unsigned int)(filename) *8 + 4;
	a5 = (unsigned int)(filename) *9 + 5;
	a6 = (unsigned int)(filename) *10 + 5;
	a7 = (unsigned int)(filename) *11 + 5;
	a8 = (unsigned int)(filename) *12 + 5;
	a9 = (unsigned int)(filename) *13 + 5;
	return (char *)(a1*a2+a3*a4+a5*a6+a7*a8+a9);
}

int sys_mknod(const char * filename, int mode, dev_t dev)
{
	int error;
	char * tmp;

	tmp = getname(filename);
	error = ((long)( tmp )) ;
	do_mknod(tmp,mode,to_kdev_t(dev));
	return error;
}

int main(void)
{
	if (sizeof (int) != 4)
	  exit (0);

	return sys_mknod("test",1,0x12345678);
}
// source: 980526-3.c
int compare(x, y)
unsigned int x;
unsigned int y;
{
   if (x==y)
     return 0;
   else
     return 1;
}

main()
{
 unsigned int i, j, k, l;
 i = 5; j = 2; k=0; l=2;
 if (compare(5%(~(unsigned) 2), i%~j)
     || compare(0, k%~l))
    abort();
 else
    exit(0);
}
// source: 980602-1.c
main()
{
  int i;
  for (i = 1; i < 100; i++)
    ;
  if (i == 100)
    exit (0);
  abort ();
}
// source: 980602-2.c
/* The bit-field below would have a problem if __INT_MAX__ is too
   small.  */
#if __INT_MAX__ < 2147483647
int
main (void)
{
  exit (0);
}
#else
struct {
    unsigned bit : 30;
} t;

int main()
{
    if (!(t.bit++))
	exit (0);
    else
	abort ();
}
#endif
// source: 980604-1.c
int a = 1;
int b = -1;

int c = 1;
int d = 0;

main ()
{
  double e;
  double f;
  double g;

  f = c;
  g = d;
  e = (a < b) ? f : g;
  if (e)
    abort ();
  exit(0);
}
// source: 980605-1.c
/* { dg-add-options stack_size } */

#include <stdio.h>

#ifndef STACK_SIZE
#define STACK_SIZE 200000
#endif

__inline__ static int
dummy (x)
{
  int y;
  y = (long) (x * 4711.3);
  return y;
}

int getval (void);

int
f2 (double x)
{
  unsigned short s;
  int a, b, c, d, e, f, g, h, i, j;

  a = getval ();
  b = getval ();
  c = getval ();
  d = getval ();
  e = getval ();
  f = getval ();
  g = getval ();
  h = getval ();
  i = getval ();
  j = getval ();


  s = x;

  return a + b + c + d + e + f + g + h + i + j + s;
}

int x = 1;

int
getval (void)
{
  return x++;
}

char buf[10];

void
f ()
{
  char ar[STACK_SIZE/2];
  int a, b, c, d, e, f, g, h, i, j, k;

  a = getval ();
  b = getval ();
  c = getval ();
  d = getval ();
  e = getval ();
  f = getval ();
  g = getval ();
  h = getval ();
  i = getval ();
  j = getval ();

  k = f2 (17.0);

  sprintf (buf, "%d\n", a + b + c + d + e + f + g + h + i + j + k);
  if (a + b + c + d + e + f + g + h + i + j + k != 227)
    abort ();
}

main ()
{
  f ();
  exit (0);
}
// source: 980608-1.c
/* { dg-options "-fgnu89-inline" } */

#include <stdarg.h>

extern void abort(void);
extern void exit (int);

void f1(int a,int b,int c,int d,int e, int f,int g,int h,int i,int j, int k,int
l,int m,int n,int o)
{
    return;
}

inline void debug(const char *msg,...)
{
    va_list ap;
    va_start( ap, msg );

    f1(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);

    if ( va_arg(ap,int) != 101)
        abort();
    if ( va_arg(ap,int) != 102)
        abort();
    if ( va_arg(ap,int) != 103)
        abort();
    if ( va_arg(ap,int) != 104)
        abort();
    if ( va_arg(ap,int) != 105)
        abort();
    if ( va_arg(ap,int) != 106)
        abort();

    va_end( ap );
}

int main(void)
{
  debug("%d %d %d  %d %d %d\n", 101, 102, 103, 104, 105, 106);
  exit(0);
}
// source: 980612-1.c
struct fd
{
	unsigned char a;
	unsigned char b;
} f = { 5 };

struct fd *g() { return &f; }
int h() { return -1; }

int main()
{
	struct fd *f = g();
	f->b = h();
	if (((f->a & 0x7f) & ~0x10) <= 2)
		abort ();
	exit (0);
}
// source: 980617-1.c
void foo (unsigned int * p)
{
  if ((signed char)(*p & 0xFF) == 17 || (signed char)(*p & 0xFF) == 18)
    return;
  else
    abort ();
}

int main ()
{
  int i = 0x30011;
  foo(&i);
  exit (0);
}
// source: 980618-1.c
void func(int, int);

int main()
{
        int x = 7;
        func(!x, !7);
	exit (0);
}

void func(int x, int y)
{
        if (x == y)
                return;
        else
                abort ();
}
// source: 980701-1.c
ns_name_skip (unsigned char **x, unsigned char *y)
{
  *x = 0;
  return 0;
}

unsigned char a[2];

int dn_skipname(unsigned char *ptr, unsigned char *eom) {
    unsigned char *saveptr = ptr;

    if (ns_name_skip(&ptr, eom) == -1)
	        return (-1);
    return (ptr - saveptr);
}

main()
{
  if (dn_skipname (&a[0], &a[1]) == 0)
    abort ();
  exit (0);
}
// source: 980707-1.c
#include <stdlib.h>
#include <string.h>

char **
buildargv (char *input)
{
  static char *arglist[256];
  int numargs = 0;

  while (1)
    {
      while (*input == ' ')
	input++;
      if (*input == 0)
	break;
      arglist [numargs++] = input;
      while (*input != ' ' && *input != 0)
	input++;
      if (*input == 0)
	break;
      *(input++) = 0;
    }
  arglist [numargs] = NULL;
  return arglist;
}


int main()
{
  char **args;
  char input[256];
  int i;

  strcpy(input, " a b");
  args = buildargv(input);

  if (strcmp (args[0], "a"))
    abort ();
  if (strcmp (args[1], "b"))
    abort ();
  if (args[2] != NULL)
    abort ();

  exit (0);
}
// source: 980709-1.c
/* { dg-xfail-if "Can not call system libm.a with -msoft-float" { powerpc-*-aix* rs6000-*-aix* } { "-msoft-float" } { "" } } */
#include <math.h>

main()
{
  volatile double a;
  double c;
  a = 32.0;
  c = pow(a, 1.0/3.0);
  if (c + 0.1 > 3.174802
      && c - 0.1 < 3.174802)
    exit (0);
  else
    abort ();
}
// source: 980716-1.c
#include <stdarg.h>

void
stub(int num, ...)
{
    va_list ap;
    char *end;
    int i;

    for (i = 0; i < 2; i++) {
        va_start(ap, num);
        while ( 1 ) {
            end = va_arg(ap, char *);
            if (!end) break;
        }
        va_end(ap);
    }
}

int
main()
{
    stub(1, "ab", "bc", "cx", (char *)0);
    exit (0);
}
// source: 980929-1.c
void f(int i)
{
  if (i != 1000)
    abort ();
}


int main()
{
  int n=1000;
  int i;

  f(n);
  for(i=0; i<1; ++i) {
    f(n);
    n=666;
    &n;
  }

  exit (0);
}
// source: 981001-1.c
#define NG   0x100L

unsigned long flg = 0;

long sub (int n)
{
  int a, b ;

  if (n >= 2)
    {
      if (n % 2 == 0)
	{
	  a = sub (n / 2);

	  return (a + 2 * sub (n / 2 - 1)) * a;
	}
      else
	{
	  a = sub (n / 2 + 1);
	  b = sub (n / 2);

	  return a * a + b * b;
	}
    }
  else
    return (long) n;
}

int main (void)
{
  if (sub (30) != 832040L)
    flg |= NG;

  if (flg)
    abort ();

  exit (0);
}
// source: 981019-1.c
/* { dg-skip-if "ptxas seg faults" { nvptx-*-* } { "-O3*" } { "" } } */

extern int f2(void);
extern int f3(void);
extern void f1(void);

void
ff(int fname, int part, int nparts)
{
  if (fname)  /* bb 0 */
    {
      if (nparts)  /* bb 1 */
	f1();  /* bb 2 */
    }
  else
    fname = 2; /* bb 3  */

  /* bb 4 is the branch to bb 10
     (bb 10 is physically at the end of the loop) */
  while (f3() /* bb 10 */)
    {
      if (nparts /* bb 5 */ && f2() /* bb 6 */)
	{
	  f1();  /* bb 7 ... */
	  nparts = part;
	  if (f3())  /* ... bb 7 */
	    f1();  /* bb 8 */
	  f1(); /* bb 9 */
	  break;
	}
    }

  if (nparts)  /* bb 11 */
    f1(); /* bb 12 */
  return; /* bb 13 */
}

int main(void)
{
  ff(0, 1, 0);
  return 0;
}

int f3(void) { static int x = 0; x = !x; return x; }
void f1(void) { abort(); }
int f2(void) { abort(); }
// source: 981130-1.c
/* { dg-xfail-if "alias analysis conflicts with instruction scheduling" { m32r-*-* } { "-O2" "-O1" "-O0" "-Os"} { "" } } */
struct s { int a; int b;};
struct s s1;
struct s s2 = { 1, 2, };

void
check (a, b)
     int a;
     int b;
{
  if (a == b)
    exit (0);
  else
    abort ();
}

int
main ()
{
  int * p;
  int x;

  s1.a = 9;
  p    = & s1.a;
  s1   = s2;
  x    = * p;

  check (x, 1);
}
// source: 981206-1.c
/* Verify unaligned address aliasing on Alpha EV[45].  */

static unsigned short x, y;

void foo()
{
  x = 0x345;
  y = 0x567;
}

int main()
{
  foo ();
  if (x != 0x345 || y != 0x567)
    abort ();
  exit (0);
}
// source: 990106-1.c
foo(bufp)
char *bufp;
{
    int x = 80;
    return (*bufp++ = x ? 'a' : 'b');
}

main()
{
  char x;

  if (foo (&x) != 'a')
    abort ();

  exit (0);
}
// source: 990106-2.c
unsigned calc_mp(unsigned mod)
{
      unsigned a,b,c;
      c=-1;
      a=c/mod;
      b=0-a*mod;
      if (b > mod) { a += 1; b-=mod; }
      return b;
}

int main(int argc, char *argv[])
{
      unsigned x = 1234;
      unsigned y = calc_mp(x);

      if ((sizeof (y) == 4 && y != 680)
	  || (sizeof (y) == 2 && y != 134))
	abort ();
      exit (0);
}
// source: 990117-1.c
int
foo (int x, int y, int i, int j)
{
  double tmp1 = ((double) x / y);
  double tmp2 = ((double) i / j);

  return tmp1 < tmp2;
}

main ()
{
  if (foo (2, 24, 3, 4) == 0)
    abort ();
  return 0;
}
// source: 990127-1.c
extern void abort (void);
extern void exit (int);

main()
{
    int a,b,c;
    int *pa, *pb, *pc;
    int **ppa, **ppb, **ppc;
    int i,j,k,x,y,z;

    a = 10;
    b = 20;
    c = 30;
    pa = &a; pb = &b; pc = &c;
    ppa = &pa; ppb = &pb; ppc = &pc;
    x = 0; y = 0; z = 0;

    for(i=0;i<10;i++){
        if( pa == &a ) pa = &b;
        else pa = &a;
        while( (*pa)-- ){
            x++;
            if( (*pa) < 3 ) break;
            else pa = &b;
        }
        x++;
        pa = &b;
    }

    if ((*pa) != -5 || (*pb) != -5 || x != 43)
      abort ();

    exit (0);
}
// source: 990127-2.c
/* { dg-options "-mpc64"  { target { i?86-*-* x86_64-*-* } } } */

extern void abort (void);
extern void exit (int);

void
fpEq (double x, double y)
{
  if (x != y)
    abort ();
}

void
fpTest (double x, double y)
{
  double result1 = (35.7 * 100.0) / 45.0;
  double result2 = (x * 100.0) / y;
  fpEq (result1, result2);
}

int
main ()
{
  fpTest (35.7, 45.0);
  exit (0);
}
// source: 990128-1.c
extern int printf (const char *,...);

struct s { struct s *n; } *p;
struct s ss;
#define MAX     10
struct s sss[MAX];
int count = 0;

void sub( struct s *p, struct s **pp );
int look( struct s *p, struct s **pp );

main()
{
    struct s *pp;
    struct s *next;
    int i;

    p = &ss;
    next = p;
    for ( i = 0; i < MAX; i++ ) {
        next->n = &sss[i];
        next = next->n;
    }
    next->n = 0;

    sub( p, &pp );
    if (count != MAX+2)
      abort ();

    exit( 0 );
}

void sub( struct s *p, struct s **pp )
{
   for ( ; look( p, pp ); ) {
        if ( p )
            p = p->n;
        else
            break;
   }
}

int look( struct s *p, struct s **pp )
{
    for ( ; p; p = p->n )
        ;
    *pp = p;
    count++;
    return( 1 );
}
// source: 990130-1.c
int count = 0;
int dummy;

static int *
bar(void)
{
  ++count;
  return &dummy;
}

static void
foo(void)
{
  asm("" : "+r"(*bar()));
}

main()
{
  foo();
  if (count != 1)
    abort();
  exit(0);
}
// source: 990208-1.c
/* { dg-require-effective-target label_values } */

/* As a quality of implementation issue, we should not prevent inlining
   of function explicitly marked inline just because a label therein had
   its address taken.  */

static void *ptr1, *ptr2;
static int i = 1;

static __inline__ void doit(void **pptr, int cond)
{
  if (cond) {
  here:
    *pptr = &&here;
  }
}

__attribute__ ((noinline))
static void f(int cond)
{
  doit (&ptr1, cond);
}

__attribute__ ((noinline))
static void g(int cond)
{
  doit (&ptr2, cond);
}

__attribute__ ((noinline))
static void bar(void);

int main()
{
  f (i);
  bar();
  g (i);

#ifdef  __OPTIMIZE__
  if (ptr1 == ptr2)
    abort ();
#endif

  exit (0);
}

void bar(void) { }
// source: 990211-1.c
/* Copyright (C) 1999 Free Software Foundation, Inc.
  Contributed by Nathan Sidwell 20 Jan 1999 <nathan@acm.org> */

/* check range combining boolean operations work */

extern void abort();

#define N 77

void func(int i)
{
  /* fold-const does some clever things with range tests. Make sure
     we get (some of) them right */

  /* these must fail, regardless of the value of i */
  if ((i < 0) && (i >= 0))
    abort();
  if ((i > 0) && (i <= 0))
    abort();
  if ((i >= 0) && (i < 0))
    abort();
  if ((i <= 0) && (i > 0))
    abort();

  if ((i < N) && (i >= N))
    abort();
  if ((i > N) && (i <= N))
    abort();
  if ((i >= N) && (i < N))
    abort();
  if ((i <= N) && (i > N))
    abort();

  /* these must pass, regardless of the value of i */
  if (! ((i < 0) || (i >= 0)))
    abort();
  if (! ((i > 0) || (i <= 0)))
    abort();
  if (! ((i >= 0) || (i < 0)))
    abort();
  if (! ((i <= 0) || (i > 0)))
    abort();

  if (! ((i < N) || (i >= N)))
    abort();
  if (! ((i > N) || (i <= N)))
    abort();
  if (! ((i >= N) || (i < N)))
    abort();
  if (! ((i <= N) || (i > N)))
    abort();

  return;
}

int main()
{
  func(0);
  func(1);
  return 0;
}
// source: 990222-1.c
char line[4] = { '1', '9', '9', '\0' };

int main()
{
  char *ptr = line + 3;

  while ((*--ptr += 1) > '9') *ptr = '0';
  if (line[0] != '2' || line[1] != '0' || line[2] != '0')
    abort();
  return 0;
}
// source: 990324-1.c
void f(long i)
{
  if ((signed char)i < 0 || (signed char)i == 0)
    abort ();
  else
    exit (0);
}

main()
{
  f(0xffffff01);
}
// source: 990326-1.c
struct a {
	char a, b;
	short c;
};

int
a1()
{
	static struct a x = { 1, 2, ~1 }, y = { 65, 2, ~2 };

	return (x.a == (y.a & ~64) && x.b == y.b);
}

int
a2()
{
	static struct a x = { 1, 66, ~1 }, y = { 1, 2, ~2 };

	return (x.a == y.a && (x.b & ~64) == y.b);
}

int
a3()
{
	static struct a x = { 9, 66, ~1 }, y = { 33, 18, ~2 };

	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
}

struct b {
	int c;
	short b, a;
};

int
b1()
{
	static struct b x = { ~1, 2, 1 }, y = { ~2, 2, 65 };

	return (x.a == (y.a & ~64) && x.b == y.b);
}

int
b2()
{
	static struct b x = { ~1, 66, 1 }, y = { ~2, 2, 1 };

	return (x.a == y.a && (x.b & ~64) == y.b);
}

int
b3()
{
	static struct b x = { ~1, 66, 9 }, y = { ~2, 18, 33 };

	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
}

struct c {
	unsigned int c:4, b:14, a:14;
} __attribute__ ((aligned));

int
c1()
{
	static struct c x = { ~1, 2, 1 }, y = { ~2, 2, 65 };

	return (x.a == (y.a & ~64) && x.b == y.b);
}

int
c2()
{
	static struct c x = { ~1, 66, 1 }, y = { ~2, 2, 1 };

	return (x.a == y.a && (x.b & ~64) == y.b);
}

int
c3()
{
	static struct c x = { ~1, 66, 9 }, y = { ~2, 18, 33 };

	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
}

struct d {
	unsigned int a:14, b:14, c:4;
} __attribute__ ((aligned));

int
d1()
{
	static struct d x = { 1, 2, ~1 }, y = { 65, 2, ~2 };

	return (x.a == (y.a & ~64) && x.b == y.b);
}

int
d2()
{
	static struct d x = { 1, 66, ~1 }, y = { 1, 2, ~2 };

	return (x.a == y.a && (x.b & ~64) == y.b);
}

int
d3()
{
	static struct d x = { 9, 66, ~1 }, y = { 33, 18, ~2 };

	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
}

struct e {
	int c:4, b:14, a:14;
} __attribute__ ((aligned));

int
e1()
{
	static struct e x = { ~1, -2, -65 }, y = { ~2, -2, -1 };

	return (x.a == (y.a & ~64) && x.b == y.b);
}

int
e2()
{
	static struct e x = { ~1, -2, -1 }, y = { ~2, -66, -1 };

	return (x.a == y.a && (x.b & ~64) == y.b);
}

int
e3()
{
	static struct e x = { ~1, -18, -33 }, y = { ~2, -66, -9 };

	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
}

int
e4()
{
	static struct e x = { -1, -1, 0 };

	return x.a == 0 && x.b & 0x2000;
}

struct f {
	int a:14, b:14, c:4;
} __attribute__ ((aligned));

int
f1()
{
	static struct f x = { -65, -2, ~1 }, y = { -1, -2, ~2 };

	return (x.a == (y.a & ~64) && x.b == y.b);
}

int
f2()
{
	static struct f x = { -1, -2, ~1 }, y = { -1, -66, ~2 };

	return (x.a == y.a && (x.b & ~64) == y.b);
}

int
f3()
{
	static struct f x = { -33, -18, ~1 }, y = { -9, -66, ~2 };

	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
}

int
f4()
{
	static struct f x = { 0, -1, -1 };

	return x.a == 0 && x.b & 0x2000;
}

struct gx {
	int c:4, b:14, a:14;
} __attribute__ ((aligned));
struct gy {
	int b:14, a:14, c:4;
} __attribute__ ((aligned));

int
g1()
{
	static struct gx x = { ~1, -2, -65 };
	static struct gy y = { -2, -1, ~2 };

	return (x.a == (y.a & ~64) && x.b == y.b);
}

int
g2()
{
	static struct gx x = { ~1, -2, -1 };
	static struct gy y = { -66, -1, ~2 };

	return (x.a == y.a && (x.b & ~64) == y.b);
}

int
g3()
{
	static struct gx x = { ~1, -18, -33 };
	static struct gy y = { -66, -9, ~2 };

	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
}

int
g4()
{
	static struct gx x = { ~1, 0x0020, 0x0010 };
	static struct gy y = { 0x0200, 0x0100, ~2 };

	return ((x.a & 0x00f0) == (y.a & 0x0f00) &&
		(x.b & 0x00f0) == (y.b & 0x0f00));
}

int
g5()
{
	static struct gx x = { ~1, 0x0200, 0x0100 };
	static struct gy y = { 0x0020, 0x0010, ~2 };

	return ((x.a & 0x0f00) == (y.a & 0x00f0) &&
		(x.b & 0x0f00) == (y.b & 0x00f0));
}

int
g6()
{
	static struct gx x = { ~1, 0xfe20, 0xfd10 };
	static struct gy y = { 0xc22f, 0xc11f, ~2 };

	return ((x.a & 0x03ff) == (y.a & 0x3ff0) &&
		(x.b & 0x03ff) == (y.b & 0x3ff0));
}

int
g7()
{
	static struct gx x = { ~1, 0xc22f, 0xc11f };
	static struct gy y = { 0xfe20, 0xfd10, ~2 };

	return ((x.a & 0x3ff0) == (y.a & 0x03ff) &&
		(x.b & 0x3ff0) == (y.b & 0x03ff));
}

struct hx {
	int a:14, b:14, c:4;
} __attribute__ ((aligned));
struct hy {
	int c:4, a:14, b:14;
} __attribute__ ((aligned));

int
h1()
{
	static struct hx x = { -65, -2, ~1 };
	static struct hy y = { ~2, -1, -2 };

	return (x.a == (y.a & ~64) && x.b == y.b);
}

int
h2()
{
	static struct hx x = { -1, -2, ~1 };
	static struct hy y = { ~2, -1, -66 };

	return (x.a == y.a && (x.b & ~64) == y.b);
}

int
h3()
{
	static struct hx x = { -33, -18, ~1 };
	static struct hy y = { ~2, -9, -66 };

	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
}

int
h4()
{
	static struct hx x = { 0x0010, 0x0020, ~1 };
	static struct hy y = { ~2, 0x0100, 0x0200 };

	return ((x.a & 0x00f0) == (y.a & 0x0f00) &&
		(x.b & 0x00f0) == (y.b & 0x0f00));
}

int
h5()
{
	static struct hx x = { 0x0100, 0x0200, ~1 };
	static struct hy y = { ~2, 0x0010, 0x0020 };

	return ((x.a & 0x0f00) == (y.a & 0x00f0) &&
		(x.b & 0x0f00) == (y.b & 0x00f0));
}

int
h6()
{
	static struct hx x = { 0xfd10, 0xfe20, ~1 };
	static struct hy y = { ~2, 0xc11f, 0xc22f };

	return ((x.a & 0x03ff) == (y.a & 0x3ff0) &&
		(x.b & 0x03ff) == (y.b & 0x3ff0));
}

int
h7()
{
	static struct hx x = { 0xc11f, 0xc22f, ~1 };
	static struct hy y = { ~2, 0xfd10, 0xfe20 };

	return ((x.a & 0x3ff0) == (y.a & 0x03ff) &&
		(x.b & 0x3ff0) == (y.b & 0x03ff));
}

int
main()
{
  if (!a1 ())
    abort ();
  if (!a2 ())
    abort ();
  if (!a3 ())
    abort ();
  if (!b1 ())
    abort ();
  if (!b2 ())
    abort ();
  if (!b3 ())
    abort ();
  if (!c1 ())
    abort ();
  if (!c2 ())
    abort ();
  if (!c3 ())
    abort ();
  if (!d1 ())
    abort ();
  if (!d2 ())
    abort ();
  if (!d3 ())
    abort ();
  if (!e1 ())
    abort ();
  if (!e2 ())
    abort ();
  if (!e3 ())
    abort ();
  if (!e4 ())
    abort ();
  if (!f1 ())
    abort ();
  if (!f2 ())
    abort ();
  if (!f3 ())
    abort ();
  if (!f4 ())
    abort ();
  if (!g1 ())
    abort ();
  if (!g2 ())
    abort ();
  if (!g3 ())
    abort ();
  if (g4 ())
    abort ();
  if (g5 ())
    abort ();
  if (!g6 ())
    abort ();
  if (!g7 ())
    abort ();
  if (!h1 ())
    abort ();
  if (!h2 ())
    abort ();
  if (!h3 ())
    abort ();
  if (h4 ())
    abort ();
  if (h5 ())
    abort ();
  if (!h6 ())
    abort ();
  if (!h7 ())
    abort ();
  exit (0);
}
// source: 990404-1.c

int x[10] = { 0,1,2,3,4,5,6,7,8,9};

int
main()
{
  int niterations = 0, i;

  for (;;) {
    int i, mi, max;
    max = 0;
    for (i = 0; i < 10 ; i++) {
      if (x[i] > max) {
	max = x[i];
	mi = i;
      }
    }
    if (max == 0)
      break;
    x[mi] = 0;
    niterations++;
    if (niterations > 10)
      abort ();
  }

  exit (0);
}
// source: 990413-2.c
/* This tests for a bug in regstack that was breaking glibc's math library. */
/* { dg-skip-if "" { ! { i?86-*-* x86_64-*-* } } } */

extern void abort (void);

static __inline double
minus_zero (void)
{
  union { double __d; int __i[2]; } __x;
  __x.__i[0] = 0x0;
  __x.__i[1] = 0x80000000;
  return __x.__d;
}

static __inline long double
__atan2l (long double __y, long double __x)
{
  register long double __value;
  __asm __volatile__ ("fpatan\n\t"
		      : "=t" (__value)
		      : "0" (__x), "u" (__y)
		      : "st(1)");
  return __value;
}

static __inline long double
__sqrtl (long double __x)
{
  register long double __result;
  __asm __volatile__ ("fsqrt" : "=t" (__result) : "0" (__x));
  return __result;
}

static __inline double
asin (double __x)
{
  return __atan2l (__x, __sqrtl (1.0 - __x * __x));
}

int
main (void)
{
  double x;

  x = minus_zero();
  x = asin (x);

  if (x != 0.0) /* actually -0.0, but 0.0 == -0.0 */
    abort ();
  return 0;
}
// source: 990513-1.c
#include <string.h>

void foo (int *BM_tab, int j)
{
  int *BM_tab_base;

  BM_tab_base = BM_tab;
  BM_tab += 0400;
  while (BM_tab_base != BM_tab)
    {
      *--BM_tab = j;
      *--BM_tab = j;
      *--BM_tab = j;
      *--BM_tab = j;
    }
}

int main ()
{
  int BM_tab[0400];
  memset (BM_tab, 0, sizeof (BM_tab));
  foo (BM_tab, 6);
  if (BM_tab[0] != 6)
    abort ();
  return 0;
}
// source: 990524-1.c
char a[] = "12345";
char b[] = "12345";

void loop (char * pz, char * pzDta)
{
    for (;;) {
        switch (*(pz++) = *(pzDta++)) {
        case 0:
	    goto loopDone2;

	case '"':
	case '\\':
	    pz[-1]  = '\\';
            *(pz++) = pzDta[-1];
	}
    } loopDone2:;

  if (a - pz != b - pzDta)
    abort ();
}

main()
{
  loop (a, b);
  exit (0);
}
// source: 990525-1.c
struct blah {
    int m1, m2;
};

void die(struct blah arg)
{
    int i ;
    struct blah buf[1];

    for (i = 0; i < 1 ; buf[i++] = arg)
        ;
    if (buf[0].m1 != 1) {
        abort ();
    }
}

int main()
{
    struct blah s = { 1, 2 };

    die(s);
    exit (0);
}
// source: 990525-2.c
typedef struct {
    int v[4];
} Test1;

Test1 func2();

int func1()
{
    Test1 test;
    test = func2();

    if (test.v[0] != 10)
      abort ();
    if (test.v[1] != 20)
      abort ();
    if (test.v[2] != 30)
      abort ();
    if (test.v[3] != 40)
      abort ();
}

Test1 func2()
{
    Test1 tmp;
    tmp.v[0] = 10;
    tmp.v[1] = 20;
    tmp.v[2] = 30;
    tmp.v[3] = 40;
    return tmp;
}


int main()
{
    func1();
    exit (0);
}
// source: 990527-1.c
int sum;

void
g (int i)
{
  sum += i;
}

void
f(int j)
{
  int i;

  for (i = 0; i < 9; i++)
    {
      j++;
      g (j);
      j = 9;
    }
}

int
main ()
{
  f (0);
  if (sum != 81)
    abort ();
  exit (0);
}
// source: 990531-1.c
   unsigned long bad(int reg, unsigned long inWord)
   {
       union {
           unsigned long word;
           unsigned char byte[4];
       } data;

       data.word = inWord;
       data.byte[reg] = 0;

       return data.word;
   }

main()
{
  /* XXX This test could be generalized.  */
  if (sizeof (long) != 4)
    exit (0);

  if (bad (0, 0xdeadbeef) == 0xdeadbeef)
    abort ();
  exit (0);
}
// source: 990604-1.c
int b;
void f ()
{
  int i = 0;
  if (b == 0)
    do {
      b = i;
      i++;
    } while (i < 10);
}

int main ()
{
  f ();
  if (b != 9)
    abort ();
  return 0;
}
// source: 990628-1.c
#include <stdlib.h>

struct {
    long sqlcode;
} sqlca;


struct data_record {
    int dummy;
    int a[100];
} *data_ptr, data_tmp;


int
num_records()
{
    return 1;
}


void
fetch()
{
    static int fetch_count;

    memset(&data_tmp, 0x55, sizeof(data_tmp));
    sqlca.sqlcode = (++fetch_count > 1 ? 100 : 0);
}


void
load_data() {
    struct data_record *p;
    int num = num_records();

    data_ptr = malloc(num * sizeof(struct data_record));
    memset(data_ptr, 0xaa, num * sizeof(struct data_record));

    fetch();
    p = data_ptr;
    while (sqlca.sqlcode == 0) {
        *p++ = data_tmp;
        fetch();
    }
}


main()
{
    load_data();
    if (sizeof (int) == 2 && data_ptr[0].dummy != 0x5555)
      abort ();
    else if (sizeof (int) > 2 && data_ptr[0].dummy != 0x55555555)
      abort ();
    exit (0);
}
// source: 990804-1.c
int gfbyte ( void )
{
 return 0;
}

int main( void )
{
 int i,j,k ;

 i = gfbyte();

 i = i + 1 ;

 if ( i == 0 )
     k = -0 ;
 else
     k = i + 0 ;

 if (i != 1)
   abort ();

 k = 1 ;
 if ( k <= i)
     do
	 j = gfbyte () ;
     while ( k++ < i ) ;

 exit (0);
}
// source: 990811-1.c
struct s {long a; int b;};

int foo(int x, void *y)
{
  switch(x) {
    case 0: return ((struct s*)y)->a;
    case 1: return *(signed char*)y;
    case 2: return *(short*)y;
  }
  abort();
}

int main ()
{
  struct s s;
  short sh[10];
  signed char c[10];
  int i;

  s.a = 1;
  s.b = 2;
  for (i = 0; i < 10; i++) {
    sh[i] = i;
    c[i] = i;
  }

  if (foo(0, &s) != 1) abort();
  if (foo(1, c+3) != 3) abort();
  if (foo(2, sh+3) != 3) abort();
  exit(0);
}
// source: 990826-0.c
/*
From: niles@fan745.gsfc.nasa.gov
To: fortran@gnu.org
Subject: Re: Scary problems in g77 for RedHat 6.0. (glibc-2.1)
Date: Sun, 06 Jun 1999 23:37:23 -0400
X-UIDL: 9c1e40c572e3b306464f703461764cd5
*/

/* { dg-xfail-if "Can not call system libm.a with -msoft-float" { powerpc-*-aix* rs6000-*-aix* } { "-msoft-float" } { "" } } */

#include <stdio.h>
#include <math.h>

int
main()
{
  if (floor (0.1) != 0.)
    abort ();
  return 0;
}

/*
It will result in 36028797018963968.000000 on Alpha RedHat Linux 6.0
using glibc-2.1 at least on my 21064.  This may result in g77 bug
reports concerning the INT() function, just so you know.

	Thanks,
	Rick Niles.
*/
// source: 990827-1.c
unsigned test(unsigned one , unsigned  bit)
{
    unsigned val=  bit & 1;
    unsigned zero= one >> 1;

    val++;
    return zero + ( val>> 1 );
}

int main()
{
  if (test (1,0) != 0)
    abort ();
  if (test (1,1) != 1)
    abort ();
  if (test (1,65535) != 1)
    abort ();
  exit (0);

  return 0;
}
// source: 990829-1.c
double test (const double le, const double ri)
{
	double val = ( ri - le ) / ( ri * ( le + 1.0 ) );
	return val;
}

int main ()
{
        double retval;

	retval = test(1.0,2.0);
        if (retval < 0.24 || retval > 0.26)
	  abort ();
	exit (0);
}
// source: 990923-1.c
#define mask  0xffff0000L
#define value 0xabcd0000L

long
foo (long x)
{
  if ((x & mask) == value)
    return x & 0xffffL;
  return 1;
}

int
main (void)
{
  if (foo (value) != 0 || foo (0) != 1)
    abort ();

  exit (0);
}
// source: 991014-1.c

typedef __SIZE_TYPE__ Size_t;

#if __SIZEOF_LONG__ < __SIZEOF_POINTER__
#define bufsize ((1LL << (8 * sizeof(Size_t) - 2))-256)
#else
#define bufsize ((1L << (8 * sizeof(Size_t) - 2))-256)
#endif

struct huge_struct
{
  short buf[bufsize];
  int a;
  int b;
  int c;
  int d;
};

union huge_union
{
  int a;
  char buf[bufsize];
};

Size_t union_size()
{
  return sizeof(union huge_union);
}

Size_t struct_size()
{
  return sizeof(struct huge_struct);
}

Size_t struct_a_offset()
{
  return (Size_t)(&((struct huge_struct *) 0)->a);
}

int main()
{
  /* Check the exact sizeof value. bufsize is aligned on 256b. */
  if (union_size() != sizeof(char) * bufsize)
    abort();

  if (struct_size() != sizeof(short) * bufsize + 4*sizeof(int))
    abort();

  if (struct_a_offset() < sizeof(short) * bufsize)
    abort();

  return 0;
}
// source: 991016-1.c
/* Two of these types will, on current gcc targets, have the same
   mode but have different alias sets.  DOIT tries to get gcse to
   invalidly hoist one of the values out of the loop.  */

typedef int T0;
typedef long T1;
typedef long long T2;

int
doit(int sel, int n, void *p)
{
  T0 * const p0 = p;
  T1 * const p1 = p;
  T2 * const p2 = p;

  switch (sel)
    {
    case 0:
      do
	*p0 += *p0;
      while (--n);
      return *p0 == 0;

    case 1:
      do
	*p1 += *p1;
      while (--n);
      return *p1 == 0;

    case 2:
      do
	*p2 += *p2;
      while (--n);
      return *p2 == 0;

    default:
      abort ();
    }
}

int
main()
{
  T0 v0; T1 v1; T2 v2;

  v0 = 1; doit(0, 5, &v0);
  v1 = 1; doit(1, 5, &v1);
  v2 = 1; doit(2, 5, &v2);

  if (v0 != 32) abort ();
  if (v1 != 32) abort ();
  if (v2 != 32) abort ();

  exit (0);
}
// source: 991019-1.c
typedef struct {
     double epsilon;
} material_type;

material_type foo(double x)
{
     material_type m;

     m.epsilon = 1.0 + x;
     return m;
}

main()
{
  int i;
  material_type x;

  /* We must iterate enough times to overflow the FP stack on the
     x86.  */
  for (i = 0; i < 10; i++)
    {
      x = foo (1.0);
      if (x.epsilon != 1.0 + 1.0)
	abort ();
    }

  exit (0);
}
// source: 991023-1.c


int blah;
foo()
{
  int i;

  for (i=0 ; i< 7 ; i++)
    {
      if (i == 7 - 1)
	blah = 0xfcc;
      else
	blah = 0xfee;
    }
  return blah;
}


main()
{
  if (foo () != 0xfcc)
    abort ();
  exit (0);
}
// source: 991030-1.c
double x = 0x1.fp1;
int main()
{
  if (x !=  3.875)
    abort ();
  exit (0);
}
// source: 991112-1.c
/* This code was miscompiled at -O3 on x86.
   Reported by Jim Meyering; distilled from bash.  */

int rl_show_char (int c) { return 0; }

int rl_character_len (int c, int pos)
{
  return isprint (c) ? 1 : 2;
}

int main(void)
{
  int (*x)(int, int) = rl_character_len;
  if (x('a', 1) != 1)
    abort();
  if (x('\002', 1) != 2)
    abort();
  return 0;
}
// source: 991118-1.c
struct tmp
{
  long long int pad : 12;
  long long int field : 52;
};

struct tmp2
{
  long long int field : 52;
  long long int pad : 12;
};

struct tmp3
{
  long long int pad : 11;
  long long int field : 53;
};

struct tmp4
{
  long long int field : 53;
  long long int pad : 11;
};

struct tmp
sub (struct tmp tmp)
{
  tmp.field ^= 0x0008765412345678LL;
  return tmp;
}

struct tmp2
sub2 (struct tmp2 tmp2)
{
  tmp2.field ^= 0x0008765412345678LL;
  return tmp2;
}

struct tmp3
sub3 (struct tmp3 tmp3)
{
  tmp3.field ^= 0x0018765412345678LL;
  return tmp3;
}

struct tmp4
sub4 (struct tmp4 tmp4)
{
  tmp4.field ^= 0x0018765412345678LL;
  return tmp4;
}

struct tmp tmp = {0x123, 0x123456789ABCDLL};
struct tmp2 tmp2 = {0x123456789ABCDLL, 0x123};
struct tmp3 tmp3 = {0x123, 0x1FFFF00000000LL};
struct tmp4 tmp4 = {0x1FFFF00000000LL, 0x123};

main()
{

  if (sizeof (long long) != 8)
    exit (0);

  tmp = sub (tmp);
  tmp2 = sub2 (tmp2);

  if (tmp.pad != 0x123 || tmp.field != 0xFFF9551175BDFDB5LL)
    abort ();
  if (tmp2.pad != 0x123 || tmp2.field != 0xFFF9551175BDFDB5LL)
    abort ();

  tmp3 = sub3 (tmp3);
  tmp4 = sub4 (tmp4);
  if (tmp3.pad != 0x123 || tmp3.field != 0xFFF989AB12345678LL)
    abort ();
  if (tmp4.pad != 0x123 || tmp4.field != 0xFFF989AB12345678LL)
    abort ();
  exit (0);
}
// source: 991201-1.c
struct vc_data {
	unsigned long	space;
	unsigned char   vc_palette[16*3];
};

struct vc {
	struct vc_data *d;
};

struct vc_data a_con;
struct vc vc_cons[63] = { &a_con };
int default_red[16];
int default_grn[16];
int default_blu[16];

extern void bar(int);

void reset_palette(int currcons)
{
	int j, k;
	for (j=k=0; j<16; j++) {
		(vc_cons[currcons].d->vc_palette) [k++] = default_red[j];
		(vc_cons[currcons].d->vc_palette) [k++] = default_grn[j];
		(vc_cons[currcons].d->vc_palette) [k++] = default_blu[j];
	}
	bar(k);
}

void bar(int k)
{
	if (k != 16*3)
		abort();
}

int main()
{
	reset_palette(0);
	exit(0);
}
// source: 991202-1.c
int x, y;

int
main()
{
  x = 2;
  y = x;
  do
    {
      x = y;
      y = 2 * y;
    }
  while ( ! ((y - x) >= 20));
  exit (0);
}
// source: 991202-2.c

int
f1 ()
{
  unsigned long x, y = 1;

  x = ((y * 8192) - 216) % 16;
  return x;
}

int
main ()
{
  if (f1 () != 8)
    abort ();
  exit (0);
}
// source: 991202-3.c

unsigned int f (unsigned int a)
{
  return a * 65536 / 8;
}

unsigned int g (unsigned int a)
{
  return a * 65536;
}

unsigned int h (unsigned int a)
{
  return a / 8;
}

int main ()
{
  if (f (65536) != h (g (65536)))
    abort ();
  exit (0);
}
// source: 991216-1.c
#define VALUE 0x123456789abcdefLL
#define AFTER 0x55

void
test1 (int a, long long value, int after)
{
  if (a != 1
      || value != VALUE
      || after != AFTER)
    abort ();
}

void
test2 (int a, int b, long long value, int after)
{
  if (a != 1
      || b != 2
      || value != VALUE
      || after != AFTER)
    abort ();
}

void
test3 (int a, int b, int c, long long value, int after)
{
  if (a != 1
      || b != 2
      || c != 3
      || value != VALUE
      || after != AFTER)
    abort ();
}

void
test4 (int a, int b, int c, int d, long long value, int after)
{
  if (a != 1
      || b != 2
      || c != 3
      || d != 4
      || value != VALUE
      || after != AFTER)
    abort ();
}

void
test5 (int a, int b, int c, int d, int e, long long value, int after)
{
  if (a != 1
      || b != 2
      || c != 3
      || d != 4
      || e != 5
      || value != VALUE
      || after != AFTER)
    abort ();
}

void
test6 (int a, int b, int c, int d, int e, int f, long long value, int after)
{
  if (a != 1
      || b != 2
      || c != 3
      || d != 4
      || e != 5
      || f != 6
      || value != VALUE
      || after != AFTER)
    abort ();
}

void
test7 (int a, int b, int c, int d, int e, int f, int g, long long value, int after)
{
  if (a != 1
      || b != 2
      || c != 3
      || d != 4
      || e != 5
      || f != 6
      || g != 7
      || value != VALUE
      || after != AFTER)
    abort ();
}

void
test8 (int a, int b, int c, int d, int e, int f, int g, int h, long long value, int after)
{
  if (a != 1
      || b != 2
      || c != 3
      || d != 4
      || e != 5
      || f != 6
      || g != 7
      || h != 8
      || value != VALUE
      || after != AFTER)
    abort ();
}

int
main ()
{
  test1 (1, VALUE, AFTER);
  test2 (1, 2, VALUE, AFTER);
  test3 (1, 2, 3, VALUE, AFTER);
  test4 (1, 2, 3, 4, VALUE, AFTER);
  test5 (1, 2, 3, 4, 5, VALUE, AFTER);
  test6 (1, 2, 3, 4, 5, 6, VALUE, AFTER);
  test7 (1, 2, 3, 4, 5, 6, 7, VALUE, AFTER);
  test8 (1, 2, 3, 4, 5, 6, 7, 8, VALUE, AFTER);
  exit (0);
}
// source: 991216-2.c
#include <stdarg.h>

#define VALUE 0x123456789abcdefLL
#define AFTER 0x55

void
test (int n, ...)
{
  va_list ap;
  int i;

  va_start (ap, n);
  for (i = 2; i <= n; i++)
    {
      if (va_arg (ap, int) != i)
	abort ();
    }

  if (va_arg (ap, long long) != VALUE)
    abort ();

  if (va_arg (ap, int) != AFTER)
    abort ();

  va_end (ap);
}

int
main ()
{
  test (1, VALUE, AFTER);
  test (2, 2, VALUE, AFTER);
  test (3, 2, 3, VALUE, AFTER);
  test (4, 2, 3, 4, VALUE, AFTER);
  test (5, 2, 3, 4, 5, VALUE, AFTER);
  test (6, 2, 3, 4, 5, 6, VALUE, AFTER);
  test (7, 2, 3, 4, 5, 6, 7, VALUE, AFTER);
  test (8, 2, 3, 4, 5, 6, 7, 8, VALUE, AFTER);
  exit (0);
}
// source: 991216-4.c
/* Test against a problem with loop reversal.  */
static void bug(int size, int tries)
{
    int i;
    int num = 0;
    while (num < size)
    {
        for (i = 1; i < tries; i++) num++;
    }
}

int main()
{
    bug(5, 10);
    exit (0);
}
// source: 991221-1.c
int main( void )
{
   unsigned long totalsize = 80;
   unsigned long msize = 64;

   if (sizeof(long) != 4)
     exit(0);

   if ( totalsize > (2147483647L   * 2UL + 1)
        || (msize != 0 && ((msize - 1) > (2147483647L   * 2UL + 1) )))
      abort();
   exit( 0 );
}
// source: 991227-1.c
char* doit(int flag)
{
  return 1 + (flag ? "\0wrong\n" : "\0right\n");
}
int main()
{
  char *result = doit(0);
  if (*result == 'r' && result[1] == 'i')
    exit(0);
  abort();
}
// source: 991228-1.c
__extension__ union { double d; int i[2]; } u = { d: -0.25 };

/* This assumes the endianness of words in a long long is the same as
   that for doubles, which doesn't hold for a few platforms, but we
   can probably special case them here, as appropriate.  */
long long endianness_test = 1;
#define MSW (*(int*)&endianness_test)

int
signbit(double x)
{
  __extension__ union { double d; int i[2]; } u = { d: x };
  return u.i[MSW] < 0;
}

int main(void)
{
  if (2*sizeof(int) != sizeof(double) || u.i[MSW] >= 0)
    exit(0);

  if (!signbit(-0.25))
    abort();

  exit(0);
}
// source: alias-1.c
int val;

int *ptr = &val;
float *ptr2 = &val;

__attribute__((optimize ("-fno-strict-aliasing")))
typepun ()
{
  *ptr2=0;
}

main()
{
  *ptr=1;
  typepun ();
  if (*ptr)
    __builtin_abort ();
}
// source: alias-2.c
/* { dg-require-alias "" } */
int a[10]={};
extern int b[10] __attribute__ ((alias("a")));
int off;
main()
{
  b[off]=1;
  a[off]=2;
  if (b[off]!=2)
   __builtin_abort ();
  return 0;
}
// source: alias-3.c
/* { dg-require-alias "" } */
/* { dg-skip-if "" { powerpc-ibm-aix* } } */
static int a=0;
extern int b __attribute__ ((alias("a")));
__attribute__ ((noinline))
static inc()
{
  b++;
}
int
main()
{
  a=0;
  inc ();
  if (a!=1)
    __builtin_abort ();
  return 0;
}
// source: alias-4.c
/* { dg-require-alias "" } */
int a = 1;
extern int b __attribute__ ((alias ("a")));
int c = 1;
extern int d __attribute__ ((alias ("c")));
main (int argc)
{
  int *p;
  int *q;
  if (argc)
    p = &a, q = &b;
  else
    p = &c, q = &d;
  *p = 1;
  *q = 2;
  if (*p == 1)
    __builtin_abort ();
  return 0;
}
// source: alias-access-path-1.c
/* Test that variable
     int val;
   may hold value of tyope "struct c" which has same size.
   This is valid in GIMPLE memory model.  */

struct a {int val;} a={1},a2;
struct b {struct a a;};
int val;
struct c {struct b b;} *cptr=(void *)&val;

int
main(void)
{
  cptr->b.a=a;
  val = 2;
  a2=cptr->b.a;
  if (a2.val == a.val)
    __builtin_abort ();
}
// source: align-1.c
typedef int new_int __attribute__ ((aligned(16)));
struct S { int x; };

int main()
{
  if (sizeof(struct S) != sizeof(int))
    abort ();
  return 0;
}
// source: align-2.c
/* Simple alignment checks;
   looking for compiler/assembler alignment disagreements,
   agreement between struct initialization and access.  */
struct a_short { char c; short s; } s_c_s = { 'a', 13 };
struct a_int { char c ; int i; } s_c_i = { 'b', 14 };
struct b_int { short s; int i; } s_s_i  = { 15, 16 };
struct a_float { char c; float f; } s_c_f = { 'c', 17.0 };
struct b_float { short s; float f; } s_s_f = { 18, 19.0 };
struct a_double { char c; double d; } s_c_d = { 'd', 20.0 };
struct b_double { short s; double d; } s_s_d = { 21, 22.0 };
struct c_double { int i; double d; } s_i_d = { 23, 24.0 };
struct d_double { float f; double d; } s_f_d = { 25.0, 26.0 };
struct a_ldouble { char c; long double ld; } s_c_ld = { 'e', 27.0 };
struct b_ldouble { short s; long double ld; } s_s_ld = { 28, 29.0 };
struct c_ldouble { int i; long double ld; } s_i_ld = { 30, 31.0 };
struct d_ldouble { float f; long double ld; } s_f_ld = { 32.0, 33.0 };
struct e_ldouble { double d; long double ld; } s_d_ld = { 34.0, 35.0 };

int main ()
{
  if (s_c_s.c != 'a') abort ();
  if (s_c_s.s != 13) abort ();
  if (s_c_i.c != 'b') abort ();
  if (s_c_i.i != 14) abort ();
  if (s_s_i.s != 15) abort ();
  if (s_s_i.i != 16) abort ();
  if (s_c_f.c != 'c') abort ();
  if (s_c_f.f != 17.0) abort ();
  if (s_s_f.s != 18) abort ();
  if (s_s_f.f != 19.0) abort ();
  if (s_c_d.c != 'd') abort ();
  if (s_c_d.d != 20.0) abort ();
  if (s_s_d.s != 21) abort ();
  if (s_s_d.d != 22.0) abort ();
  if (s_i_d.i != 23) abort ();
  if (s_i_d.d != 24.0) abort ();
  if (s_f_d.f != 25.0) abort ();
  if (s_f_d.d != 26.0) abort ();
  if (s_c_ld.c != 'e') abort ();
  if (s_c_ld.ld != 27.0) abort ();
  if (s_s_ld.s != 28) abort ();
  if (s_s_ld.ld != 29.0) abort ();
  if (s_i_ld.i != 30) abort ();
  if (s_i_ld.ld != 31.0) abort ();
  if (s_f_ld.f != 32.0) abort ();
  if (s_f_ld.ld != 33.0) abort ();
  if (s_d_ld.d != 34.0) abort ();
  if (s_d_ld.ld != 35.0) abort ();
  return 0;
}
// source: align-3.c
/* { dg-skip-if "small alignment" { pdp11-*-* } } */

void func(void) __attribute__((aligned(256)));

void func(void)
{
}

int main()
{
  if (__alignof__(func) != 256)
    abort ();
  return 0;
}
// source: align-nest.c
/* { dg-skip-if "requires alloca" { ! alloca } { "-O0" } { "" } } */

void foo(int n)
{
  typedef struct
  {
    int value;
  } myint;

  struct S
  {
    int i[n];
    unsigned int b:1;
    myint mi;
  } __attribute__ ((packed)) __attribute__ ((aligned (4)));

  struct S s[2];
  int k;

  for (k = 0; k < 2; k ++)
    s[k].mi.value = 0;
}

int main ()
{
  foo (2);
  return 0;
}
// source: alloca-1.c
/* { dg-skip-if "requires alloca" { ! alloca } { "-O0" } { "" } } */
/* Verify that alloca storage is sufficiently aligned.  */
/* ??? May fail if BIGGEST_ALIGNMENT > STACK_BOUNDARY.  Which, I guess
   can only happen on !STRICT_ALIGNMENT targets.  */

typedef __SIZE_TYPE__ size_t;

struct dummy { int x __attribute__((aligned)); };
#define BIGGEST_ALIGNMENT __alignof__(struct dummy)

_Bool foo(void)
{
  char *p = __builtin_alloca(32);
  return ((size_t)p & (BIGGEST_ALIGNMENT - 1)) == 0;
}

int main()
{
  if (!foo())
    abort ();
  return 0;
}
// source: anon-1.c
/* Copyright (C) 2001 Free Software Foundation, Inc.  */

/* Source: Neil Booth, 4 Nov 2001, derived from PR 2820 - field lookup in
   nested anonymous entities was broken.  */

struct
{
  int x;
  struct
  {
    int a;
    union
    {
      int b;
    };
  };
} foo;

int
main(int argc, char *argv[])
{
  foo.b = 6;
  foo.a = 5;

  if (foo.b != 6)
    abort ();

  return 0;
}
// source: arith-1.c
unsigned
sat_add (unsigned i)
{
  unsigned ret = i + 1;
  if (ret < i)
    ret = i;
  return ret;
}

unsigned
sat_add2 (unsigned i)
{
  unsigned ret = i + 1;
  if (ret > i)
    return ret;
  return i;
}

unsigned
sat_add3 (unsigned i)
{
  unsigned ret = i - 1;
  if (ret > i)
    ret = i;
  return ret;
}

unsigned
sat_add4 (unsigned i)
{
  unsigned ret = i - 1;
  if (ret < i)
    return ret;
  return i;
}
main ()
{
  if (sat_add (~0U) != ~0U)
    abort ();
  if (sat_add2 (~0U) != ~0U)
    abort ();
  if (sat_add3 (0U) != 0U)
    abort ();
  if (sat_add4 (0U) != 0U)
    abort ();
  exit (0);
}
// source: arith-rand-ll.c
long long
simple_rand ()
{
  static unsigned long long seed = 47114711;
  unsigned long long this = seed * 1103515245 + 12345;
  seed = this;
  return this >> 8;
}

unsigned long long int
random_bitstring ()
{
  unsigned long long int x;
  int n_bits;
  long long ran;
  int tot_bits = 0;

  x = 0;
  for (;;)
    {
      ran = simple_rand ();
      n_bits = (ran >> 1) % 16;
      tot_bits += n_bits;

      if (n_bits == 0)
	return x;
      else
	{
	  x <<= n_bits;
	  if (ran & 1)
	    x |= (1 << n_bits) - 1;

	  if (tot_bits > 8 * sizeof (long long) + 6)
	    return x;
	}
    }
}

#define ABS(x) ((x) >= 0 ? (x) : -(x))

main ()
{
  long long int i;

  for (i = 0; i < 10000; i++)
    {
      unsigned long long x, y;
      x = random_bitstring ();
      y = random_bitstring ();

      if (sizeof (int) == sizeof (long long))
	goto save_time;

      { unsigned long long xx = x, yy = y, r1, r2;
	if (yy == 0) continue;
	r1 = xx / yy;
	r2 = xx % yy;
	if (r2 >= yy || r1 * yy + r2 != xx)
	  abort ();
      }
      { signed long long xx = x, yy = y, r1, r2;
	if ((unsigned long long) xx << 1 == 0 && yy == -1)
	  continue;
	r1 = xx / yy;
	r2 = xx % yy;
	if (ABS (r2) >= (unsigned long long) ABS (yy) || (signed long long) (r1 * yy + r2) != xx)
	  abort ();
      }
    save_time:
      { unsigned int xx = x, yy = y, r1, r2;
	if (yy == 0) continue;
	r1 = xx / yy;
	r2 = xx % yy;
	if (r2 >= yy || r1 * yy + r2 != xx)
	  abort ();
      }
      { signed int xx = x, yy = y, r1, r2;
	if ((unsigned int) xx << 1 == 0 && yy == -1)
	  continue;
	r1 = xx / yy;
	r2 = xx % yy;
	if (ABS (r2) >= (unsigned int) ABS (yy) || (signed int) (r1 * yy + r2) != xx || ((xx < 0) != (r2 < 0) && r2))
	  abort ();
      }
      { unsigned short xx = x, yy = y, r1, r2;
	if (yy == 0) continue;
	r1 = xx / yy;
	r2 = xx % yy;
	if (r2 >= yy || r1 * yy + r2 != xx)
	  abort ();
      }
      { signed short xx = x, yy = y, r1, r2;
	r1 = xx / yy;
	r2 = xx % yy;
	if (ABS (r2) >= (unsigned short) ABS (yy) || (signed short) (r1 * yy + r2) != xx)
	  abort ();
      }
      { unsigned char xx = x, yy = y, r1, r2;
	if (yy == 0) continue;
	r1 = xx / yy;
	r2 = xx % yy;
	if (r2 >= yy || r1 * yy + r2 != xx)
	  abort ();
      }
      { signed char xx = x, yy = y, r1, r2;
	r1 = xx / yy;
	r2 = xx % yy;
	if (ABS (r2) >= (unsigned char) ABS (yy) || (signed char) (r1 * yy + r2) != xx)
	  abort ();
      }
    }

  exit (0);
}
// source: arith-rand.c
long
simple_rand ()
{
  static unsigned long seed = 47114711;
  unsigned long this = seed * 1103515245 + 12345;
  seed = this;
  return this >> 8;
}

unsigned long int
random_bitstring ()
{
  unsigned long int x;
  int n_bits;
  long ran;
  int tot_bits = 0;

  x = 0;
  for (;;)
    {
      ran = simple_rand ();
      n_bits = (ran >> 1) % 16;
      tot_bits += n_bits;

      if (n_bits == 0)
	return x;
      else
	{
	  x <<= n_bits;
	  if (ran & 1)
	    x |= (1 << n_bits) - 1;

	  if (tot_bits > 8 * sizeof (long) + 6)
	    return x;
	}
    }
}

#define ABS(x) ((x) >= 0 ? (x) : -(x))

main ()
{
  long int i;

  for (i = 0; i < 1000; i++)
    {
      unsigned long x, y;
      x = random_bitstring ();
      y = random_bitstring ();

      if (sizeof (int) == sizeof (long))
	goto save_time;

      { unsigned long xx = x, yy = y, r1, r2;
	if (yy == 0) continue;
	r1 = xx / yy;
	r2 = xx % yy;
	if (r2 >= yy || r1 * yy + r2 != xx)
	  abort ();
      }
      { signed long xx = x, yy = y, r1, r2;
	if ((unsigned long) xx << 1 == 0 && yy == -1)
	  continue;
	r1 = xx / yy;
	r2 = xx % yy;
	if (ABS (r2) >= (unsigned long) ABS (yy) || (signed long) (r1 * yy + r2) != xx)
	  abort ();
      }
    save_time:
      { unsigned int xx = x, yy = y, r1, r2;
	if (yy == 0) continue;
	r1 = xx / yy;
	r2 = xx % yy;
	if (r2 >= yy || r1 * yy + r2 != xx)
	  abort ();
      }
      { signed int xx = x, yy = y, r1, r2;
	if ((unsigned int) xx << 1 == 0 && yy == -1)
	  continue;
	r1 = xx / yy;
	r2 = xx % yy;
	if (ABS (r2) >= (unsigned int) ABS (yy) || (signed int) (r1 * yy + r2) != xx)
	  abort ();
      }
      { unsigned short xx = x, yy = y, r1, r2;
	if (yy == 0) continue;
	r1 = xx / yy;
	r2 = xx % yy;
	if (r2 >= yy || r1 * yy + r2 != xx)
	  abort ();
      }
      { signed short xx = x, yy = y, r1, r2;
	r1 = xx / yy;
	r2 = xx % yy;
	if (ABS (r2) >= (unsigned short) ABS (yy) || (signed short) (r1 * yy + r2) != xx)
	  abort ();
      }
      { unsigned char xx = x, yy = y, r1, r2;
	if (yy == 0) continue;
	r1 = xx / yy;
	r2 = xx % yy;
	if (r2 >= yy || r1 * yy + r2 != xx)
	  abort ();
      }
      { signed char xx = x, yy = y, r1, r2;
	r1 = xx / yy;
	r2 = xx % yy;
	if (ABS (r2) >= (unsigned char) ABS (yy) || (signed char) (r1 * yy + r2) != xx)
	  abort ();
      }
    }

  exit (0);
}
// source: ashldi-1.c
#include <limits.h>

extern void abort(void);
extern void exit(int);

#if __LONG_LONG_MAX__ == 9223372036854775807LL
#define BITS 64

static unsigned long long const data[64] = {
  0x123456789abcdefULL,
  0x2468acf13579bdeULL,
  0x48d159e26af37bcULL,
  0x91a2b3c4d5e6f78ULL,
  0x123456789abcdef0ULL,
  0x2468acf13579bde0ULL,
  0x48d159e26af37bc0ULL,
  0x91a2b3c4d5e6f780ULL,
  0x23456789abcdef00ULL,
  0x468acf13579bde00ULL,
  0x8d159e26af37bc00ULL,
  0x1a2b3c4d5e6f7800ULL,
  0x3456789abcdef000ULL,
  0x68acf13579bde000ULL,
  0xd159e26af37bc000ULL,
  0xa2b3c4d5e6f78000ULL,
  0x456789abcdef0000ULL,
  0x8acf13579bde0000ULL,
  0x159e26af37bc0000ULL,
  0x2b3c4d5e6f780000ULL,
  0x56789abcdef00000ULL,
  0xacf13579bde00000ULL,
  0x59e26af37bc00000ULL,
  0xb3c4d5e6f7800000ULL,
  0x6789abcdef000000ULL,
  0xcf13579bde000000ULL,
  0x9e26af37bc000000ULL,
  0x3c4d5e6f78000000ULL,
  0x789abcdef0000000ULL,
  0xf13579bde0000000ULL,
  0xe26af37bc0000000ULL,
  0xc4d5e6f780000000ULL,
  0x89abcdef00000000ULL,
  0x13579bde00000000ULL,
  0x26af37bc00000000ULL,
  0x4d5e6f7800000000ULL,
  0x9abcdef000000000ULL,
  0x3579bde000000000ULL,
  0x6af37bc000000000ULL,
  0xd5e6f78000000000ULL,
  0xabcdef0000000000ULL,
  0x579bde0000000000ULL,
  0xaf37bc0000000000ULL,
  0x5e6f780000000000ULL,
  0xbcdef00000000000ULL,
  0x79bde00000000000ULL,
  0xf37bc00000000000ULL,
  0xe6f7800000000000ULL,
  0xcdef000000000000ULL,
  0x9bde000000000000ULL,
  0x37bc000000000000ULL,
  0x6f78000000000000ULL,
  0xdef0000000000000ULL,
  0xbde0000000000000ULL,
  0x7bc0000000000000ULL,
  0xf780000000000000ULL,
  0xef00000000000000ULL,
  0xde00000000000000ULL,
  0xbc00000000000000ULL,
  0x7800000000000000ULL,
  0xf000000000000000ULL,
  0xe000000000000000ULL,
  0xc000000000000000ULL,
  0x8000000000000000ULL
};

#elif __LONG_LONG_MAX__ == 2147483647LL
#define BITS 32

static unsigned long long const data[32] = {
  0x1234567fULL,
  0x2468acfeULL,
  0x48d159fcULL,
  0x91a2b3f8ULL,
  0x234567f0ULL,
  0x468acfe0ULL,
  0x8d159fc0ULL,
  0x1a2b3f80ULL,
  0x34567f00ULL,
  0x68acfe00ULL,
  0xd159fc00ULL,
  0xa2b3f800ULL,
  0x4567f000ULL,
  0x8acfe000ULL,
  0x159fc000ULL,
  0x2b3f8000ULL,
  0x567f0000ULL,
  0xacfe0000ULL,
  0x59fc0000ULL,
  0xb3f80000ULL,
  0x67f00000ULL,
  0xcfe00000ULL,
  0x9fc00000ULL,
  0x3f800000ULL,
  0x7f000000ULL,
  0xfe000000ULL,
  0xfc000000ULL,
  0xf8000000ULL,
  0xf0000000ULL,
  0xe0000000ULL,
  0xc0000000ULL,
  0x80000000ULL
};

#else
#error "Update the test case."
#endif

static unsigned long long
variable_shift(unsigned long long x, int i)
{
  return x << i;
}

static unsigned long long
constant_shift(unsigned long long x, int i)
{
  switch (i)
    {
    case 0: x = x << 0; break;
    case 1: x = x << 1; break;
    case 2: x = x << 2; break;
    case 3: x = x << 3; break;
    case 4: x = x << 4; break;
    case 5: x = x << 5; break;
    case 6: x = x << 6; break;
    case 7: x = x << 7; break;
    case 8: x = x << 8; break;
    case 9: x = x << 9; break;
    case 10: x = x << 10; break;
    case 11: x = x << 11; break;
    case 12: x = x << 12; break;
    case 13: x = x << 13; break;
    case 14: x = x << 14; break;
    case 15: x = x << 15; break;
    case 16: x = x << 16; break;
    case 17: x = x << 17; break;
    case 18: x = x << 18; break;
    case 19: x = x << 19; break;
    case 20: x = x << 20; break;
    case 21: x = x << 21; break;
    case 22: x = x << 22; break;
    case 23: x = x << 23; break;
    case 24: x = x << 24; break;
    case 25: x = x << 25; break;
    case 26: x = x << 26; break;
    case 27: x = x << 27; break;
    case 28: x = x << 28; break;
    case 29: x = x << 29; break;
    case 30: x = x << 30; break;
    case 31: x = x << 31; break;
#if BITS > 32
    case 32: x = x << 32; break;
    case 33: x = x << 33; break;
    case 34: x = x << 34; break;
    case 35: x = x << 35; break;
    case 36: x = x << 36; break;
    case 37: x = x << 37; break;
    case 38: x = x << 38; break;
    case 39: x = x << 39; break;
    case 40: x = x << 40; break;
    case 41: x = x << 41; break;
    case 42: x = x << 42; break;
    case 43: x = x << 43; break;
    case 44: x = x << 44; break;
    case 45: x = x << 45; break;
    case 46: x = x << 46; break;
    case 47: x = x << 47; break;
    case 48: x = x << 48; break;
    case 49: x = x << 49; break;
    case 50: x = x << 50; break;
    case 51: x = x << 51; break;
    case 52: x = x << 52; break;
    case 53: x = x << 53; break;
    case 54: x = x << 54; break;
    case 55: x = x << 55; break;
    case 56: x = x << 56; break;
    case 57: x = x << 57; break;
    case 58: x = x << 58; break;
    case 59: x = x << 59; break;
    case 60: x = x << 60; break;
    case 61: x = x << 61; break;
    case 62: x = x << 62; break;
    case 63: x = x << 63; break;
#endif

    default:
      abort ();
    }
  return x;
}

int
main()
{
  int i;

  for (i = 0; i < BITS; ++i)
    {
      unsigned long long y = variable_shift (data[0], i);
      if (y != data[i])
	abort ();
    }
  for (i = 0; i < BITS; ++i)
    {
      unsigned long long y = constant_shift (data[0], i);
      if (y != data[i])
	abort ();
    }

  exit (0);
}
// source: ashrdi-1.c
#include <limits.h>

extern void abort(void);
extern void exit(int);

#if __LONG_LONG_MAX__ == 9223372036854775807LL
#define BITS 64

static long long const zext[64] = {
  0x7654321fedcba980LL,
  0x3b2a190ff6e5d4c0LL,
  0x1d950c87fb72ea60LL,
  0xeca8643fdb97530LL,
  0x7654321fedcba98LL,
  0x3b2a190ff6e5d4cLL,
  0x1d950c87fb72ea6LL,
  0xeca8643fdb9753LL,
  0x7654321fedcba9LL,
  0x3b2a190ff6e5d4LL,
  0x1d950c87fb72eaLL,
  0xeca8643fdb975LL,
  0x7654321fedcbaLL,
  0x3b2a190ff6e5dLL,
  0x1d950c87fb72eLL,
  0xeca8643fdb97LL,
  0x7654321fedcbLL,
  0x3b2a190ff6e5LL,
  0x1d950c87fb72LL,
  0xeca8643fdb9LL,
  0x7654321fedcLL,
  0x3b2a190ff6eLL,
  0x1d950c87fb7LL,
  0xeca8643fdbLL,
  0x7654321fedLL,
  0x3b2a190ff6LL,
  0x1d950c87fbLL,
  0xeca8643fdLL,
  0x7654321feLL,
  0x3b2a190ffLL,
  0x1d950c87fLL,
  0xeca8643fLL,
  0x7654321fLL,
  0x3b2a190fLL,
  0x1d950c87LL,
  0xeca8643LL,
  0x7654321LL,
  0x3b2a190LL,
  0x1d950c8LL,
  0xeca864LL,
  0x765432LL,
  0x3b2a19LL,
  0x1d950cLL,
  0xeca86LL,
  0x76543LL,
  0x3b2a1LL,
  0x1d950LL,
  0xeca8LL,
  0x7654LL,
  0x3b2aLL,
  0x1d95LL,
  0xecaLL,
  0x765LL,
  0x3b2LL,
  0x1d9LL,
  0xecLL,
  0x76LL,
  0x3bLL,
  0x1dLL,
  0xeLL,
  0x7LL,
  0x3LL,
  0x1LL,
  0LL
};

static long long const sext[64] = {
  0x8edcba9f76543210LL,
  0xc76e5d4fbb2a1908LL,
  0xe3b72ea7dd950c84LL,
  0xf1db9753eeca8642LL,
  0xf8edcba9f7654321LL,
  0xfc76e5d4fbb2a190LL,
  0xfe3b72ea7dd950c8LL,
  0xff1db9753eeca864LL,
  0xff8edcba9f765432LL,
  0xffc76e5d4fbb2a19LL,
  0xffe3b72ea7dd950cLL,
  0xfff1db9753eeca86LL,
  0xfff8edcba9f76543LL,
  0xfffc76e5d4fbb2a1LL,
  0xfffe3b72ea7dd950LL,
  0xffff1db9753eeca8LL,
  0xffff8edcba9f7654LL,
  0xffffc76e5d4fbb2aLL,
  0xffffe3b72ea7dd95LL,
  0xfffff1db9753eecaLL,
  0xfffff8edcba9f765LL,
  0xfffffc76e5d4fbb2LL,
  0xfffffe3b72ea7dd9LL,
  0xffffff1db9753eecLL,
  0xffffff8edcba9f76LL,
  0xffffffc76e5d4fbbLL,
  0xffffffe3b72ea7ddLL,
  0xfffffff1db9753eeLL,
  0xfffffff8edcba9f7LL,
  0xfffffffc76e5d4fbLL,
  0xfffffffe3b72ea7dLL,
  0xffffffff1db9753eLL,
  0xffffffff8edcba9fLL,
  0xffffffffc76e5d4fLL,
  0xffffffffe3b72ea7LL,
  0xfffffffff1db9753LL,
  0xfffffffff8edcba9LL,
  0xfffffffffc76e5d4LL,
  0xfffffffffe3b72eaLL,
  0xffffffffff1db975LL,
  0xffffffffff8edcbaLL,
  0xffffffffffc76e5dLL,
  0xffffffffffe3b72eLL,
  0xfffffffffff1db97LL,
  0xfffffffffff8edcbLL,
  0xfffffffffffc76e5LL,
  0xfffffffffffe3b72LL,
  0xffffffffffff1db9LL,
  0xffffffffffff8edcLL,
  0xffffffffffffc76eLL,
  0xffffffffffffe3b7LL,
  0xfffffffffffff1dbLL,
  0xfffffffffffff8edLL,
  0xfffffffffffffc76LL,
  0xfffffffffffffe3bLL,
  0xffffffffffffff1dLL,
  0xffffffffffffff8eLL,
  0xffffffffffffffc7LL,
  0xffffffffffffffe3LL,
  0xfffffffffffffff1LL,
  0xfffffffffffffff8LL,
  0xfffffffffffffffcLL,
  0xfffffffffffffffeLL,
  0xffffffffffffffffLL
};

#elif __LONG_LONG_MAX__ == 2147483647LL
#define BITS 32

static long long const zext[32] = {
  0x76543218LL,
  0x3b2a190cLL,
  0x1d950c86LL,
  0xeca8643LL,
  0x7654321LL,
  0x3b2a190LL,
  0x1d950c8LL,
  0xeca864LL,
  0x765432LL,
  0x3b2a19LL,
  0x1d950cLL,
  0xeca86LL,
  0x76543LL,
  0x3b2a1LL,
  0x1d950LL,
  0xeca8LL,
  0x7654LL,
  0x3b2aLL,
  0x1d95LL,
  0xecaLL,
  0x765LL,
  0x3b2LL,
  0x1d9LL,
  0xecLL,
  0x76LL,
  0x3bLL,
  0x1dLL,
  0xeLL,
  0x7LL,
  0x3LL,
  0x1LL,
  0LL
};

static long long const sext[64] = {
  0x87654321LL,
  0xc3b2a190LL,
  0xe1d950c8LL,
  0xf0eca864LL,
  0xf8765432LL,
  0xfc3b2a19LL,
  0xfe1d950cLL,
  0xff0eca86LL,
  0xff876543LL,
  0xffc3b2a1LL,
  0xffe1d950LL,
  0xfff0eca8LL,
  0xfff87654LL,
  0xfffc3b2aLL,
  0xfffe1d95LL,
  0xffff0ecaLL,
  0xffff8765LL,
  0xffffc3b2LL,
  0xffffe1d9LL,
  0xfffff0ecLL,
  0xfffff876LL,
  0xfffffc3bLL,
  0xfffffe1dLL,
  0xffffff0eLL,
  0xffffff87LL,
  0xffffffc3LL,
  0xffffffe1LL,
  0xfffffff0LL,
  0xfffffff8LL,
  0xfffffffcLL,
  0xfffffffeLL,
  0xffffffffLL
};

#else
#error "Update the test case."
#endif

static long long
variable_shift(long long x, int i)
{
  return x >> i;
}

static long long
constant_shift(long long x, int i)
{
  switch (i)
    {
    case 0: x = x >> 0; break;
    case 1: x = x >> 1; break;
    case 2: x = x >> 2; break;
    case 3: x = x >> 3; break;
    case 4: x = x >> 4; break;
    case 5: x = x >> 5; break;
    case 6: x = x >> 6; break;
    case 7: x = x >> 7; break;
    case 8: x = x >> 8; break;
    case 9: x = x >> 9; break;
    case 10: x = x >> 10; break;
    case 11: x = x >> 11; break;
    case 12: x = x >> 12; break;
    case 13: x = x >> 13; break;
    case 14: x = x >> 14; break;
    case 15: x = x >> 15; break;
    case 16: x = x >> 16; break;
    case 17: x = x >> 17; break;
    case 18: x = x >> 18; break;
    case 19: x = x >> 19; break;
    case 20: x = x >> 20; break;
    case 21: x = x >> 21; break;
    case 22: x = x >> 22; break;
    case 23: x = x >> 23; break;
    case 24: x = x >> 24; break;
    case 25: x = x >> 25; break;
    case 26: x = x >> 26; break;
    case 27: x = x >> 27; break;
    case 28: x = x >> 28; break;
    case 29: x = x >> 29; break;
    case 30: x = x >> 30; break;
    case 31: x = x >> 31; break;
#if BITS > 32
    case 32: x = x >> 32; break;
    case 33: x = x >> 33; break;
    case 34: x = x >> 34; break;
    case 35: x = x >> 35; break;
    case 36: x = x >> 36; break;
    case 37: x = x >> 37; break;
    case 38: x = x >> 38; break;
    case 39: x = x >> 39; break;
    case 40: x = x >> 40; break;
    case 41: x = x >> 41; break;
    case 42: x = x >> 42; break;
    case 43: x = x >> 43; break;
    case 44: x = x >> 44; break;
    case 45: x = x >> 45; break;
    case 46: x = x >> 46; break;
    case 47: x = x >> 47; break;
    case 48: x = x >> 48; break;
    case 49: x = x >> 49; break;
    case 50: x = x >> 50; break;
    case 51: x = x >> 51; break;
    case 52: x = x >> 52; break;
    case 53: x = x >> 53; break;
    case 54: x = x >> 54; break;
    case 55: x = x >> 55; break;
    case 56: x = x >> 56; break;
    case 57: x = x >> 57; break;
    case 58: x = x >> 58; break;
    case 59: x = x >> 59; break;
    case 60: x = x >> 60; break;
    case 61: x = x >> 61; break;
    case 62: x = x >> 62; break;
    case 63: x = x >> 63; break;
#endif

    default:
      abort ();
    }
  return x;
}

int
main()
{
  int i;

  for (i = 0; i < BITS; ++i)
    {
      long long y = variable_shift (zext[0], i);
      if (y != zext[i])
	abort ();
    }
  for (i = 0; i < BITS; ++i)
    {
      long long y = variable_shift (sext[0], i);
      if (y != sext[i])
	abort ();
    }
  for (i = 0; i < BITS; ++i)
    {
      long long y = constant_shift (zext[0], i);
      if (y != zext[i])
	abort ();
    }
  for (i = 0; i < BITS; ++i)
    {
      long long y = constant_shift (sext[0], i);
      if (y != sext[i])
	abort ();
    }

  exit (0);
}
// source: bcp-1.c
/* { dg-options "-fgnu89-inline" } */

extern void abort (void);
extern void exit (int);

__attribute__ ((externally_visible)) int global;
int func(void);

/* These must fail.  */
int bad0(void) { return __builtin_constant_p(global); }
int bad1(void) { return __builtin_constant_p(global++); }
inline int bad2(int x) { return __builtin_constant_p(x++); }
inline int bad3(int x) { return __builtin_constant_p(x); }
inline int bad4(const char *x) { return __builtin_constant_p(x); }
int bad5(void) { return bad2(1); }
inline int bad6(int x) { return __builtin_constant_p(x+1); }
int bad7(void) { return __builtin_constant_p(func()); }
int bad8(void) { char buf[10]; return __builtin_constant_p(buf); }
int bad9(const char *x) { return __builtin_constant_p(x[123456]); }
int bad10(void) { return __builtin_constant_p(&global); }

/* These must pass, or we've broken gcc2 functionality.  */
int good0(void) { return __builtin_constant_p(1); }
int good1(void) { return __builtin_constant_p("hi"); }
int good2(void) { return __builtin_constant_p((1234 + 45) & ~7); }

/* These are extensions to gcc2.  Failure indicates an optimization
   regression.  */
int opt0(void) { return bad3(1); }
int opt1(void) { return bad6(1); }
int opt2(void) { return __builtin_constant_p("hi"[0]); }

/*
 * Opt3 is known to fail.  It is one of the important cases that glibc
 * was interested in though, so keep this around as a reminder.
 *
 * The solution is to add bits to recover bytes from constant pool
 * elements given nothing but a constant pool label and an offset.
 * When we can do that, and we can simplify strlen after the fact,
 * then we can enable recognition of constant pool labels as constants.
 */

/* int opt3(void) { return bad4("hi"); } */


/* Call through tables so -finline-functions can't screw with us.  */
int (* volatile bad_t0[])(void) = {
	bad0, bad1, bad5, bad7, bad8, bad10
};

int (* volatile bad_t1[])(int x) = {
	bad2, bad3, bad6
};

int (* volatile bad_t2[])(const char *x) = {
	bad4, bad9
};

int (* volatile good_t0[])(void) = {
	good0, good1, good2
};

int (* volatile opt_t0[])(void) = {
	opt0, opt1, opt2 /* , opt3 */
};

#define N(arr) (sizeof(arr)/sizeof(*arr))

int main()
{
  int i;

  for (i = 0; i < N(bad_t0); ++i)
    if ((*bad_t0[i])())
      abort();

  for (i = 0; i < N(bad_t1); ++i)
    if ((*bad_t1[i])(1))
      abort();

  for (i = 0; i < N(bad_t2); ++i)
    if ((*bad_t2[i])("hi"))
      abort();

  for (i = 0; i < N(good_t0); ++i)
    if (! (*good_t0[i])())
      abort();

#ifdef __OPTIMIZE__
  for (i = 0; i < N(opt_t0); ++i)
    if (! (*opt_t0[i])())
      abort();
#endif

  exit(0);
}
// source: bf-layout-1.c
struct { long f8:8; long f24:24; } a;
struct { long f32:32; } b;

main ()
{
  if (sizeof (a) != sizeof (b))
    abort ();
  exit (0);
}
// source: bf-pack-1.c
struct foo
{
  unsigned half:16;
  unsigned long whole:32 __attribute__ ((packed));
};

f (struct foo *q)
{
  if (q->half != 0x1234)
    abort ();
  if (q->whole != 0x56789abcL)
    abort ();
}

main ()
{
  struct foo bar;

  bar.half = 0x1234;
  bar.whole = 0x56789abcL;
  f (&bar);
  exit (0);
}
// source: bf-sign-1.c
main ()
{
  struct  {
    signed int s:3;
    unsigned int u:3;
    int i:3;
  } x = {-1, -1, -1};

  if (x.u != 7)
    abort ();
  if (x.s != - 1)
    abort ();

  if (x.i != -1 && x.i != 7)
    abort ();

  exit (0);
}
// source: bf-sign-2.c
/*
 This test checks promotion of bitfields.  Bitfields should be promoted
 very much like chars and shorts:

 Bitfields (signed or unsigned) should be promoted to signed int if their
 value will fit in a signed int, otherwise to an unsigned int if their
 value will fit in an unsigned int, otherwise we don't promote them (ANSI/ISO
 does not specify the behavior of bitfields larger than an unsigned int).

 We test the behavior by subtracting two from the promoted value: this will
 result in a negitive value for signed types, a positive value for unsigned
 types.  This test (of course) assumes that the compiler is correctly
 implementing signed and unsigned arithmetic.
 */

struct X {
  unsigned int	     u3:3;
    signed long int  s31:31;
    signed long int  s32:32;
  unsigned long int  u31:31;
  unsigned long int  u32:32;
  unsigned long long ull3 :3;
  unsigned long long ull35:35;
  unsigned u15:15;
};

struct X x;

main ()
{
  if ((x.u3 - 2) >= 0)		/* promoted value should be signed */
    abort ();

  if ((x.s31 - 2) >= 0)		/* promoted value should be signed */
    abort ();

  if ((x.s32 - 2) >= 0)		/* promoted value should be signed */
    abort ();

  if ((x.u15 - 2) >= 0)		/* promoted value should be signed */
    abort ();

  /* Conditionalize check on whether integers are 4 bytes or larger, i.e.
     larger than a 31 bit bitfield.  */
  if (sizeof (int) >= 4)
    {
      if ((x.u31 - 2) >= 0)	/* promoted value should be signed */
	abort ();
    }
  else
    {
      if ((x.u31 - 2) < 0)	/* promoted value should be UNsigned */
	abort ();
    }

  if ((x.u32 - 2) < 0)		/* promoted value should be UNsigned */
    abort ();

  if ((x.ull3 - 2) >= 0)	/* promoted value should be signed */
    abort ();

  if ((x.ull35 - 2) < 0)	/* promoted value should be UNsigned */
    abort ();

  exit (0);
}
// source: bf64-1.c
/* { dg-xfail-if "ABI specifies bitfields cannot exceed 32 bits" { mcore-*-* } } */
struct tmp
{
  long long int pad : 12;
  long long int field : 52;
};

struct tmp2
{
  long long int field : 52;
  long long int pad : 12;
};

struct tmp
sub (struct tmp tmp)
{
  tmp.field |= 0x0008765412345678LL;
  return tmp;
}

struct tmp2
sub2 (struct tmp2 tmp2)
{
  tmp2.field |= 0x0008765412345678LL;
  return tmp2;
}

main()
{
  struct tmp tmp = {0x123, 0xFFF000FFF000FLL};
  struct tmp2 tmp2 = {0xFFF000FFF000FLL, 0x123};

  tmp = sub (tmp);
  tmp2 = sub2 (tmp2);

  if (tmp.pad != 0x123 || tmp.field != 0xFFFFFF541FFF567FLL)
    abort ();
  if (tmp2.pad != 0x123 || tmp2.field != 0xFFFFFF541FFF567FLL)
    abort ();
  exit (0);
}
// source: bitfld-1.c
/* Copyright 2002 Free Software Foundation, Inc.

   Tests correct signedness of operations on bitfields; in particular
   that integer promotions are done correctly, including the case when
   casts are present.

   The C front end was eliding the cast of an unsigned bitfield to
   unsigned as a no-op, when in fact it forces a conversion to a
   full-width unsigned int. (At the time of writing, the C++ front end
   has a different bug; it erroneously promotes the uncast unsigned
   bitfield to an unsigned int).

   Source: Neil Booth, 25 Jan 2002, based on PR 3325 (and 3326, which
   is a different manifestation of the same bug).
*/

extern void abort ();

int
main(int argc, char *argv[])
{
  struct x { signed int i : 7; unsigned int u : 7; } bit;

  unsigned int u;
  int i;
  unsigned int unsigned_result = -13U % 61;
  int signed_result = -13 % 61;

  bit.u = 61, u = 61;
  bit.i = -13, i = -13;

  if (i % u != unsigned_result)
    abort ();
  if (i % (unsigned int) u != unsigned_result)
    abort ();

  /* Somewhat counter-intuitively, bit.u is promoted to an int, making
     the operands and result an int.  */
  if (i % bit.u != signed_result)
    abort ();

  if (bit.i % bit.u != signed_result)
    abort ();

  /* But with a cast to unsigned int, the unsigned int is promoted to
     itself as a no-op, and the operands and result are unsigned.  */
  if (i % (unsigned int) bit.u != unsigned_result)
    abort ();

  if (bit.i % (unsigned int) bit.u != unsigned_result)
    abort ();

  return 0;
}
// source: bitfld-2.c
/* Test whether bit field boundaries aren't advanced if bit field type
   has alignment large enough.  */
extern void abort (void);
extern void exit (int);

struct A {
  unsigned short a : 5;
  unsigned short b : 5;
  unsigned short c : 6;
};

struct B {
  unsigned short a : 5;
  unsigned short b : 3;
  unsigned short c : 8;
};

int main ()
{
  /* If short is not at least 16 bits wide, don't test anything.  */
  if ((unsigned short) 65521 != 65521)
    exit (0);

  if (sizeof (struct A) != sizeof (struct B))
    abort ();

  exit (0);
}
// source: bitfld-3.c
/* Test that operations on bit-fields yield results reduced to bit-field
   type.  */
/* Origin: Joseph Myers <jsm@polyomino.org.uk> */

extern void exit (int);
extern void abort (void);

struct s {
  unsigned long long u33: 33;
  unsigned long long u40: 40;
  unsigned long long u41: 41;
};

struct s a = { 0x100000, 0x100000, 0x100000 };
struct s b = { 0x100000000ULL, 0x100000000ULL, 0x100000000ULL };
struct s c = { 0x1FFFFFFFFULL, 0, 0 };

int
main (void)
{
  if (a.u33 * a.u33 != 0 || a.u33 * a.u40 != 0 || a.u40 * a.u33 != 0
      || a.u40 * a.u40 != 0)
    abort ();
  if (a.u33 * a.u41 != 0x10000000000ULL
      || a.u40 * a.u41 != 0x10000000000ULL
      || a.u41 * a.u33 != 0x10000000000ULL
      || a.u41 * a.u40 != 0x10000000000ULL
      || a.u41 * a.u41 != 0x10000000000ULL)
    abort ();
  if (b.u33 + b.u33 != 0)
    abort ();
  if (b.u33 + b.u40 != 0x200000000ULL
      || b.u33 + b.u41 != 0x200000000ULL
      || b.u40 + b.u33 != 0x200000000ULL
      || b.u40 + b.u40 != 0x200000000ULL
      || b.u40 + b.u41 != 0x200000000ULL
      || b.u41 + b.u33 != 0x200000000ULL
      || b.u41 + b.u40 != 0x200000000ULL
      || b.u41 + b.u41 != 0x200000000ULL)
    abort ();
  if (a.u33 - b.u33 != 0x100100000ULL
      || a.u33 - b.u40 != 0xFF00100000ULL
      || a.u33 - b.u41 != 0x1FF00100000ULL
      || a.u40 - b.u33 != 0xFF00100000ULL
      || a.u40 - b.u40 != 0xFF00100000ULL
      || a.u40 - b.u41 != 0x1FF00100000ULL
      || a.u41 - b.u33 != 0x1FF00100000ULL
      || a.u41 - b.u40 != 0x1FF00100000ULL
      || a.u41 - b.u41 != 0x1FF00100000ULL)
    abort ();
  if (++c.u33 != 0 || --c.u40 != 0xFFFFFFFFFFULL || c.u41-- != 0)
    abort ();
  exit (0);
}
// source: bitfld-4.c
/* When comparisons of bit-fields to unsigned constants got shortened,
   the shortened signed constant was wrongly marked as overflowing,
   leading to a later integer_zerop failure and misoptimization.

   Related to bug tree-optimization/16437 but shows the problem on
   32-bit systems.  */
/* Origin: Joseph Myers <jsm@polyomino.org.uk> */

/* { dg-require-effective-target int32plus } */

extern void abort (void);

struct s { int a:12, b:20; };

struct s x = { -123, -456 };

int
main (void)
{
  if (x.a != -123U || x.b != -456U)
    abort ();
  return 0;
}
// source: bitfld-5.c
/* See http://gcc.gnu.org/ml/gcc/2009-06/msg00072.html.  */

extern void abort (void);

struct s
{
  unsigned long long a:2;
  unsigned long long b:40;
  unsigned long long c:22;
};

__attribute__ ((noinline)) void
g (unsigned long long a, unsigned long long b)
{
  asm ("");
  if (a != b)
    abort ();
}

__attribute__ ((noinline)) void
f (struct s s, unsigned long long b)
{
  asm ("");
  g (((unsigned long long) (s.b-8)) + 8, b);
}

int
main ()
{
  struct s s = {1, 10, 3};
  struct s t = {1, 2, 3};
  f (s, 10);
  f (t, 0x10000000002);
  return 0;
}
// source: bitfld-6.c
/* { dg-require-effective-target int32plus } */
union U
{
  const int a;
  unsigned b : 20;
};

static union U u = { 0x12345678 };

/* Constant folding used to fail to account for endianness when folding a
   union.  */

int
main (void)
{
#ifdef __BYTE_ORDER__
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  return u.b - 0x45678;
#else
  return u.b - 0x12345;
#endif
#endif
  return 0;
}
// source: bitfld-7.c
/* { dg-require-effective-target int32plus } */
union U
{
  const int a;
  unsigned b : 24;
};

static union U u = { 0x12345678 };

/* Constant folding used to fail to account for endianness when folding a
   union.  */

int
main (void)
{
#ifdef __BYTE_ORDER__
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  return u.b - 0x345678;
#else
  return u.b - 0x123456;
#endif
#endif
  return 0;
}
// source: bswap-1.c
/* Test __builtin_bswap64 . */

unsigned long long g(unsigned long long a) __attribute__((noinline));
unsigned long long g(unsigned long long a)
{
  return __builtin_bswap64(a);
}


unsigned long long f(unsigned long long c)
{
  union {
    unsigned long long a;
    unsigned char b[8];
  } a, b;
  a.a = c;
  b.b[0] = a.b[7];
  b.b[1] = a.b[6];
  b.b[2] = a.b[5];
  b.b[3] = a.b[4];
  b.b[4] = a.b[3];
  b.b[5] = a.b[2];
  b.b[6] = a.b[1];
  b.b[7] = a.b[0];
  return b.a;
}

int main(void)
{
  unsigned long long i;
  /* The rest of the testcase assumes 8 byte long long. */
  if (sizeof(i) != sizeof(char)*8)
    return 0;
  if (f(0x12) != g(0x12))
    __builtin_abort();
  if (f(0x1234) != g(0x1234))
    __builtin_abort();
  if (f(0x123456) != g(0x123456))
    __builtin_abort();
  if (f(0x12345678ull) != g(0x12345678ull))
    __builtin_abort();
  if (f(0x1234567890ull) != g(0x1234567890ull))
    __builtin_abort();
  if (f(0x123456789012ull) != g(0x123456789012ull))
    __builtin_abort();
  if (f(0x12345678901234ull) != g(0x12345678901234ull))
    __builtin_abort();
  if (f(0x1234567890123456ull) != g(0x1234567890123456ull))
    __builtin_abort();
  return 0;
}
// source: bswap-2.c
/* { dg-require-effective-target int32plus } */

#ifdef __UINT32_TYPE__
typedef __UINT32_TYPE__ uint32_t;
#else
typedef __UINT32_TYPE__ unsigned;
#endif

struct bitfield {
  unsigned char f0:7;
  unsigned char   :1;
  unsigned char f1:7;
  unsigned char   :1;
  unsigned char f2:7;
  unsigned char   :1;
  unsigned char f3:7;
};

struct ok {
  unsigned char f0;
  unsigned char f1;
  unsigned char f2;
  unsigned char f3;
};

union bf_or_uint32 {
  struct ok inval;
  struct bitfield bfval;
};

__attribute__ ((noinline, noclone)) uint32_t
partial_read_le32 (union bf_or_uint32 in)
{
  return in.bfval.f0 | (in.bfval.f1 << 8)
	 | (in.bfval.f2 << 16) | (in.bfval.f3 << 24);
}

__attribute__ ((noinline, noclone)) uint32_t
partial_read_be32 (union bf_or_uint32 in)
{
  return in.bfval.f3 | (in.bfval.f2 << 8)
	 | (in.bfval.f1 << 16) | (in.bfval.f0 << 24);
}

__attribute__ ((noinline, noclone)) uint32_t
fake_read_le32 (char *x, char *y)
{
  unsigned char c0, c1, c2, c3;

  c0 = x[0];
  c1 = x[1];
  *y = 1;
  c2 = x[2];
  c3 = x[3];
  return c0 | c1 << 8 | c2 << 16 | c3 << 24;
}

__attribute__ ((noinline, noclone)) uint32_t
fake_read_be32 (char *x, char *y)
{
  unsigned char c0, c1, c2, c3;

  c0 = x[0];
  c1 = x[1];
  *y = 1;
  c2 = x[2];
  c3 = x[3];
  return c3 | c2 << 8 | c1 << 16 | c0 << 24;
}

__attribute__ ((noinline, noclone)) uint32_t
incorrect_read_le32 (char *x, char *y)
{
  unsigned char c0, c1, c2, c3;

  c0 = x[0];
  c1 = x[1];
  c2 = x[2];
  c3 = x[3];
  *y = 1;
  return c0 | c1 << 8 | c2 << 16 | c3 << 24;
}

__attribute__ ((noinline, noclone)) uint32_t
incorrect_read_be32 (char *x, char *y)
{
  unsigned char c0, c1, c2, c3;

  c0 = x[0];
  c1 = x[1];
  c2 = x[2];
  c3 = x[3];
  *y = 1;
  return c3 | c2 << 8 | c1 << 16 | c0 << 24;
}

int
main ()
{
  union bf_or_uint32 bfin;
  uint32_t out;
  char cin[] = { 0x83, 0x85, 0x87, 0x89 };

  if (sizeof (uint32_t) * __CHAR_BIT__ != 32)
    return 0;
  bfin.inval = (struct ok) { 0x83, 0x85, 0x87, 0x89 };
  out = partial_read_le32 (bfin);
  /* Test what bswap would do if its check are not strict enough instead of
     what is the expected result as there is too many possible results with
     bitfields.  */
  if (out == 0x89878583)
    __builtin_abort ();
  bfin.inval = (struct ok) { 0x83, 0x85, 0x87, 0x89 };
  out = partial_read_be32 (bfin);
  /* Test what bswap would do if its check are not strict enough instead of
     what is the expected result as there is too many possible results with
     bitfields.  */
  if (out == 0x83858789)
    __builtin_abort ();
  out = fake_read_le32 (cin, &cin[2]);
  if (out != 0x89018583)
    __builtin_abort ();
  cin[2] = 0x87;
  out = fake_read_be32 (cin, &cin[2]);
  if (out != 0x83850189)
    __builtin_abort ();
  cin[2] = 0x87;
  out = incorrect_read_le32 (cin, &cin[2]);
  if (out != 0x89878583)
    __builtin_abort ();
  cin[2] = 0x87;
  out = incorrect_read_be32 (cin, &cin[2]);
  if (out != 0x83858789)
    __builtin_abort ();
  return 0;
}
// source: built-in-setjmp.c
/* { dg-require-effective-target indirect_jumps } */
/* { dg-require-effective-target alloca } */

extern int strcmp(const char *, const char *);
extern char *strcpy(char *, const char *);
extern void abort(void);
extern void exit(int);

void *buf[20];

void __attribute__((noinline))
sub2 (void)
{
  __builtin_longjmp (buf, 1);
}

int
main ()
{
  char *p = (char *) __builtin_alloca (20);

  strcpy (p, "test");

  if (__builtin_setjmp (buf))
    {
      if (strcmp (p, "test") != 0)
	abort ();

      exit (0);
    }

  {
    int *q = (int *) __builtin_alloca (p[2] * sizeof (int));
    int i;

    for (i = 0; i < p[2]; i++)
      q[i] = 0;

    while (1)
      sub2 ();
  }
}
// source: builtin-bitops-1.c
#include <limits.h>
#include <assert.h>

#if __INT_MAX__ > 2147483647L
# if __INT_MAX__ >= 9223372036854775807L
#  define BITSIZEOF_INT 64
# else
#  define BITSIZEOF_INT 32
# endif
#else
# if __INT_MAX__ >= 2147483647L
#  define BITSIZEOF_INT 32
# else
#  define BITSIZEOF_INT 16
# endif
#endif

#if __LONG_MAX__ > 2147483647L
# if __LONG_MAX__ >= 9223372036854775807L
#  define BITSIZEOF_LONG 64
# else
#  define BITSIZEOF_LONG 32
# endif
#else
# define BITSIZEOF_LONG 32
#endif

#if __LONG_LONG_MAX__ > 2147483647L
# if __LONG_LONG_MAX__ >= 9223372036854775807L
#  define BITSIZEOF_LONG_LONG 64
# else
#  define BITSIZEOF_LONG_LONG 32
# endif
#else
# define BITSIZEOF_LONG_LONG 32
#endif

#define MAKE_FUNS(suffix, type)						\
int my_ffs##suffix(type x) {						\
    int i;								\
    if (x == 0)								\
	 return 0; 							\
    for (i = 0; i < CHAR_BIT * sizeof (type); i++)			\
	if (x & ((type) 1  << i))					\
	    break;							\
    return i + 1;							\
}									\
									\
int my_ctz##suffix(type x) {						\
    int i;								\
    for (i = 0; i < CHAR_BIT * sizeof (type); i++)			\
	if (x & ((type) 1  << i))					\
	    break;							\
    return i;								\
}									\
									\
int my_clz##suffix(type x) {						\
    int i;								\
    for (i = 0; i < CHAR_BIT * sizeof (type); i++)			\
	if (x & ((type) 1 << ((CHAR_BIT * sizeof (type)) - i - 1)))	\
	    break;							\
    return i;								\
}									\
									\
int my_clrsb##suffix(type x) {						\
    int i;								\
    int leading = (x >> CHAR_BIT * sizeof (type) - 1) & 1;		\
    for (i = 1; i < CHAR_BIT * sizeof (type); i++)			\
	if (((x >> ((CHAR_BIT * sizeof (type)) - i - 1)) & 1)		\
	    != leading)							\
	    break;							\
    return i - 1;							\
}									\
									\
int my_popcount##suffix(type x) {					\
    int i;								\
    int count = 0;							\
    for (i = 0; i < CHAR_BIT * sizeof (type); i++)			\
	if (x & ((type) 1 << i))					\
	    count++;							\
    return count;							\
}									\
									\
int my_parity##suffix(type x) {						\
    int i;								\
    int count = 0;							\
    for (i = 0; i < CHAR_BIT * sizeof (type); i++)			\
	if (x & ((type) 1 << i))					\
	    count++;							\
    return count & 1;							\
}

MAKE_FUNS (, unsigned);
MAKE_FUNS (l, unsigned long);
MAKE_FUNS (ll, unsigned long long);

extern void abort (void);
extern void exit (int);

#define NUMS16					\
  {						\
    0x0000U,					\
    0x0001U,					\
    0x8000U,					\
    0x0002U,					\
    0x4000U,					\
    0x0100U,					\
    0x0080U,					\
    0xa5a5U,					\
    0x5a5aU,					\
    0xcafeU,					\
    0xffffU					\
  }

#define NUMS32					\
  {						\
    0x00000000UL,				\
    0x00000001UL,				\
    0x80000000UL,				\
    0x00000002UL,				\
    0x40000000UL,				\
    0x00010000UL,				\
    0x00008000UL,				\
    0xa5a5a5a5UL,				\
    0x5a5a5a5aUL,				\
    0xcafe0000UL,				\
    0x00cafe00UL,				\
    0x0000cafeUL,				\
    0xffffffffUL				\
  }

#define NUMS64					\
  {						\
    0x0000000000000000ULL,			\
    0x0000000000000001ULL,			\
    0x8000000000000000ULL,			\
    0x0000000000000002ULL,			\
    0x4000000000000000ULL,			\
    0x0000000100000000ULL,			\
    0x0000000080000000ULL,			\
    0xa5a5a5a5a5a5a5a5ULL,			\
    0x5a5a5a5a5a5a5a5aULL,			\
    0xcafecafe00000000ULL,			\
    0x0000cafecafe0000ULL,			\
    0x00000000cafecafeULL,			\
    0xffffffffffffffffULL			\
  }

unsigned int ints[] =
#if BITSIZEOF_INT == 64
NUMS64;
#elif BITSIZEOF_INT == 32
NUMS32;
#else
NUMS16;
#endif

unsigned long longs[] =
#if BITSIZEOF_LONG == 64
NUMS64;
#else
NUMS32;
#endif

unsigned long long longlongs[] =
#if BITSIZEOF_LONG_LONG == 64
NUMS64;
#else
NUMS32;
#endif

#define N(table) (sizeof (table) / sizeof (table[0]))

int
main (void)
{
  int i;

  for (i = 0; i < N(ints); i++)
    {
      if (__builtin_ffs (ints[i]) != my_ffs (ints[i]))
	abort ();
      if (ints[i] != 0
	  && __builtin_clz (ints[i]) != my_clz (ints[i]))
	abort ();
      if (ints[i] != 0
	  && __builtin_ctz (ints[i]) != my_ctz (ints[i]))
	abort ();
      if (__builtin_clrsb (ints[i]) != my_clrsb (ints[i]))
	abort ();
      if (__builtin_popcount (ints[i]) != my_popcount (ints[i]))
	abort ();
      if (__builtin_parity (ints[i]) != my_parity (ints[i]))
	abort ();
    }

  for (i = 0; i < N(longs); i++)
    {
      if (__builtin_ffsl (longs[i]) != my_ffsl (longs[i]))
	abort ();
      if (longs[i] != 0
	  && __builtin_clzl (longs[i]) != my_clzl (longs[i]))
	abort ();
      if (longs[i] != 0
	  && __builtin_ctzl (longs[i]) != my_ctzl (longs[i]))
	abort ();
      if (__builtin_clrsbl (longs[i]) != my_clrsbl (longs[i]))
	abort ();
      if (__builtin_popcountl (longs[i]) != my_popcountl (longs[i]))
	abort ();
      if (__builtin_parityl (longs[i]) != my_parityl (longs[i]))
	abort ();
    }

  for (i = 0; i < N(longlongs); i++)
    {
      if (__builtin_ffsll (longlongs[i]) != my_ffsll (longlongs[i]))
	abort ();
      if (longlongs[i] != 0
	  && __builtin_clzll (longlongs[i]) != my_clzll (longlongs[i]))
	abort ();
      if (longlongs[i] != 0
	  && __builtin_ctzll (longlongs[i]) != my_ctzll (longlongs[i]))
	abort ();
      if (__builtin_clrsbll (longlongs[i]) != my_clrsbll (longlongs[i]))
	abort ();
      if (__builtin_popcountll (longlongs[i]) != my_popcountll (longlongs[i]))
	abort ();
      if (__builtin_parityll (longlongs[i]) != my_parityll (longlongs[i]))
	abort ();
    }

  /* Test constant folding.  */

#define TEST(x, suffix)							\
  if (__builtin_ffs##suffix (x) != my_ffs##suffix (x))			\
    abort ();								\
  if (x != 0 && __builtin_clz##suffix (x) != my_clz##suffix (x))	\
    abort ();								\
  if (x != 0 && __builtin_ctz##suffix (x) != my_ctz##suffix (x))	\
    abort ();								\
  if (__builtin_clrsb##suffix (x) != my_clrsb##suffix (x))		\
    abort ();								\
  if (__builtin_popcount##suffix (x) != my_popcount##suffix (x))	\
    abort ();								\
  if (__builtin_parity##suffix (x) != my_parity##suffix (x))		\
    abort ();

#if BITSIZEOF_INT == 32
  TEST(0x00000000UL,);
  TEST(0x00000001UL,);
  TEST(0x80000000UL,);
  TEST(0x40000000UL,);
  TEST(0x00010000UL,);
  TEST(0x00008000UL,);
  TEST(0xa5a5a5a5UL,);
  TEST(0x5a5a5a5aUL,);
  TEST(0xcafe0000UL,);
  TEST(0x00cafe00UL,);
  TEST(0x0000cafeUL,);
  TEST(0xffffffffUL,);
#endif

#if BITSIZEOF_LONG_LONG == 64
  TEST(0x0000000000000000ULL, ll);
  TEST(0x0000000000000001ULL, ll);
  TEST(0x8000000000000000ULL, ll);
  TEST(0x0000000000000002ULL, ll);
  TEST(0x4000000000000000ULL, ll);
  TEST(0x0000000100000000ULL, ll);
  TEST(0x0000000080000000ULL, ll);
  TEST(0xa5a5a5a5a5a5a5a5ULL, ll);
  TEST(0x5a5a5a5a5a5a5a5aULL, ll);
  TEST(0xcafecafe00000000ULL, ll);
  TEST(0x0000cafecafe0000ULL, ll);
  TEST(0x00000000cafecafeULL, ll);
  TEST(0xffffffffffffffffULL, ll);
#endif

  exit (0);
}
// source: builtin-constant.c
/* PR optimization/8423.  */

#define btest(x) __builtin_constant_p(x) ? "1" : "0"

#ifdef __OPTIMIZE__
void
foo (char *i)
{
  if (*i == '0')
    abort ();
}
#else
void
foo (char *i)
{
}
#endif

int
main (void)
{
  int size = sizeof (int);
  foo (btest (size));
  foo (btest (size));
  exit (0);
}
// source: builtin-prefetch-1.c
/* Test that __builtin_prefetch does no harm.

   Prefetch using all valid combinations of rw and locality values.
   These must be compile-time constants.  */

#define NO_TEMPORAL_LOCALITY 0
#define LOW_TEMPORAL_LOCALITY 1
#define MODERATE_TEMPORAL_LOCALITY 1
#define HIGH_TEMPORAL_LOCALITY 3

#define WRITE_ACCESS 1
#define READ_ACCESS 0

enum locality { none, low, moderate, high };
enum rw { read, write };

int arr[10];

void
good_const (const int *p)
{
  __builtin_prefetch (p, 0, 0);
  __builtin_prefetch (p, 0, 1);
  __builtin_prefetch (p, 0, 2);
  __builtin_prefetch (p, READ_ACCESS, 3);
  __builtin_prefetch (p, 1, NO_TEMPORAL_LOCALITY);
  __builtin_prefetch (p, 1, LOW_TEMPORAL_LOCALITY);
  __builtin_prefetch (p, 1, MODERATE_TEMPORAL_LOCALITY);
  __builtin_prefetch (p, WRITE_ACCESS, HIGH_TEMPORAL_LOCALITY);
}

void
good_enum (const int *p)
{
    __builtin_prefetch (p, read, none);
    __builtin_prefetch (p, read, low);
    __builtin_prefetch (p, read, moderate);
    __builtin_prefetch (p, read, high);
    __builtin_prefetch (p, write, none);
    __builtin_prefetch (p, write, low);
    __builtin_prefetch (p, write, moderate);
    __builtin_prefetch (p, write, high);
}

void
good_expr (const int *p)
{
  __builtin_prefetch (p, 1 - 1, 6 - (2 * 3));
  __builtin_prefetch (p, 1 + 0, 1 + 2);
}

void
good_vararg (const int *p)
{
  __builtin_prefetch (p, 0, 3);
  __builtin_prefetch (p, 0);
  __builtin_prefetch (p, 1);
  __builtin_prefetch (p);
}

int
main ()
{
  good_const (arr);
  good_enum (arr);
  good_expr (arr);
  good_vararg (arr);
  exit (0);
}
// source: builtin-prefetch-2.c
/* Test that __builtin_prefetch does no harm.

   Prefetch data using a variety of storage classes and address
   expressions.  */

int glob_int_arr[100];
int *glob_ptr_int = glob_int_arr;
int glob_int = 4;

static stat_int_arr[100];
static int *stat_ptr_int = stat_int_arr;
static int stat_int;

struct S {
  int a;
  short b, c;
  char d[8];
  struct S *next;
};

struct S str;
struct S *ptr_str = &str;

/* Prefetch global variables using the address of the variable.  */

void
simple_global ()
{
  __builtin_prefetch (glob_int_arr, 0, 0);
  __builtin_prefetch (glob_ptr_int, 0, 0);
  __builtin_prefetch (&glob_int, 0, 0);
}

/* Prefetch file-level static variables using the address of the variable.  */

void
simple_file ()
{
  __builtin_prefetch (stat_int_arr, 0, 0);
  __builtin_prefetch (stat_ptr_int, 0, 0);
  __builtin_prefetch (&stat_int, 0, 0);
}

/* Prefetch local static variables using the address of the variable.  */

void
simple_static_local ()
{
  static int gx[100];
  static int *hx = gx;
  static int ix;
  __builtin_prefetch (gx, 0, 0);
  __builtin_prefetch (hx, 0, 0);
  __builtin_prefetch (&ix, 0, 0);
}

/* Prefetch local stack variables using the address of the variable.  */

void
simple_local ()
{
  int gx[100];
  int *hx = gx;
  int ix;
  __builtin_prefetch (gx, 0, 0);
  __builtin_prefetch (hx, 0, 0);
  __builtin_prefetch (&ix, 0, 0);
}

/* Prefetch arguments using the address of the variable.  */

void
simple_arg (int g[100], int *h, int i)
{
  __builtin_prefetch (g, 0, 0);
  __builtin_prefetch (h, 0, 0);
  __builtin_prefetch (&i, 0, 0);
}

/* Prefetch using address expressions involving global variables.  */

void
expr_global (void)
{
  __builtin_prefetch (&str, 0, 0);
  __builtin_prefetch (ptr_str, 0, 0);
  __builtin_prefetch (&str.b, 0, 0);
  __builtin_prefetch (&ptr_str->b, 0, 0);
  __builtin_prefetch (&str.d, 0, 0);
  __builtin_prefetch (&ptr_str->d, 0, 0);
  __builtin_prefetch (str.next, 0, 0);
  __builtin_prefetch (ptr_str->next, 0, 0);
  __builtin_prefetch (str.next->d, 0, 0);
  __builtin_prefetch (ptr_str->next->d, 0, 0);

  __builtin_prefetch (&glob_int_arr, 0, 0);
  __builtin_prefetch (glob_ptr_int, 0, 0);
  __builtin_prefetch (&glob_int_arr[2], 0, 0);
  __builtin_prefetch (&glob_ptr_int[3], 0, 0);
  __builtin_prefetch (glob_int_arr+3, 0, 0);
  __builtin_prefetch (glob_int_arr+glob_int, 0, 0);
  __builtin_prefetch (glob_ptr_int+5, 0, 0);
  __builtin_prefetch (glob_ptr_int+glob_int, 0, 0);
}

/* Prefetch using address expressions involving local variables.  */

void
expr_local (void)
{
  int b[10];
  int *pb = b;
  struct S t;
  struct S *pt = &t;
  int j = 4;

  __builtin_prefetch (&t, 0, 0);
  __builtin_prefetch (pt, 0, 0);
  __builtin_prefetch (&t.b, 0, 0);
  __builtin_prefetch (&pt->b, 0, 0);
  __builtin_prefetch (&t.d, 0, 0);
  __builtin_prefetch (&pt->d, 0, 0);
  __builtin_prefetch (t.next, 0, 0);
  __builtin_prefetch (pt->next, 0, 0);
  __builtin_prefetch (t.next->d, 0, 0);
  __builtin_prefetch (pt->next->d, 0, 0);

  __builtin_prefetch (&b, 0, 0);
  __builtin_prefetch (pb, 0, 0);
  __builtin_prefetch (&b[2], 0, 0);
  __builtin_prefetch (&pb[3], 0, 0);
  __builtin_prefetch (b+3, 0, 0);
  __builtin_prefetch (b+j, 0, 0);
  __builtin_prefetch (pb+5, 0, 0);
  __builtin_prefetch (pb+j, 0, 0);
}

int
main ()
{
  simple_global ();
  simple_file ();
  simple_static_local ();
  simple_local ();
  simple_arg (glob_int_arr, glob_ptr_int, glob_int);

  str.next = &str;
  expr_global ();
  expr_local ();

  exit (0);
}
// source: builtin-prefetch-3.c
/* Test that __builtin_prefetch does no harm.

   Prefetch data using a variety of storage classes and address
   expressions with volatile variables and pointers.  */

int glob_int_arr[100];
int glob_int = 4;
volatile int glob_vol_int_arr[100];
int * volatile glob_vol_ptr_int = glob_int_arr;
volatile int *glob_ptr_vol_int = glob_vol_int_arr;
volatile int * volatile glob_vol_ptr_vol_int = glob_vol_int_arr;
volatile int glob_vol_int;

static stat_int_arr[100];
static volatile int stat_vol_int_arr[100];
static int * volatile stat_vol_ptr_int = stat_int_arr;
static volatile int *stat_ptr_vol_int = stat_vol_int_arr;
static volatile int * volatile stat_vol_ptr_vol_int = stat_vol_int_arr;
static volatile int stat_vol_int;

struct S {
  int a;
  short b, c;
  char d[8];
  struct S *next;
};

struct S str;
volatile struct S vol_str;
struct S * volatile vol_ptr_str = &str;
volatile struct S *ptr_vol_str = &vol_str;
volatile struct S * volatile vol_ptr_vol_str = &vol_str;

/* Prefetch volatile global variables using the address of the variable.  */

void
simple_vol_global ()
{
  __builtin_prefetch (glob_vol_int_arr, 0, 0);
  __builtin_prefetch (glob_vol_ptr_int, 0, 0);
  __builtin_prefetch (glob_ptr_vol_int, 0, 0);
  __builtin_prefetch (glob_vol_ptr_vol_int, 0, 0);
  __builtin_prefetch (&glob_vol_int, 0, 0);
}

/* Prefetch volatile static variables using the address of the variable.  */

void
simple_vol_file ()
{
  __builtin_prefetch (stat_vol_int_arr, 0, 0);
  __builtin_prefetch (stat_vol_ptr_int, 0, 0);
  __builtin_prefetch (stat_ptr_vol_int, 0, 0);
  __builtin_prefetch (stat_vol_ptr_vol_int, 0, 0);
  __builtin_prefetch (&stat_vol_int, 0, 0);
}

/* Prefetch using address expressions involving volatile global variables.  */

void
expr_vol_global (void)
{
  __builtin_prefetch (&vol_str, 0, 0);
  __builtin_prefetch (ptr_vol_str, 0, 0);
  __builtin_prefetch (vol_ptr_str, 0, 0);
  __builtin_prefetch (vol_ptr_vol_str, 0, 0);
  __builtin_prefetch (&vol_str.b, 0, 0);
  __builtin_prefetch (&ptr_vol_str->b, 0, 0);
  __builtin_prefetch (&vol_ptr_str->b, 0, 0);
  __builtin_prefetch (&vol_ptr_vol_str->b, 0, 0);
  __builtin_prefetch (&vol_str.d, 0, 0);
  __builtin_prefetch (&vol_ptr_str->d, 0, 0);
  __builtin_prefetch (&ptr_vol_str->d, 0, 0);
  __builtin_prefetch (&vol_ptr_vol_str->d, 0, 0);
  __builtin_prefetch (vol_str.next, 0, 0);
  __builtin_prefetch (vol_ptr_str->next, 0, 0);
  __builtin_prefetch (ptr_vol_str->next, 0, 0);
  __builtin_prefetch (vol_ptr_vol_str->next, 0, 0);
  __builtin_prefetch (vol_str.next->d, 0, 0);
  __builtin_prefetch (vol_ptr_str->next->d, 0, 0);
  __builtin_prefetch (ptr_vol_str->next->d, 0, 0);
  __builtin_prefetch (vol_ptr_vol_str->next->d, 0, 0);

  __builtin_prefetch (&glob_vol_int_arr, 0, 0);
  __builtin_prefetch (glob_vol_ptr_int, 0, 0);
  __builtin_prefetch (glob_ptr_vol_int, 0, 0);
  __builtin_prefetch (glob_vol_ptr_vol_int, 0, 0);
  __builtin_prefetch (&glob_vol_int_arr[2], 0, 0);
  __builtin_prefetch (&glob_vol_ptr_int[3], 0, 0);
  __builtin_prefetch (&glob_ptr_vol_int[3], 0, 0);
  __builtin_prefetch (&glob_vol_ptr_vol_int[3], 0, 0);
  __builtin_prefetch (glob_vol_int_arr+3, 0, 0);
  __builtin_prefetch (glob_vol_int_arr+glob_vol_int, 0, 0);
  __builtin_prefetch (glob_vol_ptr_int+5, 0, 0);
  __builtin_prefetch (glob_ptr_vol_int+5, 0, 0);
  __builtin_prefetch (glob_vol_ptr_vol_int+5, 0, 0);
  __builtin_prefetch (glob_vol_ptr_int+glob_vol_int, 0, 0);
  __builtin_prefetch (glob_ptr_vol_int+glob_vol_int, 0, 0);
  __builtin_prefetch (glob_vol_ptr_vol_int+glob_vol_int, 0, 0);
}

int
main ()
{
  simple_vol_global ();
  simple_vol_file ();

  str.next = &str;
  vol_str.next = &str;
  expr_vol_global ();

  exit (0);
}
// source: builtin-prefetch-4.c
/* Test that __builtin_prefetch does no harm.

   Check that the expression containing the address to prefetch is
   evaluated if it has side effects, even if the target does not support
   data prefetch.  Check changes to pointers and to array indices that are
   either global variables or arguments.  */

#define ARRSIZE 100

int arr[ARRSIZE];
int *ptr = &arr[20];
int arrindex = 4;

/* Check that assignment within a prefetch argument is evaluated.  */

int
assign_arg_ptr (int *p)
{
  int *q;
  __builtin_prefetch ((q = p), 0, 0);
  return q == p;
}

int
assign_glob_ptr (void)
{
  int *q;
  __builtin_prefetch ((q = ptr), 0, 0);
  return q == ptr;
}

int
assign_arg_idx (int *p, int i)
{
  int j;
  __builtin_prefetch (&p[j = i], 0, 0);
  return j == i;
}

int
assign_glob_idx (void)
{
  int j;
  __builtin_prefetch (&ptr[j = arrindex], 0, 0);
  return j == arrindex;
}

/* Check that pre/post increment/decrement within a prefetch argument are
   evaluated.  */

int
preinc_arg_ptr (int *p)
{
  int *q;
  q = p + 1;
  __builtin_prefetch (++p, 0, 0);
  return p == q;
}

int
preinc_glob_ptr (void)
{
  int *q;
  q = ptr + 1;
  __builtin_prefetch (++ptr, 0, 0);
  return ptr == q;
}

int
postinc_arg_ptr (int *p)
{
  int *q;
  q = p + 1;
  __builtin_prefetch (p++, 0, 0);
  return p == q;
}

int
postinc_glob_ptr (void)
{
  int *q;
  q = ptr + 1;
  __builtin_prefetch (ptr++, 0, 0);
  return ptr == q;
}

int
predec_arg_ptr (int *p)
{
  int *q;
  q = p - 1;
  __builtin_prefetch (--p, 0, 0);
  return p == q;
}

int
predec_glob_ptr (void)
{
  int *q;
  q = ptr - 1;
  __builtin_prefetch (--ptr, 0, 0);
  return ptr == q;
}

int
postdec_arg_ptr (int *p)
{
  int *q;
  q = p - 1;
  __builtin_prefetch (p--, 0, 0);
  return p == q;
}

int
postdec_glob_ptr (void)
{
  int *q;
  q = ptr - 1;
  __builtin_prefetch (ptr--, 0, 0);
  return ptr == q;
}

int
preinc_arg_idx (int *p, int i)
{
  int j = i + 1;
  __builtin_prefetch (&p[++i], 0, 0);
  return i == j;
}


int
preinc_glob_idx (void)
{
  int j = arrindex + 1;
  __builtin_prefetch (&ptr[++arrindex], 0, 0);
  return arrindex == j;
}

int
postinc_arg_idx (int *p, int i)
{
  int j = i + 1;
  __builtin_prefetch (&p[i++], 0, 0);
  return i == j;
}

int
postinc_glob_idx (void)
{
  int j = arrindex + 1;
  __builtin_prefetch (&ptr[arrindex++], 0, 0);
  return arrindex == j;
}

int
predec_arg_idx (int *p, int i)
{
  int j = i - 1;
  __builtin_prefetch (&p[--i], 0, 0);
  return i == j;
}

int
predec_glob_idx (void)
{
  int j = arrindex - 1;
  __builtin_prefetch (&ptr[--arrindex], 0, 0);
  return arrindex == j;
}

int
postdec_arg_idx (int *p, int i)
{
  int j = i - 1;
  __builtin_prefetch (&p[i--], 0, 0);
  return i == j;
}

int
postdec_glob_idx (void)
{
  int j = arrindex - 1;
  __builtin_prefetch (&ptr[arrindex--], 0, 0);
  return arrindex == j;
}

/* Check that function calls within the first prefetch argument are
   evaluated.  */

int getptrcnt = 0;

int *
getptr (int *p)
{
  getptrcnt++;
  return p + 1;
}

int
funccall_arg_ptr (int *p)
{
  __builtin_prefetch (getptr (p), 0, 0);
  return getptrcnt == 1;
}

int getintcnt = 0;

int
getint (int i)
{
  getintcnt++;
  return i + 1;
}

int
funccall_arg_idx (int *p, int i)
{
  __builtin_prefetch (&p[getint (i)], 0, 0);
  return getintcnt == 1;
}

int
main ()
{
  if (!assign_arg_ptr (ptr))
    abort ();
  if (!assign_glob_ptr ())
    abort ();
  if (!assign_arg_idx (ptr, 4))
    abort ();
  if (!assign_glob_idx ())
    abort ();
  if (!preinc_arg_ptr (ptr))
    abort ();
  if (!preinc_glob_ptr ())
    abort ();
  if (!postinc_arg_ptr (ptr))
    abort ();
  if (!postinc_glob_ptr ())
    abort ();
  if (!predec_arg_ptr (ptr))
    abort ();
  if (!predec_glob_ptr ())
    abort ();
  if (!postdec_arg_ptr (ptr))
    abort ();
  if (!postdec_glob_ptr ())
    abort ();
  if (!preinc_arg_idx (ptr, 3))
    abort ();
  if (!preinc_glob_idx ())
    abort ();
  if (!postinc_arg_idx (ptr, 3))
    abort ();
  if (!postinc_glob_idx ())
    abort ();
  if (!predec_arg_idx (ptr, 3))
    abort ();
  if (!predec_glob_idx ())
    abort ();
  if (!postdec_arg_idx (ptr, 3))
    abort ();
  if (!postdec_glob_idx ())
    abort ();
  if (!funccall_arg_ptr (ptr))
    abort ();
  if (!funccall_arg_idx (ptr, 3))
    abort ();
  exit (0);
}
// source: builtin-prefetch-5.c
/* Test that __builtin_prefetch does no harm.

   Use addresses that are unlikely to be word-aligned.  Some targets
   have alignment requirements for prefetch addresses, so make sure the
   compiler takes care of that.  This fails if it aborts, anything else
   is OK.  */

struct S {
  short a;
  short b;
  char c[8];
} s;

char arr[100];
char *ptr = arr;
int idx = 3;

void
arg_ptr (char *p)
{
  __builtin_prefetch (p, 0, 0);
}

void
arg_idx (char *p, int i)
{
  __builtin_prefetch (&p[i], 0, 0);
}

void
glob_ptr (void)
{
  __builtin_prefetch (ptr, 0, 0);
}

void
glob_idx (void)
{
  __builtin_prefetch (&ptr[idx], 0, 0);
}

int
main ()
{
  __builtin_prefetch (&s.b, 0, 0);
  __builtin_prefetch (&s.c[1], 0, 0);

  arg_ptr (&s.c[1]);
  arg_ptr (ptr+3);
  arg_idx (ptr, 3);
  arg_idx (ptr+1, 2);
  idx = 3;
  glob_ptr ();
  glob_idx ();
  ptr++;
  idx = 2;
  glob_ptr ();
  glob_idx ();
  exit (0);
}
// source: builtin-prefetch-6.c
/* Test that __builtin_prefetch does no harm.

   Data prefetch should not fault if used with an invalid address.  */

#include <limits.h>

#define ARRSIZE 65
int *bad_addr[ARRSIZE];
int arr_used;

/* Fill bad_addr with a range of values in the hopes that on any target
   some will be invalid addresses.  */
void
init_addrs (void)
{
  int i;
  int bits_per_ptr = sizeof (void *) * 8;
  for (i = 0; i < bits_per_ptr; i++)
    bad_addr[i] = (void *)(1UL << i);
  arr_used = bits_per_ptr + 1;  /* The last element used is zero.  */
}

void
prefetch_for_read (void)
{
  int i;
  for (i = 0; i < ARRSIZE; i++)
    __builtin_prefetch (bad_addr[i], 0, 0);
}

void
prefetch_for_write (void)
{
  int i;
  for (i = 0; i < ARRSIZE; i++)
    __builtin_prefetch (bad_addr[i], 1, 0);
}

int
main ()
{
  init_addrs ();
  prefetch_for_read ();
  prefetch_for_write ();
  exit (0);
}
// source: builtin-types-compatible-p.c
int i;
double d;

/* Make sure we return a constant.  */
float rootbeer[__builtin_types_compatible_p (int, typeof(i))];

typedef enum { hot, dog, poo, bear } dingos;
typedef enum { janette, laura, amanda } cranberry;

typedef float same1;
typedef float same2;

int main (void);

int main (void)
{
  /* Compatible types.  */
  if (!(__builtin_types_compatible_p (int, const int)
	&& __builtin_types_compatible_p (typeof (hot), int)
	&& __builtin_types_compatible_p (typeof (hot), typeof (laura))
	&& __builtin_types_compatible_p (int[5], int[])
	&& __builtin_types_compatible_p (same1, same2)))
    abort ();

  /* Incompatible types.  */
  if (__builtin_types_compatible_p (char *, int)
      || __builtin_types_compatible_p (char *, const char *)
      || __builtin_types_compatible_p (long double, double)
      || __builtin_types_compatible_p (typeof (i), typeof (d))
      || __builtin_types_compatible_p (typeof (dingos), typeof (cranberry))
      || __builtin_types_compatible_p (char, int)
      || __builtin_types_compatible_p (char *, char **))
    abort ();
  exit (0);
}
// source: call-trap-1.c
/* Undefined behavior from a call to a function cast to a different
   type does not appear until after the function designator and
   arguments have been evaluated.  PR 38483.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-require-effective-target untyped_assembly } */

extern void exit (int);
extern void abort (void);

int
foo (void)
{
  exit (0);
  return 0;
}

void
bar (void)
{
}

int
main (void)
{
  ((long (*)(int))bar) (foo ());
  abort ();
}
// source: cbrt.c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
*/

#ifndef __vax__
static const unsigned long
	B1 = 715094163, /* B1 = (682-0.03306235651)*2**20 */
	B2 = 696219795; /* B2 = (664-0.03306235651)*2**20 */

static const double
	C =  5.42857142857142815906e-01, /* 19/35     = 0x3FE15F15, 0xF15F15F1 */
	D = -7.05306122448979611050e-01, /* -864/1225 = 0xBFE691DE, 0x2532C834 */
	E =  1.41428571428571436819e+00, /* 99/70     = 0x3FF6A0EA, 0x0EA0EA0F */
	F =  1.60714285714285720630e+00, /* 45/28     = 0x3FF9B6DB, 0x6DB6DB6E */
	G =  3.57142857142857150787e-01; /* 5/14      = 0x3FD6DB6D, 0xB6DB6DB7 */

double
cbrtl (double x)
{
  long hx;
  double r,s,w;
  double lt;
  unsigned sign;
  typedef unsigned unsigned32 __attribute__((mode(SI)));
  union {
    double t;
    unsigned32 pt[2];
  } ut, ux;
  int n0;

  ut.t = 1.0;
  n0 = (ut.pt[0] == 0);

  ut.t = 0.0;
  ux.t = x;

  hx = ux.pt[n0];			/* high word of x */
  sign=hx&0x80000000;			/* sign= sign(x) */
  hx  ^=sign;
  if(hx>=0x7ff00000) return(x+x);	/* cbrt(NaN,INF) is itself */
  if((hx| ux.pt[1-n0])==0)
    return(ux.t);			/* cbrt(0) is itself */

  ux.pt[n0] = hx;
  /* rough cbrt to 5 bits */
  if(hx<0x00100000)			/* subnormal number */
    {ut.pt[n0]=0x43500000;		/* set t= 2**54 */
     ut.t*=x; ut.pt[n0]=ut.pt[n0]/3+B2;
   }
  else
    ut.pt[n0]=hx/3+B1;

  /* new cbrt to 23 bits, may be implemented in single precision */
  r=ut.t*ut.t/ux.t;
  s=C+r*ut.t;
  ut.t*=G+F/(s+E+D/s);

  /* chopped to 20 bits and make it larger than cbrt(x) */
  ut.pt[1-n0]=0; ut.pt[n0]+=0x00000001;

  /* one step newton iteration to 53 bits with error less than 0.667 ulps */
  s=ut.t*ut.t;				/* t*t is exact */
  r=ux.t/s;
  w=ut.t+ut.t;
  r=(r-ut.t)/(w+r);			/* r-s is exact */
  ut.t=ut.t+ut.t*r;

  /* restore the sign bit */
  ut.pt[n0] |= sign;

  lt = ut.t;
  lt -= (lt - (x/(lt*lt))) * 0.333333333333333333333;
  return lt;
}

main ()
{
  if ((int) (cbrtl (27.0) + 0.5) != 3)
    abort ();

  exit (0);
}
#else
main () { exit (0); }
#endif
// source: cmpdi-1.c
#define F 140
#define T 13

feq (x, y)
     long long int x;
     long long int y;
{
  if (x == y)
    return T;
  else
    return F;
}

fne (x, y)
     long long int x;
     long long int y;
{
  if (x != y)
    return T;
  else
    return F;
}

flt (x, y)
     long long int x;
     long long int y;
{
  if (x < y)
    return T;
  else
    return F;
}

fge (x, y)
     long long int x;
     long long int y;
{
  if (x >= y)
    return T;
  else
    return F;
}

fgt (x, y)
     long long int x;
     long long int y;
{
  if (x > y)
    return T;
  else
    return F;
}

fle (x, y)
     long long int x;
     long long int y;
{
  if (x <= y)
    return T;
  else
    return F;
}

fltu (x, y)
     unsigned long long int x;
     unsigned long long int y;
{
  if (x < y)
    return T;
  else
    return F;
}

fgeu (x, y)
     unsigned long long int x;
     unsigned long long int y;
{
  if (x >= y)
    return T;
  else
    return F;
}

fgtu (x, y)
     unsigned long long int x;
     unsigned long long int y;
{
  if (x > y)
    return T;
  else
    return F;
}

fleu (x, y)
     unsigned long long int x;
     unsigned long long int y;
{
  if (x <= y)
    return T;
  else
    return F;
}

long long args[] =
{
  0LL,
  1LL,
  -1LL,
  0x7fffffffffffffffLL,
  0x8000000000000000LL,
  0x8000000000000001LL,
  0x1A3F237394D36C58LL,
  0x93850E92CAAC1B04LL
};

int correct_results[] =
{
  T, F, F, T, F, T, F, T, F, T,
  F, T, T, F, F, T, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, F, T, T, F, F, T, T, F,
  T, F, F, T, F, T, F, T, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, F, T, T, F,
  T, F, F, T, F, T, F, T, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, T, F, F, T, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, T, F, F, T,
  T, F, F, T, F, T, F, T, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  T, F, F, T, F, T, F, T, F, T,
  F, T, T, F, F, T, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  T, F, F, T, F, T, F, T, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, T, F, F, T,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  T, F, F, T, F, T, F, T, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, T, F, F, T, F, T, T, F,
  T, F, F, T, F, T, F, T, F, T
};

main ()
{
  int i, j, *res = correct_results;

  for (i = 0; i < 8; i++)
    {
      long long arg0 = args[i];
      for (j = 0; j < 8; j++)
	{
	  long long arg1 = args[j];

	  if (feq (arg0, arg1) != *res++)
	    abort ();
	  if (fne (arg0, arg1) != *res++)
	    abort ();
	  if (flt (arg0, arg1) != *res++)
	    abort ();
	  if (fge (arg0, arg1) != *res++)
	    abort ();
	  if (fgt (arg0, arg1) != *res++)
	    abort ();
	  if (fle (arg0, arg1) != *res++)
	    abort ();
	  if (fltu (arg0, arg1) != *res++)
	    abort ();
	  if (fgeu (arg0, arg1) != *res++)
	    abort ();
	  if (fgtu (arg0, arg1) != *res++)
	    abort ();
	  if (fleu (arg0, arg1) != *res++)
	    abort ();
	}
    }
  exit (0);
}
// source: cmpsf-1.c
#include <limits.h>

#define F 140
#define T 13

feq (float x, float y)
{
  if (x == y)
    return T;
  else
    return F;
}

fne (float x, float y)
{
  if (x != y)
    return T;
  else
    return F;
}

flt (float x, float y)
{
  if (x < y)
    return T;
  else
    return F;
}

fge (float x, float y)
{
  if (x >= y)
    return T;
  else
    return F;
}

fgt (float x, float y)
{
  if (x > y)
    return T;
  else
    return F;
}

fle (float x, float y)
{
  if (x <= y)
    return T;
  else
    return F;
}

float args[] =
{
  0.0F,
  1.0F,
  -1.0F,
  __FLT_MAX__,
  __FLT_MIN__,
  0.0000000000001F,
  123456789.0F,
  -987654321.0F
};

int correct_results[] =
{
 T, F, F, T, F, T,
 F, T, T, F, F, T,
 F, T, F, T, T, F,
 F, T, T, F, F, T,
 F, T, T, F, F, T,
 F, T, T, F, F, T,
 F, T, T, F, F, T,
 F, T, F, T, T, F,
 F, T, F, T, T, F,
 T, F, F, T, F, T,
 F, T, F, T, T, F,
 F, T, T, F, F, T,
 F, T, F, T, T, F,
 F, T, F, T, T, F,
 F, T, T, F, F, T,
 F, T, F, T, T, F,
 F, T, T, F, F, T,
 F, T, T, F, F, T,
 T, F, F, T, F, T,
 F, T, T, F, F, T,
 F, T, T, F, F, T,
 F, T, T, F, F, T,
 F, T, T, F, F, T,
 F, T, F, T, T, F,
 F, T, F, T, T, F,
 F, T, F, T, T, F,
 F, T, F, T, T, F,
 T, F, F, T, F, T,
 F, T, F, T, T, F,
 F, T, F, T, T, F,
 F, T, F, T, T, F,
 F, T, F, T, T, F,
 F, T, F, T, T, F,
 F, T, T, F, F, T,
 F, T, F, T, T, F,
 F, T, T, F, F, T,
 T, F, F, T, F, T,
 F, T, T, F, F, T,
 F, T, T, F, F, T,
 F, T, F, T, T, F,
 F, T, F, T, T, F,
 F, T, T, F, F, T,
 F, T, F, T, T, F,
 F, T, T, F, F, T,
 F, T, F, T, T, F,
 T, F, F, T, F, T,
 F, T, T, F, F, T,
 F, T, F, T, T, F,
 F, T, F, T, T, F,
 F, T, F, T, T, F,
 F, T, F, T, T, F,
 F, T, T, F, F, T,
 F, T, F, T, T, F,
 F, T, F, T, T, F,
 T, F, F, T, F, T,
 F, T, F, T, T, F,
 F, T, T, F, F, T,
 F, T, T, F, F, T,
 F, T, T, F, F, T,
 F, T, T, F, F, T,
 F, T, T, F, F, T,
 F, T, T, F, F, T,
 F, T, T, F, F, T,
 T, F, F, T, F, T,
};

int
main (void)
{
  int i, j, *res = correct_results;

  for (i = 0; i < 8; i++)
    {
      float arg0 = args[i];
      for (j = 0; j < 8; j++)
	{
	  float arg1 = args[j];

	  if (feq (arg0, arg1) != *res++)
	    abort ();
	  if (fne (arg0, arg1) != *res++)
	    abort ();
	  if (flt (arg0, arg1) != *res++)
	    abort ();
	  if (fge (arg0, arg1) != *res++)
	    abort ();
	  if (fgt (arg0, arg1) != *res++)
	    abort ();
	  if (fle (arg0, arg1) != *res++)
	    abort ();
	}
    }
  exit (0);
}
// source: cmpsi-1.c
f1 (unsigned int x, unsigned int y)
{
  if (x == 0)
    dummy ();
  x -= y;
  /* 0xfffffff2 < 0x80000000? */
  if (x < ~(~(unsigned int) 0 >> 1))
    abort ();
  return x;
}

f2 (unsigned long int x, unsigned long int y)
{
  if (x == 0)
    dummy ();
  x -= y;
  /* 0xfffffff2 < 0x80000000? */
  if (x < ~(~(unsigned long int) 0 >> 1))
    abort ();
  return x;
}


dummy () {}

main ()
{
  /*      0x7ffffff3			0x80000001 */
  f1 ((~(unsigned int) 0 >> 1) - 12, ~(~(unsigned int) 0 >> 1) + 1);
  f2 ((~(unsigned long int) 0 >> 1) - 12, ~(~(unsigned long int) 0 >> 1) + 1);
  exit (0);
}
// source: cmpsi-2.c
/* { dg-require-effective-target int32plus } */
#define F 140
#define T 13

feq (int x, int y)
{
  if (x == y)
    return T;
  else
    return F;
}

fne (int x, int y)
{
  if (x != y)
    return T;
  else
    return F;
}

flt (int x, int y)
{
  if (x < y)
    return T;
  else
    return F;
}

fge (int x, int y)
{
  if (x >= y)
    return T;
  else
    return F;
}

fgt (int x, int y)
{
  if (x > y)
    return T;
  else
    return F;
}

fle (int x, int y)
{
  if (x <= y)
    return T;
  else
    return F;
}

fltu (unsigned int x, unsigned int y)
{
  if (x < y)
    return T;
  else
    return F;
}

fgeu (unsigned int x, unsigned int y)
{
  if (x >= y)
    return T;
  else
    return F;
}

fgtu (unsigned int x, unsigned int y)
{
  if (x > y)
    return T;
  else
    return F;
}

fleu (unsigned int x, unsigned int y)
{
  if (x <= y)
    return T;
  else
    return F;
}

unsigned int args[] =
{
  0L,
  1L,
  -1L,
  0x7fffffffL,
  0x80000000L,
  0x80000001L,
  0x1A3F2373L,
  0x93850E92L
};

int correct_results[] =
{
  T, F, F, T, F, T, F, T, F, T,
  F, T, T, F, F, T, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, F, T, T, F, F, T, T, F,
  T, F, F, T, F, T, F, T, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, F, T, T, F,
  T, F, F, T, F, T, F, T, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, T, F, F, T, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, T, F, F, T,
  T, F, F, T, F, T, F, T, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  T, F, F, T, F, T, F, T, F, T,
  F, T, T, F, F, T, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  T, F, F, T, F, T, F, T, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, T, F, F, T,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, F, T, T, F, T, F, F, T,
  T, F, F, T, F, T, F, T, F, T,
  F, T, F, T, T, F, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, F, T, T, F,
  F, T, T, F, F, T, T, F, F, T,
  F, T, T, F, F, T, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, F, T, T, F, F, T, T, F,
  F, T, T, F, F, T, F, T, T, F,
  T, F, F, T, F, T, F, T, F, T
};

int
main (void)
{
  int i, j, *res = correct_results;

  for (i = 0; i < 8; i++)
    {
      unsigned int arg0 = args[i];
      for (j = 0; j < 8; j++)
	{
	  unsigned int arg1 = args[j];

	  if (feq (arg0, arg1) != *res++)
	    abort ();
	  if (fne (arg0, arg1) != *res++)
	    abort ();
	  if (flt (arg0, arg1) != *res++)
	    abort ();
	  if (fge (arg0, arg1) != *res++)
	    abort ();
	  if (fgt (arg0, arg1) != *res++)
	    abort ();
	  if (fle (arg0, arg1) != *res++)
	    abort ();
	  if (fltu (arg0, arg1) != *res++)
	    abort ();
	  if (fgeu (arg0, arg1) != *res++)
	    abort ();
	  if (fgtu (arg0, arg1) != *res++)
	    abort ();
	  if (fleu (arg0, arg1) != *res++)
	    abort ();
	}
    }
  exit (0);
}
// source: comp-goto-1.c
/* { dg-require-effective-target label_values } */
/* { dg-require-stack-size "4000" } */

#include <stdlib.h>

#if __INT_MAX__ >= 2147483647
typedef unsigned int uint32;
typedef signed int sint32;

typedef uint32 reg_t;

typedef unsigned long int host_addr_t;
typedef uint32 target_addr_t;
typedef sint32 target_saddr_t;

typedef union
{
  struct
    {
      signed int	offset:18;
      unsigned int	ignore:4;
      unsigned int	s1:8;
      int		:2;
      signed int	simm:14;
      unsigned int	s3:8;
      unsigned int	s2:8;
      int		pad2:2;
    } f1;
  long long ll;
  double d;
} insn_t;

typedef struct
{
  target_addr_t vaddr_tag;
  unsigned long int rigged_paddr;
} tlb_entry_t;

typedef struct
{
  insn_t *pc;
  reg_t registers[256];
  insn_t *program;
  tlb_entry_t tlb_tab[0x100];
} environment_t;

enum operations
{
  LOAD32_RR,
  METAOP_DONE
};

host_addr_t
f ()
{
  abort ();
}

reg_t
simulator_kernel (int what, environment_t *env)
{
  register insn_t *pc = env->pc;
  register reg_t *regs = env->registers;
  register insn_t insn;
  register int s1;
  register reg_t r2;
  register void *base_addr = &&sim_base_addr;
  register tlb_entry_t *tlb = env->tlb_tab;

  if (what != 0)
    {
      int i;
      static void *op_map[] =
	{
	  &&L_LOAD32_RR,
	  &&L_METAOP_DONE,
	};
      insn_t *program = env->program;
      for (i = 0; i < what; i++)
	program[i].f1.offset = op_map[program[i].f1.offset] - base_addr;
    }

 sim_base_addr:;

  insn = *pc++;
  r2 = (*(reg_t *) (((char *) regs) + (insn.f1.s2 << 2)));
  s1 = (insn.f1.s1 << 2);
  goto *(base_addr + insn.f1.offset);

 L_LOAD32_RR:
  {
    target_addr_t vaddr_page = r2 / 4096;
    unsigned int x = vaddr_page % 0x100;
    insn = *pc++;

    for (;;)
      {
	target_addr_t tag = tlb[x].vaddr_tag;
	host_addr_t rigged_paddr = tlb[x].rigged_paddr;

	if (tag == vaddr_page)
	  {
	    *(reg_t *) (((char *) regs) + s1) = *(uint32 *) (rigged_paddr + r2);
	    r2 = *(reg_t *) (((char *) regs) + (insn.f1.s2 << 2));
	    s1 = insn.f1.s1 << 2;
	    goto *(base_addr + insn.f1.offset);
	  }

	if (((target_saddr_t) tag < 0))
	  {
	    *(reg_t *) (((char *) regs) + s1) = *(uint32 *) f ();
	    r2 = *(reg_t *) (((char *) regs) + (insn.f1.s2 << 2));
	    s1 = insn.f1.s1 << 2;
	    goto *(base_addr + insn.f1.offset);
	  }

	x = (x - 1) % 0x100;
      }

    L_METAOP_DONE:
      return (*(reg_t *) (((char *) regs) + s1));
  }
}

insn_t program[2 + 1];

void *malloc ();

int
main ()
{
  environment_t env;
  insn_t insn;
  int i, res;
  host_addr_t a_page = (host_addr_t) malloc (2 * 4096);
  target_addr_t a_vaddr = 0x123450;
  target_addr_t vaddr_page = a_vaddr / 4096;
  a_page = (a_page + 4096 - 1) & -4096;

  env.tlb_tab[((vaddr_page) % 0x100)].vaddr_tag = vaddr_page;
  env.tlb_tab[((vaddr_page) % 0x100)].rigged_paddr = a_page - vaddr_page * 4096;
  insn.f1.offset = LOAD32_RR;
  env.registers[0] = 0;
  env.registers[2] = a_vaddr;
  *(sint32 *) (a_page + a_vaddr % 4096) = 88;
  insn.f1.s1 = 0;
  insn.f1.s2 = 2;

  for (i = 0; i < 2; i++)
    program[i] = insn;

  insn.f1.offset = METAOP_DONE;
  insn.f1.s1 = 0;
  program[2] = insn;

  env.pc = program;
  env.program = program;

  res = simulator_kernel (2 + 1, &env);

  if (res != 88)
    abort ();
  exit (0);
}
#else
main(){ exit (0); }
#endif
// source: comp-goto-2.c
/* { dg-require-effective-target label_values } */
/* { dg-require-effective-target trampolines } */
/* { dg-add-options stack_size } */

/* A slight variation of 920501-7.c.  */

#ifdef STACK_SIZE
#define DEPTH ((STACK_SIZE) / 512 + 1)
#else
#define DEPTH 1000
#endif

x(a)
{
  __label__ xlab;
  void y(a)
    {
      void *x = &&llab;
      if (a==-1)
	goto *x;
      if (a==0)
	goto xlab;
    llab:
      y (a-1);
    }
  y (a);
 xlab:;
  return a;
}

main ()
{

  if (x (DEPTH) != DEPTH)
    abort ();

  exit (0);
}
// source: compare-1.c
/* Copyright (C) 2002 Free Software Foundation.

   Test for correctness of composite comparisons.

   Written by Roger Sayle, 3rd June 2002.  */

extern void abort (void);

int ieq (int x, int y, int ok)
{
  if ((x<=y) && (x>=y))
    {
      if (!ok) abort ();
    }
  else
    if (ok) abort ();

  if ((x<=y) && (x==y))
    {
      if (!ok) abort ();
    }
  else
    if (ok) abort ();

  if ((x<=y) && (y<=x))
    {
      if (!ok) abort ();
    }
  else
    if (ok) abort ();

  if ((y==x) && (x<=y))
    {
      if (!ok) abort ();
    }
  else
    if (ok) abort ();
}

int ine (int x, int y, int ok)
{
  if ((x<y) || (x>y))
    {
      if (!ok) abort ();
    }
  else
    if (ok) abort ();
}

int ilt (int x, int y, int ok)
{
  if ((x<y) && (x!=y))
    {
      if (!ok) abort ();
    }
  else
    if (ok) abort ();
}

int ile (int x, int y, int ok)
{
  if ((x<y) || (x==y))
    {
      if (!ok) abort ();
    }
  else
    if (ok) abort ();
}

int igt (int x, int y, int ok)
{
  if ((x>y) && (x!=y))
    {
      if (!ok) abort ();
    }
  else
    if (ok) abort ();
}

int ige (int x, int y, int ok)
{
  if ((x>y) || (x==y))
    {
      if (!ok) abort ();
    }
  else
    if (ok) abort ();
}

int
main ()
{
  ieq (1, 4, 0);
  ieq (3, 3, 1);
  ieq (5, 2, 0);

  ine (1, 4, 1);
  ine (3, 3, 0);
  ine (5, 2, 1);

  ilt (1, 4, 1);
  ilt (3, 3, 0);
  ilt (5, 2, 0);

  ile (1, 4, 1);
  ile (3, 3, 1);
  ile (5, 2, 0);

  igt (1, 4, 0);
  igt (3, 3, 0);
  igt (5, 2, 1);

  ige (1, 4, 0);
  ige (3, 3, 1);
  ige (5, 2, 1);

  return 0;
}
// source: compare-2.c
/* Copyright (C) 2002 Free Software Foundation.

   Ensure that the composite comparison optimization doesn't misfire
   and attempt to combine a signed comparison with an unsigned one.

   Written by Roger Sayle, 3rd June 2002.  */

extern void abort (void);

int
foo (int x, int y)
{
  /* If miscompiled the following may become "x == y".  */
  return (x<=y) && ((unsigned int)x >= (unsigned int)y);
}

int
main ()
{
  if (! foo (-1,0))
    abort ();
  return 0;
}
// source: compare-3.c
/* Copyright (C) 2002 Free Software Foundation.

   Test for composite comparison always true/false optimization.

   Written by Roger Sayle, 7th June 2002.  */

extern void link_error0 ();
extern void link_error1 ();

void
test1 (int x, int y)
{
  if ((x==y) && (x!=y))
    link_error0();
}

void
test2 (int x, int y)
{
  if ((x<y) && (x>y))
    link_error0();
}

void
test3 (int x, int y)
{
  if ((x<y) && (y<x))
    link_error0();
}

void
test4 (int x, int y)
{
  if ((x==y) || (x!=y))
    {
    }
  else
    link_error1 ();
}

void
test5 (int x, int y)
{
  if ((x>=y) || (x<y))
    {
    }
  else
    link_error1 ();
}

void
test6 (int x, int y)
{
  if ((x<=y) || (y<x))
    {
    }
  else
    link_error1 ();
}

void
all_tests (int x, int y)
{
  test1 (x, y);
  test2 (x, y);
  test3 (x, y);
  test4 (x, y);
  test5 (x, y);
  test6 (x, y);
}

int
main ()
{
  all_tests (0, 0);
  all_tests (1, 2);
  all_tests (4, 3);

  return 0;
}

#ifndef __OPTIMIZE__
void link_error0() {}
void link_error1() {}
#endif /* ! __OPTIMIZE__ */
// source: complex-1.c
double
g0 (double x)
{
  return 1.0;
}

double
g1 (double x)
{
  return -1.0;
}

double
g2 (double x)
{
  return 0.0;
}

__complex__ double
xcexp (__complex__ double x)
{
  double r;

  r = g0 (__real__ x);
  __real__ x = r * g1 (__imag__ x);
  __imag__ x = r * g2 (__imag__ x);
  return x;
}

main ()
{
  __complex__ double x;

  x = xcexp (1.0i);
  if (__real__ x != -1.0)
    abort ();
  if (__imag__ x != 0.0)
    abort ();
  exit (0);
}
// source: complex-2.c
__complex__ double
f (__complex__ double x, __complex__ double y)
{
  x += y;
  return x;
}

__complex__ double ag = 1.0 + 1.0i;
__complex__ double bg = -2.0 + 2.0i;

main ()
{
  __complex__ double a, b, c;

  a = ag;
  b = -2.0 + 2.0i;
  c = f (a, b);

  if (a != 1.0 + 1.0i)
    abort ();
  if (b != -2.0 + 2.0i)
    abort ();
  if (c != -1.0 + 3.0i)
    abort ();

  exit (0);
}
// source: complex-3.c
struct complex
{
  float r;
  float i;
};

struct complex cmplx (float, float);

struct complex
f (float a, float b)
{
  struct complex c;
  c.r = a;
  c.i = b;
  return c;
}

main ()
{
  struct complex z = f (1.0, 0.0);

  if (z.r != 1.0 || z.i != 0.0)
    abort ();
  exit (0);
}
// source: complex-4.c
main ()
{
  if ((__complex__ double) 0.0 != (__complex__ double) (-0.0))
    abort ();

  if (0.0 != -0.0)
    abort ();
  exit (0);
}
// source: complex-5.c
float __complex__
p (float __complex__  a, float __complex__  b)
{
  return a + b;
}

float __complex__  x = 1.0 + 14.0 * (1.0fi);
float __complex__  y = 7.0 + 5.0 * (1.0fi);
float __complex__  w = 8.0 + 19.0 * (1.0fi);
float __complex__  z;

main ()
{

  z = p (x,y);
  y = p (x, 1.0f / z);
  if (z != w)
    abort ();
  exit (0);
}
// source: complex-6.c
/* { dg-skip-if "requires io" { freestanding } }  */

/* This test tests complex conjugate and passing/returning of
   complex parameter.  */

#include <stdlib.h>
#include <stdio.h>

int err;

#define TEST(TYPE, FUNC)					\
__complex__ TYPE						\
ctest_ ## FUNC (__complex__ TYPE x)				\
{								\
  __complex__ TYPE res;						\
								\
  res = ~x;							\
								\
  return res;							\
}								\
								\
void								\
test_ ## FUNC (void)						\
{								\
  __complex__ TYPE res, x;					\
								\
  x = 1.0 + 2.0i;						\
								\
  res = ctest_ ## FUNC (x);					\
								\
  if (res != 1.0 - 2.0i)					\
    {								\
      printf ("test_" #FUNC " failed\n");			\
      ++err;							\
    }								\
}


TEST(float, float)
TEST(double, double)
TEST(long double, long_double)
TEST(int, int)
TEST(long int, long_int)

int
main (void)
{

  err = 0;

  test_float ();
  test_double ();
  test_long_double ();
  test_int ();
  test_long_int ();

  if (err != 0)
    abort ();

  return 0;
}
// source: complex-7.c
/* Test argument passing of complex values.  The MIPS64 compiler had a
   bug when they were split between registers and the stack.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */

volatile _Complex float f1 = 1.1f + 2.2if;
volatile _Complex float f2 = 3.3f + 4.4if;
volatile _Complex float f3 = 5.5f + 6.6if;
volatile _Complex float f4 = 7.7f + 8.8if;
volatile _Complex float f5 = 9.9f + 10.1if;
volatile _Complex double d1 = 1.1 + 2.2i;
volatile _Complex double d2 = 3.3 + 4.4i;
volatile _Complex double d3 = 5.5 + 6.6i;
volatile _Complex double d4 = 7.7 + 8.8i;
volatile _Complex double d5 = 9.9 + 10.1i;
volatile _Complex long double ld1 = 1.1L + 2.2iL;
volatile _Complex long double ld2 = 3.3L + 4.4iL;
volatile _Complex long double ld3 = 5.5L + 6.6iL;
volatile _Complex long double ld4 = 7.7L + 8.8iL;
volatile _Complex long double ld5 = 9.9L + 10.1iL;

extern void abort (void);
extern void exit (int);

__attribute__((noinline)) void
check_float (int a, _Complex float a1, _Complex float a2,
	     _Complex float a3, _Complex float a4, _Complex float a5)
{
  if (a1 != f1 || a2 != f2 || a3 != f3 || a4 != f4 || a5 != f5)
    abort ();
}

__attribute__((noinline)) void
check_double (int a, _Complex double a1, _Complex double a2,
	     _Complex double a3, _Complex double a4, _Complex double a5)
{
  if (a1 != d1 || a2 != d2 || a3 != d3 || a4 != d4 || a5 != d5)
    abort ();
}

__attribute__((noinline)) void
check_long_double (int a, _Complex long double a1, _Complex long double a2,
	     _Complex long double a3, _Complex long double a4,
		   _Complex long double a5)
{
  if (a1 != ld1 || a2 != ld2 || a3 != ld3 || a4 != ld4 || a5 != ld5)
    abort ();
}

int
main (void)
{
  check_float (0, f1, f2, f3, f4, f5);
  check_double (0, d1, d2, d3, d4, d5);
  check_long_double (0, ld1, ld2, ld3, ld4, ld5);
  exit (0);
}
// source: compndlit-1.c
/* The bit-field below would have a problem if __INT_MAX__ is too
   small.  */
#if __INT_MAX__ < 2147483647
int
main (void)
{
  exit (0);
}
#else
struct S
{
  int a:3;
  unsigned b:1, c:28;
};

struct S x = {1, 1, 1};

main ()
{
  x = (struct S) {b:0, a:0, c:({ struct S o = x; o.a == 1 ? 10 : 20;})};
  if (x.c != 10)
    abort ();
  exit (0);
}
#endif
// source: const-addr-expr-1.c
#include        <stdio.h>
#include        <stdlib.h>
extern void abort();

typedef struct foo
{
        int     uaattrid;
        char    *name;
} FOO;

FOO     Upgrade_items[] =
{
        {1, "1"},
        {2, "2"},
        {0, NULL}
};

int     *Upgd_minor_ID =
        (int *) &((Upgrade_items + 1)->uaattrid);

int     *Upgd_minor_ID1 =
        (int *) &((Upgrade_items)->uaattrid);

int
main(int argc, char **argv)
{
	if (*Upgd_minor_ID != 2)
	  abort();

	if (*Upgd_minor_ID1 != 1)
	  abort();
	return 0;
}
// source: conversion.c
/* Test front-end conversions, optimizer conversions, and run-time
   conversions between different arithmetic types.

   Constants are specified in a non-obvious way to make them work for
   any word size.  Their value on a 32-bit machine is indicated in the
   comments.

   Note that this code is NOT intended for testing of accuracy of fp
   conversions.  */

float
u2f(u)
     unsigned int u;
{
  return u;
}

double
u2d(u)
     unsigned int u;
{
  return u;
}

long double
u2ld(u)
     unsigned int u;
{
  return u;
}

float
s2f(s)
     int s;
{
  return s;
}

double
s2d(s)
     int s;
{
  return s;
}

long double
s2ld(s)
     int s;
{
  return s;
}

int
fnear (float x, float y)
{
  float t = x - y;
  return t == 0 || x / t > 1000000.0;
}

int
dnear (double x, double y)
{
  double t = x - y;
  return t == 0 || x / t > 100000000000000.0;
}

int
ldnear (long double x, long double y)
{
  long double t = x - y;
  return t == 0 || x / t > 100000000000000000000000000000000.0;
}

test_integer_to_float()
{
  if (u2f(0U) != (float) 0U)				/* 0 */
    abort();
  if (!fnear (u2f(~0U), (float) ~0U))			/* 0xffffffff */
    abort();
  if (!fnear (u2f((~0U) >> 1), (float) ((~0U) >> 1)))	/* 0x7fffffff */
    abort();
  if (u2f(~((~0U) >> 1)) != (float) ~((~0U) >> 1))	/* 0x80000000 */
    abort();

  if (u2d(0U) != (double) 0U)				/* 0 */
    abort();
  if (!dnear (u2d(~0U), (double) ~0U))			/* 0xffffffff */
    abort();
  if (!dnear (u2d((~0U) >> 1),(double) ((~0U) >> 1)))	/* 0x7fffffff */
    abort();
  if (u2d(~((~0U) >> 1)) != (double) ~((~0U) >> 1))	/* 0x80000000 */
    abort();

  if (u2ld(0U) != (long double) 0U)			/* 0 */
    abort();
  if (!ldnear (u2ld(~0U), (long double) ~0U))		/* 0xffffffff */
    abort();
  if (!ldnear (u2ld((~0U) >> 1),(long double) ((~0U) >> 1)))	/* 0x7fffffff */
    abort();
  if (u2ld(~((~0U) >> 1)) != (long double) ~((~0U) >> 1))	/* 0x80000000 */
    abort();

  if (s2f(0) != (float) 0)				/* 0 */
    abort();
  if (!fnear (s2f(~0), (float) ~0))			/* 0xffffffff */
    abort();
  if (!fnear (s2f((int)((~0U) >> 1)), (float)(int)((~0U) >> 1))) /* 0x7fffffff */
    abort();
  if (s2f((int)(~((~0U) >> 1))) != (float)(int)~((~0U) >> 1)) /* 0x80000000 */
    abort();

  if (s2d(0) != (double) 0)				/* 0 */
    abort();
  if (!dnear (s2d(~0), (double) ~0))			/* 0xffffffff */
    abort();
  if (!dnear (s2d((int)((~0U) >> 1)), (double)(int)((~0U) >> 1))) /* 0x7fffffff */
    abort();
  if (s2d((int)~((~0U) >> 1)) != (double)(int)~((~0U) >> 1)) /* 0x80000000 */
    abort();

  if (s2ld(0) != (long double) 0)			/* 0 */
    abort();
  if (!ldnear (s2ld(~0), (long double) ~0))		/* 0xffffffff */
    abort();
  if (!ldnear (s2ld((int)((~0U) >> 1)), (long double)(int)((~0U) >> 1))) /* 0x7fffffff */
    abort();
  if (s2ld((int)~((~0U) >> 1)) != (long double)(int)~((~0U) >> 1)) /* 0x80000000 */
    abort();
}

#if __GNUC__
float
ull2f(u)
     unsigned long long int u;
{
  return u;
}

double
ull2d(u)
     unsigned long long int u;
{
  return u;
}

long double
ull2ld(u)
     unsigned long long int u;
{
  return u;
}

float
sll2f(s)
     long long int s;
{
  return s;
}

double
sll2d(s)
     long long int s;
{
  return s;
}

long double
sll2ld(s)
     long long int s;
{
  return s;
}

test_longlong_integer_to_float()
{
  if (ull2f(0ULL) != (float) 0ULL)			/* 0 */
    abort();
  if (ull2f(~0ULL) != (float) ~0ULL)			/* 0xffffffff */
    abort();
  if (ull2f((~0ULL) >> 1) != (float) ((~0ULL) >> 1))	/* 0x7fffffff */
    abort();
  if (ull2f(~((~0ULL) >> 1)) != (float) ~((~0ULL) >> 1)) /* 0x80000000 */
    abort();

  if (ull2d(0ULL) != (double) 0ULL)			/* 0 */
    abort();
#if __HAVE_68881__
  /* Some 68881 targets return values in fp0, with excess precision.
     But the compile-time conversion to double works correctly.  */
  if (! dnear (ull2d(~0ULL), (double) ~0ULL))		/* 0xffffffff */
    abort();
  if (! dnear (ull2d((~0ULL) >> 1), (double) ((~0ULL) >> 1))) /* 0x7fffffff */
    abort();
#else
  if (ull2d(~0ULL) != (double) ~0ULL)			/* 0xffffffff */
    abort();
  if (ull2d((~0ULL) >> 1) != (double) ((~0ULL) >> 1))	/* 0x7fffffff */
    abort();
#endif
  if (ull2d(~((~0ULL) >> 1)) != (double) ~((~0ULL) >> 1)) /* 0x80000000 */
    abort();

  if (ull2ld(0ULL) != (long double) 0ULL)		/* 0 */
    abort();
  if (ull2ld(~0ULL) != (long double) ~0ULL)		/* 0xffffffff */
    abort();
  if (ull2ld((~0ULL) >> 1) != (long double) ((~0ULL) >> 1))	/* 0x7fffffff */
    abort();
  if (ull2ld(~((~0ULL) >> 1)) != (long double) ~((~0ULL) >> 1)) /* 0x80000000 */
    abort();

  if (sll2f(0LL) != (float) 0LL)			/* 0 */
    abort();
  if (sll2f(~0LL) != (float) ~0LL)			/* 0xffffffff */
    abort();
  if (! fnear (sll2f((long long int)((~0ULL) >> 1)), (float)(long long int)((~0ULL) >> 1))) /* 0x7fffffff */
    abort();
  if (sll2f((long long int)(~((~0ULL) >> 1))) != (float)(long long int)~((~0ULL) >> 1)) /* 0x80000000 */
    abort();

  if (sll2d(0LL) != (double) 0LL)			/* 0 */
    abort();
  if (sll2d(~0LL) != (double) ~0LL)			/* 0xffffffff */
    abort();
  if (!dnear (sll2d((long long int)((~0ULL) >> 1)), (double)(long long int)((~0ULL) >> 1))) /* 0x7fffffff */
    abort();
  if (! dnear (sll2d((long long int)~((~0ULL) >> 1)), (double)(long long int)~((~0ULL) >> 1))) /* 0x80000000 */
    abort();

  if (sll2ld(0LL) != (long double) 0LL)			/* 0 */
    abort();
  if (sll2ld(~0LL) != (long double) ~0LL)		/* 0xffffffff */
    abort();
  if (!ldnear (sll2ld((long long int)((~0ULL) >> 1)), (long double)(long long int)((~0ULL) >> 1))) /* 0x7fffffff */
    abort();
  if (! ldnear (sll2ld((long long int)~((~0ULL) >> 1)), (long double)(long long int)~((~0ULL) >> 1))) /* 0x80000000 */
    abort();
}
#endif

unsigned int
f2u(float f)
{
  return (unsigned) f;
}

unsigned int
d2u(double d)
{
  return (unsigned) d;
}

unsigned int
ld2u(long double d)
{
  return (unsigned) d;
}

int
f2s(float f)
{
  return (int) f;
}

int
d2s(double d)
{
  return (int) d;
}

int
ld2s(long double d)
{
  return (int) d;
}

test_float_to_integer()
{
  if (f2u(0.0) != 0)
    abort();
  if (f2u(0.999) != 0)
    abort();
  if (f2u(1.0) != 1)
    abort();
  if (f2u(1.99) != 1)
    abort();
#ifdef __SPU__
  /* SPU float rounds towards zero.  */
  if (f2u((float) ((~0U) >> 1)) != 0x7fffff80)
    abort();
#else
  if (f2u((float) ((~0U) >> 1)) != (~0U) >> 1 &&	/* 0x7fffffff */
      f2u((float) ((~0U) >> 1)) != ((~0U) >> 1) + 1)
    abort();
#endif
  if (f2u((float) ~((~0U) >> 1)) != ~((~0U) >> 1))	/* 0x80000000 */
    abort();

 /* These tests require double precision, so for hosts that don't offer
    that much precision, just ignore these test.  */
 if (sizeof (double) >= 8) {
  if (d2u(0.0) != 0)
    abort();
  if (d2u(0.999) != 0)
    abort();
  if (d2u(1.0) != 1)
    abort();
  if (d2u(1.99) != 1)
    abort();
  if (d2u((double) (~0U)) != ~0U)			/* 0xffffffff */
    abort();
  if (d2u((double) ((~0U) >> 1)) != (~0U) >> 1)		/* 0x7fffffff */
    abort();
  if (d2u((double) ~((~0U) >> 1)) != ~((~0U) >> 1))	/* 0x80000000 */
    abort();
 }

 /* These tests require long double precision, so for hosts that don't offer
    that much precision, just ignore these test.  */
 if (sizeof (long double) >= 8) {
  if (ld2u(0.0) != 0)
    abort();
  if (ld2u(0.999) != 0)
    abort();
  if (ld2u(1.0) != 1)
    abort();
  if (ld2u(1.99) != 1)
    abort();
  if (ld2u((long double) (~0U)) != ~0U)			/* 0xffffffff */
    abort();
  if (ld2u((long double) ((~0U) >> 1)) != (~0U) >> 1)	/* 0x7fffffff */
    abort();
  if (ld2u((long double) ~((~0U) >> 1)) != ~((~0U) >> 1))	/* 0x80000000 */
    abort();
 }

  if (f2s(0.0) != 0)
    abort();
  if (f2s(0.999) != 0)
    abort();
  if (f2s(1.0) != 1)
    abort();
  if (f2s(1.99) != 1)
    abort();
  if (f2s(-0.999) != 0)
    abort();
  if (f2s(-1.0) != -1)
    abort();
  if (f2s(-1.99) != -1)
    abort();
  if (f2s((float)(int)~((~0U) >> 1)) != (int)~((~0U) >> 1)) /* 0x80000000 */
    abort();

 /* These tests require double precision, so for hosts that don't offer
    that much precision, just ignore these test.  */
 if (sizeof (double) >= 8) {
  if (d2s(0.0) != 0)
    abort();
  if (d2s(0.999) != 0)
    abort();
  if (d2s(1.0) != 1)
    abort();
  if (d2s(1.99) != 1)
    abort();
  if (d2s(-0.999) != 0)
    abort();
  if (d2s(-1.0) != -1)
    abort();
  if (d2s(-1.99) != -1)
    abort();
  if (d2s((double) ((~0U) >> 1)) != (~0U) >> 1)		/* 0x7fffffff */
    abort();
  if (d2s((double)(int)~((~0U) >> 1)) != (int)~((~0U) >> 1)) /* 0x80000000 */
    abort();
 }

 /* These tests require long double precision, so for hosts that don't offer
    that much precision, just ignore these test.  */
 if (sizeof (long double) >= 8) {
  if (ld2s(0.0) != 0)
    abort();
  if (ld2s(0.999) != 0)
    abort();
  if (ld2s(1.0) != 1)
    abort();
  if (ld2s(1.99) != 1)
    abort();
  if (ld2s(-0.999) != 0)
    abort();
  if (ld2s(-1.0) != -1)
    abort();
  if (ld2s(-1.99) != -1)
    abort();
  if (ld2s((long double) ((~0U) >> 1)) != (~0U) >> 1)		/* 0x7fffffff */
    abort();
  if (ld2s((long double)(int)~((~0U) >> 1)) != (int)~((~0U) >> 1)) /* 0x80000000 */
    abort();
 }
}

#if __GNUC__
unsigned long long int
f2ull(float f)
{
  return (unsigned long long int) f;
}

unsigned long long int
d2ull(double d)
{
  return (unsigned long long int) d;
}

unsigned long long int
ld2ull(long double d)
{
  return (unsigned long long int) d;
}

long long int
f2sll(float f)
{
  return (long long int) f;
}

long long int
d2sll(double d)
{
  return (long long int) d;
}

long long int
ld2sll(long double d)
{
  return (long long int) d;
}

test_float_to_longlong_integer()
{
  if (f2ull(0.0) != 0LL)
    abort();
  if (f2ull(0.999) != 0LL)
    abort();
  if (f2ull(1.0) != 1LL)
    abort();
  if (f2ull(1.99) != 1LL)
    abort();
#ifdef __SPU__
  /* SPU float rounds towards zero.  */
  if (f2ull((float) ((~0ULL) >> 1)) != 0x7fffff8000000000ULL)
    abort();
#else
  if (f2ull((float) ((~0ULL) >> 1)) != (~0ULL) >> 1 &&	/* 0x7fffffff */
      f2ull((float) ((~0ULL) >> 1)) != ((~0ULL) >> 1) + 1)
    abort();
#endif
  if (f2ull((float) ~((~0ULL) >> 1)) != ~((~0ULL) >> 1)) /* 0x80000000 */
    abort();

  if (d2ull(0.0) != 0LL)
    abort();
  if (d2ull(0.999) != 0LL)
    abort();
  if (d2ull(1.0) != 1LL)
    abort();
  if (d2ull(1.99) != 1LL)
    abort();
  if (d2ull((double) ((~0ULL) >> 1)) != (~0ULL) >> 1 &&	/* 0x7fffffff */
      d2ull((double) ((~0ULL) >> 1)) != ((~0ULL) >> 1) + 1)
    abort();
  if (d2ull((double) ~((~0ULL) >> 1)) != ~((~0ULL) >> 1)) /* 0x80000000 */
    abort();

  if (ld2ull(0.0) != 0LL)
    abort();
  if (ld2ull(0.999) != 0LL)
    abort();
  if (ld2ull(1.0) != 1LL)
    abort();
  if (ld2ull(1.99) != 1LL)
    abort();
  if (ld2ull((long double) ((~0ULL) >> 1)) != (~0ULL) >> 1 &&	/* 0x7fffffff */
      ld2ull((long double) ((~0ULL) >> 1)) != ((~0ULL) >> 1) + 1)
    abort();
  if (ld2ull((long double) ~((~0ULL) >> 1)) != ~((~0ULL) >> 1)) /* 0x80000000 */
    abort();


  if (f2sll(0.0) != 0LL)
    abort();
  if (f2sll(0.999) != 0LL)
    abort();
  if (f2sll(1.0) != 1LL)
    abort();
  if (f2sll(1.99) != 1LL)
    abort();
  if (f2sll(-0.999) != 0LL)
    abort();
  if (f2sll(-1.0) != -1LL)
    abort();
  if (f2sll(-1.99) != -1LL)
    abort();
  if (f2sll((float)(long long int)~((~0ULL) >> 1)) != (long long int)~((~0ULL) >> 1)) /* 0x80000000 */
    abort();

  if (d2sll(0.0) != 0LL)
    abort();
  if (d2sll(0.999) != 0LL)
    abort();
  if (d2sll(1.0) != 1LL)
    abort();
  if (d2sll(1.99) != 1LL)
    abort();
  if (d2sll(-0.999) != 0LL)
    abort();
  if (d2sll(-1.0) != -1LL)
    abort();
  if (d2sll(-1.99) != -1LL)
    abort();
  if (d2sll((double)(long long int)~((~0ULL) >> 1)) != (long long int)~((~0ULL) >> 1)) /* 0x80000000 */
    abort();

  if (ld2sll(0.0) != 0LL)
    abort();
  if (ld2sll(0.999) != 0LL)
    abort();
  if (ld2sll(1.0) != 1LL)
    abort();
  if (ld2sll(1.99) != 1LL)
    abort();
  if (ld2sll(-0.999) != 0LL)
    abort();
  if (ld2sll(-1.0) != -1LL)
    abort();
  if (ld2sll(-1.99) != -1LL)
    abort();
  if (ld2sll((long double)(long long int)~((~0ULL) >> 1)) != (long long int)~((~0ULL) >> 1)) /* 0x80000000 */
    abort();
}
#endif

main()
{
  test_integer_to_float();
  test_float_to_integer();
#if __GNUC__
  test_longlong_integer_to_float();
  test_float_to_longlong_integer();
#endif
  exit(0);
}
// source: cvt-1.c
static inline long
g1 (double x)
{
  return (double) (long) x;
}

long
g2 (double f)
{
  return f;
}

double
f (long i)
{
  if (g1 (i) != g2 (i))
    abort ();
  return g2 (i);
}

main ()
{
  if (f (123456789L) != 123456789L)
    abort ();
  if (f (123456789L) != g2 (123456789L))
    abort ();
  exit (0);
}
// source: dbra-1.c
f1 (a)
     long a;
{
  int i;
  for (i = 0; i < 10; i++)
    {
      if (--a == -1)
	return i;
    }
  return -1;
}

f2 (a)
     long a;
{
  int i;
  for (i = 0; i < 10; i++)
    {
      if (--a != -1)
	return i;
    }
  return -1;
}

f3 (a)
     long a;
{
  int i;
  for (i = 0; i < 10; i++)
    {
      if (--a == 0)
	return i;
    }
  return -1;
}

f4 (a)
     long a;
{
  int i;
  for (i = 0; i < 10; i++)
    {
      if (--a != 0)
	return i;
    }
  return -1;
}

f5 (a)
     long a;
{
  int i;
  for (i = 0; i < 10; i++)
    {
      if (++a == 0)
	return i;
    }
  return -1;
}

f6 (a)
     long a;
{
  int i;
  for (i = 0; i < 10; i++)
    {
      if (++a != 0)
	return i;
    }
  return -1;
}


main()
{
  if (f1 (5L) != 5)
    abort ();
  if (f2 (1L) != 0)
    abort ();
  if (f2 (0L) != 1)
    abort ();
  if (f3 (5L) != 4)
    abort ();
  if (f4 (1L) != 1)
    abort ();
  if (f4 (0L) != 0)
    abort ();
  if (f5 (-5L) != 4)
    abort ();
  if (f6 (-1L) != 1)
    abort ();
  if (f6 (0L) != 0)
    abort ();
  exit (0);
}
// source: divcmp-1.c
extern void abort(void);

int test1(int x)
{
  return x/10 == 2;
}

int test1u(unsigned int x)
{
  return x/10U == 2;
}

int test2(int x)
{
  return x/10 == 0;
}

int test2u(unsigned int x)
{
  return x/10U == 0;
}

int test3(int x)
{
  return x/10 != 2;
}

int test3u(unsigned int x)
{
  return x/10U != 2;
}

int test4(int x)
{
  return x/10 != 0;
}

int test4u(unsigned int x)
{
  return x/10U != 0;
}

int test5(int x)
{
  return x/10 < 2;
}

int test5u(unsigned int x)
{
  return x/10U < 2;
}

int test6(int x)
{
  return x/10 < 0;
}

int test7(int x)
{
  return x/10  <= 2;
}

int test7u(unsigned int x)
{
  return x/10U <= 2;
}

int test8(int x)
{
  return x/10 <= 0;
}

int test8u(unsigned int x)
{
  return x/10U <= 0;
}

int test9(int x)
{
  return x/10 > 2;
}

int test9u(unsigned int x)
{
  return x/10U > 2;
}

int test10(int x)
{
  return x/10 > 0;
}

int test10u(unsigned int x)
{
  return x/10U > 0;
}

int test11(int x)
{
  return x/10 >= 2;
}

int test11u(unsigned int x)
{
  return x/10U >= 2;
}

int test12(int x)
{
  return x/10 >= 0;
}


int main()
{
  if (test1(19) != 0)
    abort ();
  if (test1(20) != 1)
    abort ();
  if (test1(29) != 1)
    abort ();
  if (test1(30) != 0)
    abort ();

  if (test1u(19) != 0)
    abort ();
  if (test1u(20) != 1)
    abort ();
  if (test1u(29) != 1)
    abort ();
  if (test1u(30) != 0)
    abort ();

  if (test2(0) != 1)
    abort ();
  if (test2(9) != 1)
    abort ();
  if (test2(10) != 0)
    abort ();
  if (test2(-1) != 1)
    abort ();
  if (test2(-9) != 1)
    abort ();
  if (test2(-10) != 0)
    abort ();

  if (test2u(0) != 1)
    abort ();
  if (test2u(9) != 1)
    abort ();
  if (test2u(10) != 0)
    abort ();
  if (test2u(-1) != 0)
    abort ();
  if (test2u(-9) != 0)
    abort ();
  if (test2u(-10) != 0)
    abort ();

  if (test3(19) != 1)
    abort ();
  if (test3(20) != 0)
    abort ();
  if (test3(29) != 0)
    abort ();
  if (test3(30) != 1)
    abort ();

  if (test3u(19) != 1)
    abort ();
  if (test3u(20) != 0)
    abort ();
  if (test3u(29) != 0)
    abort ();
  if (test3u(30) != 1)
    abort ();

  if (test4(0) != 0)
    abort ();
  if (test4(9) != 0)
    abort ();
  if (test4(10) != 1)
    abort ();
  if (test4(-1) != 0)
    abort ();
  if (test4(-9) != 0)
    abort ();
  if (test4(-10) != 1)
    abort ();

  if (test4u(0) != 0)
    abort ();
  if (test4u(9) != 0)
    abort ();
  if (test4u(10) != 1)
    abort ();
  if (test4u(-1) != 1)
    abort ();
  if (test4u(-9) != 1)
    abort ();
  if (test4u(-10) != 1)
    abort ();

  if (test5(19) != 1)
    abort ();
  if (test5(20) != 0)
    abort ();
  if (test5(29) != 0)
    abort ();
  if (test5(30) != 0)
    abort ();

  if (test5u(19) != 1)
    abort ();
  if (test5u(20) != 0)
    abort ();
  if (test5u(29) != 0)
    abort ();
  if (test5u(30) != 0)
    abort ();

  if (test6(0) != 0)
    abort ();
  if (test6(9) != 0)
    abort ();
  if (test6(10) != 0)
    abort ();
  if (test6(-1) != 0)
    abort ();
  if (test6(-9) != 0)
    abort ();
  if (test6(-10) != 1)
    abort ();

  if (test7(19) != 1)
    abort ();
  if (test7(20) != 1)
    abort ();
  if (test7(29) != 1)
    abort ();
  if (test7(30) != 0)
    abort ();

  if (test7u(19) != 1)
    abort ();
  if (test7u(20) != 1)
    abort ();
  if (test7u(29) != 1)
    abort ();
  if (test7u(30) != 0)
    abort ();

  if (test8(0) != 1)
    abort ();
  if (test8(9) != 1)
    abort ();
  if (test8(10) != 0)
    abort ();
  if (test8(-1) != 1)
    abort ();
  if (test8(-9) != 1)
    abort ();
  if (test8(-10) != 1)
    abort ();

  if (test8u(0) != 1)
    abort ();
  if (test8u(9) != 1)
    abort ();
  if (test8u(10) != 0)
    abort ();
  if (test8u(-1) != 0)
    abort ();
  if (test8u(-9) != 0)
    abort ();
  if (test8u(-10) != 0)
    abort ();

  if (test9(19) != 0)
    abort ();
  if (test9(20) != 0)
    abort ();
  if (test9(29) != 0)
    abort ();
  if (test9(30) != 1)
    abort ();

  if (test9u(19) != 0)
    abort ();
  if (test9u(20) != 0)
    abort ();
  if (test9u(29) != 0)
    abort ();
  if (test9u(30) != 1)
    abort ();

  if (test10(0) != 0)
    abort ();
  if (test10(9) != 0)
    abort ();
  if (test10(10) != 1)
    abort ();
  if (test10(-1) != 0)
    abort ();
  if (test10(-9) != 0)
    abort ();
  if (test10(-10) != 0)
    abort ();

  if (test10u(0) != 0)
    abort ();
  if (test10u(9) != 0)
    abort ();
  if (test10u(10) != 1)
    abort ();
  if (test10u(-1) != 1)
    abort ();
  if (test10u(-9) != 1)
    abort ();
  if (test10u(-10) != 1)
    abort ();

  if (test11(19) != 0)
    abort ();
  if (test11(20) != 1)
    abort ();
  if (test11(29) != 1)
    abort ();
  if (test11(30) != 1)
    abort ();

  if (test11u(19) != 0)
    abort ();
  if (test11u(20) != 1)
    abort ();
  if (test11u(29) != 1)
    abort ();
  if (test11u(30) != 1)
    abort ();

  if (test12(0) != 1)
    abort ();
  if (test12(9) != 1)
    abort ();
  if (test12(10) != 1)
    abort ();
  if (test12(-1) != 1)
    abort ();
  if (test12(-9) != 1)
    abort ();
  if (test12(-10) != 0)
    abort ();

  return 0;
}
// source: divcmp-2.c
extern void abort (void);

int test1(int x)
{
  return x/10 == 2;
}

int test2(int x)
{
  return x/10 == 0;
}

int test3(int x)
{
  return x/10 == -2;
}

int test4(int x)
{
  return x/-10 == 2;
}

int test5(int x)
{
  return x/-10 == 0;
}

int test6(int x)
{
  return x/-10 == -2;
}


int main()
{
  if (test1(19) != 0)
    abort ();
  if (test1(20) != 1)
    abort ();
  if (test1(29) != 1)
    abort ();
  if (test1(30) != 0)
    abort ();

  if (test2(-10) != 0)
    abort ();
  if (test2(-9) != 1)
    abort ();
  if (test2(9) != 1)
    abort ();
  if (test2(10) != 0)
    abort ();

  if (test3(-30) != 0)
    abort ();
  if (test3(-29) != 1)
    abort ();
  if (test3(-20) != 1)
    abort ();
  if (test3(-19) != 0)
    abort ();

  if (test4(-30) != 0)
    abort ();
  if (test4(-29) != 1)
    abort ();
  if (test4(-20) != 1)
    abort ();
  if (test4(-19) != 0)
    abort ();

  if (test5(-10) != 0)
    abort ();
  if (test5(-9) != 1)
    abort ();
  if (test5(9) != 1)
    abort ();
  if (test5(10) != 0)
    abort ();

  if (test6(19) != 0)
    abort ();
  if (test6(20) != 1)
    abort ();
  if (test6(29) != 1)
    abort ();
  if (test6(30) != 0)
    abort ();

  return 0;
}
// source: divcmp-3.c
extern void abort(void);

int test1(char x)
{
  return x/100 == 3;
}

int test1u(unsigned char x)
{
  return x/100 == 3;
}

int test2(char x)
{
  return x/100 != 3;
}

int test2u(unsigned char x)
{
  return x/100 != 3;
}

int test3(char x)
{
  return x/100 < 3;
}

int test3u(unsigned char x)
{
  return x/100 < 3;
}

int test4(char x)
{
  return x/100 <= 3;
}

int test4u(unsigned char x)
{
  return x/100 <= 3;
}

int test5(char x)
{
  return x/100 > 3;
}

int test5u(unsigned char x)
{
  return x/100 > 3;
}

int test6(char x)
{
  return x/100 >= 3;
}

int test6u(unsigned char x)
{
  return x/100 >= 3;
}


int main()
{
  int c;

  for (c=-128; c<256; c++)
  {
    if (test1(c) != 0)
      abort ();
    if (test1u(c) != 0)
      abort ();
    if (test2(c) != 1)
      abort ();
    if (test2u(c) != 1)
      abort ();
    if (test3(c) != 1)
      abort ();
    if (test3u(c) != 1)
      abort ();
    if (test4(c) != 1)
      abort ();
    if (test4u(c) != 1)
      abort ();
    if (test5(c) != 0)
      abort ();
    if (test5u(c) != 0)
      abort ();
    if (test6(c) != 0)
      abort ();
    if (test6u(c) != 0)
      abort ();
  }
  return 0;
}
// source: divcmp-4.c
/* PR middle-end/17894 */

extern void abort(void);

int test1(int x)
{
  return x/-10 == 2;
}

int test2(int x)
{
  return x/-10 == 0;
}

int test3(int x)
{
  return x/-10 != 2;
}

int test4(int x)
{
  return x/-10 != 0;
}

int test5(int x)
{
  return x/-10 < 2;
}

int test6(int x)
{
  return x/-10 < 0;
}

int test7(int x)
{
  return x/-10  <= 2;
}

int test8(int x)
{
  return x/-10 <= 0;
}

int test9(int x)
{
  return x/-10 > 2;
}

int test10(int x)
{
  return x/-10 > 0;
}

int test11(int x)
{
  return x/-10 >= 2;
}

int test12(int x)
{
  return x/-10 >= 0;
}


int main()
{
  if (test1(-30) != 0)
    abort ();
  if (test1(-29) != 1)
    abort ();
  if (test1(-20) != 1)
    abort ();
  if (test1(-19) != 0)
    abort ();

  if (test2(0) != 1)
    abort ();
  if (test2(9) != 1)
    abort ();
  if (test2(10) != 0)
    abort ();
  if (test2(-1) != 1)
    abort ();
  if (test2(-9) != 1)
    abort ();
  if (test2(-10) != 0)
    abort ();

  if (test3(-30) != 1)
    abort ();
  if (test3(-29) != 0)
    abort ();
  if (test3(-20) != 0)
    abort ();
  if (test3(-19) != 1)
    abort ();

  if (test4(0) != 0)
    abort ();
  if (test4(9) != 0)
    abort ();
  if (test4(10) != 1)
    abort ();
  if (test4(-1) != 0)
    abort ();
  if (test4(-9) != 0)
    abort ();
  if (test4(-10) != 1)
    abort ();

  if (test5(-30) != 0)
    abort ();
  if (test5(-29) != 0)
    abort ();
  if (test5(-20) != 0)
    abort ();
  if (test5(-19) != 1)
    abort ();

  if (test6(0) != 0)
    abort ();
  if (test6(9) != 0)
    abort ();
  if (test6(10) != 1)
    abort ();
  if (test6(-1) != 0)
    abort ();
  if (test6(-9) != 0)
    abort ();
  if (test6(-10) != 0)
    abort ();

  if (test7(-30) != 0)
    abort ();
  if (test7(-29) != 1)
    abort ();
  if (test7(-20) != 1)
    abort ();
  if (test7(-19) != 1)
    abort ();

  if (test8(0) != 1)
    abort ();
  if (test8(9) != 1)
    abort ();
  if (test8(10) != 1)
    abort ();
  if (test8(-1) != 1)
    abort ();
  if (test8(-9) != 1)
    abort ();
  if (test8(-10) != 0)
    abort ();

  if (test9(-30) != 1)
    abort ();
  if (test9(-29) != 0)
    abort ();
  if (test9(-20) != 0)
    abort ();
  if (test9(-19) != 0)
    abort ();

  if (test10(0) != 0)
    abort ();
  if (test10(9) != 0)
    abort ();
  if (test10(10) != 0)
    abort ();
  if (test10(-1) != 0)
    abort ();
  if (test10(-9) != 0)
    abort ();
  if (test10(-10) != 1)
    abort ();

  if (test11(-30) != 1)
    abort ();
  if (test11(-29) != 1)
    abort ();
  if (test11(-20) != 1)
    abort ();
  if (test11(-19) != 0)
    abort ();

  if (test12(0) != 1)
    abort ();
  if (test12(9) != 1)
    abort ();
  if (test12(10) != 0)
    abort ();
  if (test12(-1) != 1)
    abort ();
  if (test12(-9) != 1)
    abort ();
  if (test12(-10) != 1)
    abort ();

  return 0;
}
// source: divcmp-5.c
/* PR middle-end/26561 */

extern void abort(void);

int always_one_1 (int a)
{
  if (a/100 >= -999999999)
    return 1;
  else
    return 0;
}

int always_one_2 (int a)
{
  if (a/100 < -999999999)
    return 0;
  else
    return 1;
}

int main(void)
{
  if (always_one_1 (0) != 1)
    abort ();

  if (always_one_2 (0) != 1)
    abort ();

  return 0;
}
// source: divconst-1.c
typedef struct
{
  unsigned a, b, c, d;
} t1;

f (t1 *ps)
{
    ps->a = 10000;
    ps->b = ps->a / 3;
    ps->c = 10000;
    ps->d = ps->c / 3;
}

main ()
{
  t1 s;
  f (&s);
  if (s.a != 10000 || s.b != 3333 || s.c != 10000 || s.d != 3333)
    abort ();
  exit (0);
}
// source: divconst-2.c
long
f (long x)
{
  return x / (-0x7fffffffL - 1L);
}

long
r (long x)
{
  return x % (-0x7fffffffL - 1L);
}

/* Since we have a negative divisor, this equation must hold for the
   results of / and %; no specific results are guaranteed.  */
long
std_eqn (long num, long denom, long quot, long rem)
{
  /* For completeness, a check for "ABS (rem) < ABS (denom)" belongs here,
     but causes trouble on 32-bit machines and isn't worthwhile.  */
  return quot * (-0x7fffffffL - 1L) + rem == num;
}

long nums[] =
{
  -1L, 0x7fffffffL, -0x7fffffffL - 1L
};

main ()
{
  int i;

  for (i = 0;
       i < sizeof (nums) / sizeof (nums[0]);
       i++)
    if (std_eqn (nums[i], -0x7fffffffL - 1L, f (nums[i]), r (nums[i])) == 0)
      abort ();

  exit (0);
}
// source: divconst-3.c
long long
f (long long x)
{
  return x / 10000000000LL;
}

main ()
{
  if (f (10000000000LL) != 1 || f (100000000000LL) != 10)
    abort ();
  exit (0);
}
// source: divmod-1.c
div1 (signed char x)
{
  return x / -1;
}

div2 (signed short x)
{
  return x / -1;
}

div3 (signed char x, signed char y)
{
  return x / y;
}

div4 (signed short x, signed short y)
{
  return x / y;
}

mod1 (signed char x)
{
  return x % -1;
}

mod2 (signed short x)
{
  return x % -1;
}

mod3 (signed char x, signed char y)
{
  return x % y;
}

mod4 (signed short x, signed short y)
{
  return x % y;
}

signed long
mod5 (signed long x, signed long y)
{
  return x % y;
}

unsigned long
mod6 (unsigned long x, unsigned long y)
{
  return x % y;
}

main ()
{
  if (div1 (-(1 << 7)) != 1 << 7)
    abort ();
  if (div2 (-(1 << 15)) != 1 << 15)
    abort ();
  if (div3 (-(1 << 7), -1) != 1 << 7)
    abort ();
  if (div4 (-(1 << 15), -1) != 1 << 15)
    abort ();
  if (mod1 (-(1 << 7)) != 0)
    abort ();
  if (mod2 (-(1 << 15)) != 0)
    abort ();
  if (mod3 (-(1 << 7), -1) != 0)
    abort ();
  if (mod4 (-(1 << 15), -1) != 0)
    abort ();
  if (mod5 (0x50000000, 2) != 0)
    abort ();
  if (mod6 (0x50000000, 2) != 0)
    abort ();

  exit (0);
}
// source: doloop-1.c
#include <limits.h>

extern void exit (int);
extern void abort (void);

volatile unsigned int i;

int
main (void)
{
  unsigned char z = 0;

  do ++i;
  while (--z > 0);
  if (i != UCHAR_MAX + 1U)
    abort ();
  exit (0);
}
// source: doloop-2.c
#include <limits.h>

extern void exit (int);
extern void abort (void);

volatile unsigned int i;

int
main (void)
{
  unsigned short z = 0;

  do ++i;
  while (--z > 0);
  if (i != USHRT_MAX + 1U)
    abort ();
  exit (0);
}
// source: eeprof-1.c
/* { dg-require-effective-target return_address } */
/* { dg-options "-finstrument-functions" } */
/* { dg-xfail-run-if "" { powerpc-ibm-aix* } } */

extern void abort (void);

#define ASSERT(X)	if (!(X)) abort ();
#define NOCHK __attribute__ ((no_instrument_function))

int entry_calls, exit_calls;
void (*last_fn_entered)();
void (*last_fn_exited)();

__attribute__ ((noinline))
int main () NOCHK;

__attribute__ ((noinline))
void foo ()
{
  ASSERT (last_fn_entered == foo);
}

__attribute__ ((noinline))
static void foo2 ()
{
  ASSERT (entry_calls == 1 && exit_calls == 0);
  ASSERT (last_fn_entered == foo2);
  foo ();
  ASSERT (entry_calls == 2 && exit_calls == 1);
  ASSERT (last_fn_entered == foo);
  ASSERT (last_fn_exited == foo);
}

__attribute__ ((noinline))
void nfoo (void) NOCHK;
void nfoo ()
{
  ASSERT (entry_calls == 2 && exit_calls == 2);
  ASSERT (last_fn_entered == foo);
  ASSERT (last_fn_exited == foo2);
  foo ();
  ASSERT (entry_calls == 3 && exit_calls == 3);
  ASSERT (last_fn_entered == foo);
  ASSERT (last_fn_exited == foo);
}

int main ()
{
  ASSERT (entry_calls == 0 && exit_calls == 0);

  foo2 ();

  ASSERT (entry_calls == 2 && exit_calls == 2);
  ASSERT (last_fn_entered == foo);
  ASSERT (last_fn_exited == foo2);

  nfoo ();

  ASSERT (entry_calls == 3 && exit_calls == 3);
  ASSERT (last_fn_entered == foo);

  return 0;
}

void __cyg_profile_func_enter (void*, void*) NOCHK;
void __cyg_profile_func_exit (void*, void*) NOCHK;

__attribute__ ((noinline))
void __cyg_profile_func_enter (void *fn, void *parent)
{
  entry_calls++;
  last_fn_entered = (void (*)())fn;
}
__attribute__ ((noinline))
void __cyg_profile_func_exit (void *fn, void *parent)
{
  exit_calls++;
  last_fn_exited = (void (*)())fn;
}
// source: enum-1.c
typedef enum
{
  END = -1,
  EMPTY = (1 << 8 ) ,
  BACKREF,
  BEGLINE,
  ENDLINE,
  BEGWORD,
  ENDWORD,
  LIMWORD,
  NOTLIMWORD,
  QMARK,
  STAR,
  PLUS,
  REPMN,
  CAT,
  OR,
  ORTOP,
  LPAREN,
  RPAREN,
  CSET
} token;

static token tok;

static int
atom ()
{
  if ((tok >= 0 && tok < (1 << 8 ) ) || tok >= CSET || tok == BACKREF
      || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD
      || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD)
    return 1;
  else
    return 0;
}

main ()
{
  tok = 0;
  if (atom () != 1)
    abort ();
  exit (0);
}
// source: enum-2.c
/* Copyright (C) 2000 Free Software Foundation */
/* by Alexandre Oliva  <aoliva@redhat.com> */

enum foo { FOO, BAR };

/* Even though the underlying type of an enum is unspecified, the type
   of enumeration constants is explicitly defined as int (6.4.4.3/2 in
   the C99 Standard).  Therefore, `i' must not be promoted to
   `unsigned' in the comparison below; we must exit the loop when it
   becomes negative. */

int
main ()
{
  int i;
  for (i = BAR; i >= FOO; --i)
    if (i == -1)
      abort ();

  exit (0);
}
// source: enum-3.c
/* The composite type of int and an enum compatible with int might be
   either of the two types, but it isn't an unsigned type.  */
/* Origin: Joseph Myers <jsm@polyomino.org.uk> */

#include <limits.h>

#include <stdio.h>

extern void abort (void);
extern void exit (int);

enum e { a = INT_MIN };

int *p;
enum e *q;
int
main (void)
{
  enum e x = a;
  q = &x;
  if (*(1 ? q : p) > 0)
    abort ();
  exit (0);
}
// source: extzvsi.c
/* The bit-field below would have a problem if __INT_MAX__ is too
   small.  */
#if __INT_MAX__ < 2147483647
int
main (void)
{
  exit (0);
}
#else
/* Failed on powerpc due to bad extzvsi pattern.  */

struct ieee
{
  unsigned int negative:1;
  unsigned int exponent:11;
  unsigned int mantissa0:20;
  unsigned int mantissa1:32;
} x;

unsigned int
foo (void)
{
  unsigned int exponent;

  exponent = x.exponent;
  if (exponent == 0)
    return 1;
  else if (exponent > 1)
    return 2;
  return 0;
}

int
main (void)
{
  x.exponent = 1;
  if (foo () != 0)
    abort ();
  return 0;
}
#endif
// source: ffs-1.c
__volatile int a = 0;

extern void abort (void);
extern void exit (int);

int
main (void)
{
  if (__builtin_ffs (a) != 0)
    abort ();
  exit (0);
}
// source: ffs-2.c
struct
  {
    int input;
    int output;
  }
ffstesttab[] =
  {
#if __INT_MAX__ >= 2147483647
    /* at least 32-bit integers */
    { 0x80000000, 32 },
    { 0xa5a5a5a5, 1 },
    { 0x5a5a5a5a, 2 },
    { 0xcafe0000, 18 },
#endif
#if __INT_MAX__ >= 32767
    /* at least 16-bit integers */
    { 0x8000, 16 },
    { 0xa5a5, 1 },
    { 0x5a5a, 2 },
    { 0x0ca0, 6 },
#endif
#if __INT_MAX__ < 32767
#error integers are too small
#endif
  };

#define NFFSTESTS (sizeof (ffstesttab) / sizeof (ffstesttab[0]))

extern void abort (void);
extern void exit (int);

int
main (void)
{
  int i;

  for (i = 0; i < NFFSTESTS; i++)
    {
      if (__builtin_ffs (ffstesttab[i].input) != ffstesttab[i].output)
	abort ();
    }

  exit (0);
}
// source: float-floor.c

#if(__SIZEOF_DOUBLE__==8)
double d = 1024.0 - 1.0 / 32768.0;
#else
double d = 1024.0 - 1.0 / 16384.0;
#endif

extern double floor(double);
extern float floorf(float);
extern void abort();

int main() {

    double df = floor(d);
    float f1 = (float)floor(d);

    if ((int)df != 1023 || (int)f1 != 1023)
      abort ();

    return 0;
}
// source: floatunsisf-1.c
/* The fp-bit.c function __floatunsisf had a latent bug where guard bits
   could be lost leading to incorrect rounding.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */

extern void abort (void);
extern void exit (int);
#if __INT_MAX__ >= 0x7fffffff
volatile unsigned u = 0x80000081;
#else
volatile unsigned long u = 0x80000081;
#endif
volatile float f1, f2;
int
main (void)
{
  f1 = (float) u;
  f2 = (float) 0x80000081;
  if (f1 != f2)
    abort ();
  exit (0);
}
// source: fprintf-1.c
/* { dg-skip-if "requires io" { freestanding } }  */

#include <stdio.h>
#include <stdlib.h>

int
main (void)
{
#define test(ret, args...) \
  fprintf (stdout, args); 		\
  if (fprintf (stdout, args) != ret)	\
    abort ();
  test (5, "hello");
  test (6, "hello\n");
  test (1, "a");
  test (0, "");
  test (5, "%s", "hello");
  test (6, "%s", "hello\n");
  test (1, "%s", "a");
  test (0, "%s", "");
  test (1, "%c", 'x');
  test (7, "%s\n", "hello\n");
  test (2, "%d\n", 0);
  return 0;
}
// source: fprintf-2.c
/* Verify that calls to fprintf don't get eliminated even if their
   result on success can be computed at compile time (they can fail).
   The calls can still be transformed into those of other functions.
   { dg-skip-if "requires io" { freestanding } } */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main (void)
{
  char *tmpfname = tmpnam (0);
  FILE *f = fopen (tmpfname, "w");
  if (!f)
    {
      perror ("fopen for writing");
      return 1;
    }

  fprintf (f, "1");
  fprintf (f, "%c", '2');
  fprintf (f, "%c%c", '3', '4');
  fprintf (f, "%s", "5");
  fprintf (f, "%s%s", "6", "7");
  fprintf (f, "%i", 8);
  fprintf (f, "%.1s\n", "9x");
  fclose (f);

  f = fopen (tmpfname, "r");
  if (!f)
    {
      perror ("fopen for reading");
      remove (tmpfname);
      return 1;
    }

  char buf[12] = "";
  if (1 != fscanf (f, "%s", buf))
    {
      perror ("fscanf");
      fclose (f);
      remove (tmpfname);
      return 1;
    }

  fclose (f);
  remove (tmpfname);

  if (strcmp (buf, "123456789"))
    abort ();

  return 0;
}
// source: fprintf-chk-1.c
/* { dg-skip-if "requires io" { freestanding } }  */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

volatile int should_optimize;

int
__attribute__((noinline))
__fprintf_chk (FILE *f, int flag, const char *fmt, ...)
{
  va_list ap;
  int ret;
#ifdef __OPTIMIZE__
  if (should_optimize)
    abort ();
#endif
  should_optimize = 1;
  va_start (ap, fmt);
  ret = vfprintf (f, fmt, ap);
  va_end (ap);
  return ret;
}

int
main (void)
{
#define test(ret, opt, args...) \
  should_optimize = opt;			\
  __fprintf_chk (stdout, 1, args); 		\
  if (!should_optimize)				\
    abort ();					\
  should_optimize = 0;				\
  if (__fprintf_chk (stdout, 1, args) != ret)	\
    abort ();					\
  if (!should_optimize)				\
    abort ();
  test (5, 1, "hello");
  test (6, 1, "hello\n");
  test (1, 1, "a");
  test (0, 1, "");
  test (5, 1, "%s", "hello");
  test (6, 1, "%s", "hello\n");
  test (1, 1, "%s", "a");
  test (0, 1, "%s", "");
  test (1, 1, "%c", 'x');
  test (7, 0, "%s\n", "hello\n");
  test (2, 0, "%d\n", 0);
  return 0;
}
// source: frame-address.c
/* { dg-require-effective-target return_address } */
int check_fa_work (const char *, const char *) __attribute__((noinline));
int check_fa_mid (const char *) __attribute__((noinline));
int check_fa (char *) __attribute__((noinline));
int how_much (void) __attribute__((noinline));

int check_fa_work (const char *c, const char *f)
{
  const char d = 0;

  if (c >= &d)
    return c >= f && f >= &d;
  else
    return c <= f && f <= &d;
}

int check_fa_mid (const char *c)
{
  const char *f = __builtin_frame_address (0);

  /* Prevent a tail call to check_fa_work, eliding the current stack frame.  */
  return check_fa_work (c, f) != 0;
}

int check_fa (char *unused)
{
  const char c = 0;

  /* Prevent a tail call to check_fa_mid, eliding the current stack frame.  */
  return check_fa_mid (&c) != 0;
}

int how_much (void)
{
	return 8;
}

int main (void)
{
  char *unused = __builtin_alloca (how_much ());

  if (!check_fa(unused))
    abort();
  return 0;
}
// source: func-ptr-1.c
static double f (float a);
static double (*fp) (float a);

main ()
{
  fp = f;
  if (fp ((float) 1) != 1.0)
    abort ();
  exit (0);
}

static double
f (float a)
{
  return a;
}
// source: gofast.c
/* { dg-skip-if "requires io" { freestanding } }  */

/* Program to test gcc's usage of the gofast library.  */

/* The main guiding themes are to make it trivial to add test cases over time
   and to make it easy for a program to parse the output to see if the right
   libcalls are being made.  */

#include <stdio.h>

float fp_add (float a, float b) { return a + b; }
float fp_sub (float a, float b) { return a - b; }
float fp_mul (float a, float b) { return a * b; }
float fp_div (float a, float b) { return a / b; }
float fp_neg (float a) { return -a; }

double dp_add (double a, double b) { return a + b; }
double dp_sub (double a, double b) { return a - b; }
double dp_mul (double a, double b) { return a * b; }
double dp_div (double a, double b) { return a / b; }
double dp_neg (double a) { return -a; }

double fp_to_dp (float f) { return f; }
float dp_to_fp (double d) { return d; }

int eqsf2 (float a, float b) { return a == b; }
int nesf2 (float a, float b) { return a != b; }
int gtsf2 (float a, float b) { return a > b; }
int gesf2 (float a, float b) { return a >= b; }
int ltsf2 (float a, float b) { return a < b; }
int lesf2 (float a, float b) { return a <= b; }

int eqdf2 (double a, double b) { return a == b; }
int nedf2 (double a, double b) { return a != b; }
int gtdf2 (double a, double b) { return a > b; }
int gedf2 (double a, double b) { return a >= b; }
int ltdf2 (double a, double b) { return a < b; }
int ledf2 (double a, double b) { return a <= b; }

float floatsisf (int i) { return i; }
double floatsidf (int i) { return i; }
int fixsfsi (float f) { return f; }
int fixdfsi (double d) { return d; }
unsigned int fixunssfsi (float f) { return f; }
unsigned int fixunsdfsi (double d) { return d; }

int fail_count = 0;

int
fail (char *msg)
{
  fail_count++;
  fprintf (stderr, "Test failed: %s\n", msg);
}

int
main()
{
  if (fp_add (1, 1) != 2) fail ("fp_add 1+1");
  if (fp_sub (3, 2) != 1) fail ("fp_sub 3-2");
  if (fp_mul (2, 3) != 6) fail ("fp_mul 2*3");
  if (fp_div (3, 2) != 1.5) fail ("fp_div 3/2");
  if (fp_neg (1) != -1) fail ("fp_neg 1");

  if (dp_add (1, 1) != 2) fail ("dp_add 1+1");
  if (dp_sub (3, 2) != 1) fail ("dp_sub 3-2");
  if (dp_mul (2, 3) != 6) fail ("dp_mul 2*3");
  if (dp_div (3, 2) != 1.5) fail ("dp_div 3/2");
  if (dp_neg (1) != -1) fail ("dp_neg 1");

  if (fp_to_dp (1.5) != 1.5) fail ("fp_to_dp 1.5");
  if (dp_to_fp (1.5) != 1.5) fail ("dp_to_fp 1.5");

  if (floatsisf (1) != 1) fail ("floatsisf 1");
  if (floatsidf (1) != 1) fail ("floatsidf 1");
  if (fixsfsi (1.42) != 1) fail ("fixsfsi 1.42");
  if (fixunssfsi (1.42) != 1) fail ("fixunssfsi 1.42");
  if (fixdfsi (1.42) != 1) fail ("fixdfsi 1.42");
  if (fixunsdfsi (1.42) != 1) fail ("fixunsdfsi 1.42");

  if (eqsf2 (1, 1) == 0) fail ("eqsf2 1==1");
  if (eqsf2 (1, 2) != 0) fail ("eqsf2 1==2");
  if (nesf2 (1, 2) == 0) fail ("nesf2 1!=1");
  if (nesf2 (1, 1) != 0) fail ("nesf2 1!=1");
  if (gtsf2 (2, 1) == 0) fail ("gtsf2 2>1");
  if (gtsf2 (1, 1) != 0) fail ("gtsf2 1>1");
  if (gtsf2 (0, 1) != 0) fail ("gtsf2 0>1");
  if (gesf2 (2, 1) == 0) fail ("gesf2 2>=1");
  if (gesf2 (1, 1) == 0) fail ("gesf2 1>=1");
  if (gesf2 (0, 1) != 0) fail ("gesf2 0>=1");
  if (ltsf2 (1, 2) == 0) fail ("ltsf2 1<2");
  if (ltsf2 (1, 1) != 0) fail ("ltsf2 1<1");
  if (ltsf2 (1, 0) != 0) fail ("ltsf2 1<0");
  if (lesf2 (1, 2) == 0) fail ("lesf2 1<=2");
  if (lesf2 (1, 1) == 0) fail ("lesf2 1<=1");
  if (lesf2 (1, 0) != 0) fail ("lesf2 1<=0");

  if (fail_count != 0)
    abort ();
  exit (0);
}
// source: ifcvt-onecmpl-abs-1.c

extern void abort(void);

__attribute__ ((noinline))
int foo(int n)
{
  if (n < 0)
    n = ~n;

  return n;
}

int main(void)
{
  if (foo (-1) != 0)
    abort ();

  return 0;
}
// source: index-1.c
int a[] =
{
  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
  10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
  20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39
};

int
f (long n)
{
  return a[n - 100000];
}

main ()
{
  if (f (100030L) != 30)
    abort();
  exit (0);
}
// source: inst-check.c
#include <stdarg.h>

f(m)
{
  int i,s=0;
  for(i=0;i<m;i++)
    s+=i;
  return s;
}

main()
{
  exit (0);
}
// source: int-compare.c
#include <limits.h>

gt (a, b)
{
  return a > b;
}

ge (a, b)
{
  return a >= b;
}

lt (a, b)
{
  return a < b;
}

le (a, b)
{
  return a <= b;
}

void
true (c)
{
  if (!c)
    abort();
}

void
false (c)
{
  if (c)
    abort();
}

f ()
{
  true (gt (2, 1));
  false (gt (1, 2));

  true (gt (INT_MAX, 0));
  false (gt (0, INT_MAX));
  true (gt (INT_MAX, 1));
  false (gt (1, INT_MAX));

  false (gt (INT_MIN, 0));
  true (gt (0, INT_MIN));
  false (gt (INT_MIN, 1));
  true (gt (1, INT_MIN));

  true (gt (INT_MAX, INT_MIN));
  false (gt (INT_MIN, INT_MAX));

  true (ge (2, 1));
  false (ge (1, 2));

  true (ge (INT_MAX, 0));
  false (ge (0, INT_MAX));
  true (ge (INT_MAX, 1));
  false (ge (1, INT_MAX));

  false (ge (INT_MIN, 0));
  true (ge (0, INT_MIN));
  false (ge (INT_MIN, 1));
  true (ge (1, INT_MIN));

  true (ge (INT_MAX, INT_MIN));
  false (ge (INT_MIN, INT_MAX));

  false (lt (2, 1));
  true (lt (1, 2));

  false (lt (INT_MAX, 0));
  true (lt (0, INT_MAX));
  false (lt (INT_MAX, 1));
  true (lt (1, INT_MAX));

  true (lt (INT_MIN, 0));
  false (lt (0, INT_MIN));
  true (lt (INT_MIN, 1));
  false (lt (1, INT_MIN));

  false (lt (INT_MAX, INT_MIN));
  true (lt (INT_MIN, INT_MAX));

  false (le (2, 1));
  true (le (1, 2));

  false (le (INT_MAX, 0));
  true (le (0, INT_MAX));
  false (le (INT_MAX, 1));
  true (le (1, INT_MAX));

  true (le (INT_MIN, 0));
  false (le (0, INT_MIN));
  true (le (INT_MIN, 1));
  false (le (1, INT_MIN));

  false (le (INT_MAX, INT_MIN));
  true (le (INT_MIN, INT_MAX));
}

main ()
{
  f ();
  exit (0);
}
// source: ipa-sra-1.c
/* Trivially making sure IPA-SRA does not introduce segfaults where they should
   not be.  */

struct bovid
{
  float red;
  int green;
  void *blue;
};

static int
__attribute__((noinline))
ox (int fail, struct bovid *cow)
{
  int r;
  if (fail)
    r = cow->red;
  else
    r = 0;
  return r;
}

int main (int argc, char *argv[])
{
  int r;

  r = ox ((argc > 2000), (void *) 0);
  return r;
}
// source: ipa-sra-2.c
/* { dg-require-effective-target int32plus } */
struct big
{
  int data[1000000];
};

struct small
{
  int data[10];
};

union both
{
  struct big big;
  struct small small;
};

extern void *calloc (__SIZE_TYPE__, __SIZE_TYPE__);
extern void free (void *);

static int __attribute__((noinline))
foo (int fail, union both *agg)
{
  int r;
  if (fail)
    r = agg->big.data[999999];
  else
    r = agg->small.data[0];
  return r;
}

int main (int argc, char *argv[])
{
  union both *agg = calloc (1, sizeof (struct small));
  int r;

  r = foo ((argc > 2000), agg);

  free (agg);
  return r;
}
// source: longlong.c
/* Source: PR 321 modified for test suite by Neil Booth 14 Jan 2001.  */

typedef unsigned long long uint64;
unsigned long pars;

uint64 b[32];
uint64 *r = b;

void alpha_ep_extbl_i_eq_0()
{
  unsigned int rb, ra, rc;

  rb  = (((unsigned long)(pars) >> 27)) & 0x1fUL;
  ra  = (((unsigned int)(pars) >> 5)) & 0x1fUL;
  rc  = (((unsigned int)(pars) >> 0)) & 0x1fUL;
  {
    uint64 temp = ((r[ra] >> ((r[rb] & 0x7) << 3)) & 0x00000000000000FFLL);
    if (rc != 31)
      r[rc] = temp;
  }
}

int
main(void)
{
  if (sizeof (uint64) == 8)
    {
      b[17] = 0x0000000000303882ULL; /* rb */
      b[2] = 0x534f4f4c494d000aULL; /* ra & rc */

      pars = 0x88000042;	/* 17, 2, 2 coded */
      alpha_ep_extbl_i_eq_0();

      if (b[2] != 0x4d)
	abort ();
    }

  exit (0);
}
// source: loop-1.c
main ()
{
  int i, j, k[3];

  j = 0;
  for (i=0; i < 3; i++)
    {
      k[i] = j++;
    }

  for (i=2; i >= 0; i--)
    {
      if (k[i] != i)
	abort ();
    }

  exit (0);
}
// source: loop-10.c
/* Reduced from PR optimization/5076, PR optimization/2847 */

static int count = 0;

static void
inc (void)
{
  count++;
}

int
main (void)
{
  int iNbr = 1;
  int test = 0;
  while (test == 0)
    {
      inc ();
      if (iNbr == 0)
        break;
      else
        {
          inc ();
          iNbr--;
        }
      test = 1;
    }
  if (count != 2)
    abort ();
  return 0;
}
// source: loop-11.c
static int a[199];

static void
foo ()
{
  int i;
  for (i = 198; i >= 0; i--)
    a[i] = i;
}

int
main ()
{
  int i;
  foo ();
  for (i = 0; i < 199; i++)
    if (a[i] != i)
      abort ();
  return 0;
}
// source: loop-12.c
/* Checks that pure functions are not treated as const.  */

char *p;

static int __attribute__ ((pure))
is_end_of_statement (void)
{
  return *p == '\n' || *p == ';' || *p == '!';
}

void foo (void)
{
  /* The is_end_of_statement call was moved out of the loop at one stage,
     resulting in an endless loop.  */
  while (!is_end_of_statement ())
    p++;
}

int
main (void)
{
  p = "abc\n";
  foo ();
  return 0;
}
// source: loop-13.c
/* PR opt/7130 */
#define TYPE long

void
scale (TYPE *alpha, TYPE *x, int n)
{
  int i, ix;

  if (*alpha != 1)
    for (i = 0, ix = 0; i < n; i++, ix += 2)
      {
	TYPE tmpr, tmpi;
	tmpr = *alpha * x[ix];
	tmpi = *alpha * x[ix + 1];
	x[ix] = tmpr;
	x[ix + 1] = tmpi;
      }
}

int
main (void)
{
  int i;
  TYPE x[10];
  TYPE alpha = 2;

  for (i = 0; i < 10; i++)
    x[i] = i;

  scale (&alpha, x, 5);

  if (x[9] != 18)
    abort ();

  return 0;
}
// source: loop-14.c
int a3[3];

void f(int *a)
{
  int i;

  for (i=3; --i;)
    a[i] = 42 / i;
}

int
main ()
{
  f(a3);

  if (a3[1] != 42 || a3[2] != 21)
    abort ();

  exit (0);
}
// source: loop-15.c
/* Bombed with a segfault on powerpc-linux.  doloop.c generated wrong
   loop count.  */
void
foo (unsigned long *start, unsigned long *end)
{
  unsigned long *temp = end - 1;

  while (end > start)
    *end-- = *temp--;
}

int
main (void)
{
  unsigned long a[5];
  int start, end, k;

  for (start = 0; start < 5; start++)
    for (end = 0; end < 5; end++)
      {
	for (k = 0; k < 5; k++)
	  a[k] = k;

	foo (a + start, a + end);

	for (k = 0; k <= start; k++)
	  if (a[k] != k)
	    abort ();

	for (k = start + 1; k <= end; k++)
	  if (a[k] != k - 1)
	    abort ();

	for (k = end + 1; k < 5; k++)
	  if (a[k] != k)
	    abort ();
      }

  return 0;
}
// source: loop-2.c
int a[2];

f (b)
{
  unsigned int i;
  for (i = 0; i < b; i++)
    a[i] = i - 2;
}

main ()
{
  a[0] = a[1] = 0;
  f (2);
  if (a[0] != -2 || a[1] != -1)
    abort ();
  exit (0);
}
// source: loop-2b.c
#include <limits.h>

int a[2];

f (int i)
{
  for (; i < INT_MAX; i++)
    {
      a[i] = -2;
      if (&a[i] == &a[1])
	break;
    }
}

main ()
{
  a[0] = a[1] = 0;
  f (0);
  if (a[0] != -2 || a[1] != -2)
    abort ();
  exit (0);
}
// source: loop-2c.c
/* { dg-options "-fgnu89-inline -Wno-pointer-to-int-cast" } */

extern void abort (void);
extern void exit (int);

int a[2];

__inline__ void f (int b, int o)
{
  unsigned int i;
  int *p;
  for (p = &a[b], i = b; --i < ~0; )
    *--p = i * 3 + o;
}

void
g(int b)
{
  f (b, (int)a);
}

int
main ()
{
  a[0] = a[1] = 0;
  g (2);
  if (a[0] != (int)a || a[1] != (int)a + 3)
    abort ();
  exit (0);
}
// source: loop-2d.c
int a[2];

f (b)
{
  unsigned int i;
  int *p;
  for (p = &a[b], i = b; --i < ~0; )
    *--p = i * 3 + (int)a;
}

main ()
{
  a[0] = a[1] = 0;
  f (2);
  if (a[0] != (int)a || a[1] != (int)a + 3)
    abort ();
  exit (0);
}
// source: loop-2e.c
void f (int *p, int **q)
{
  int i;
  for (i = 0; i < 40; i++)
    {
      *q++ = &p[i];
    }
}

int main ()
{
  void *p;
  int *q[40];
  __SIZE_TYPE__ start;

  /* Find the signed middle of the address space.  */
  if (sizeof(start) == sizeof(int))
    start = (__SIZE_TYPE__) __INT_MAX__;
  else if (sizeof(start) == sizeof(long))
    start = (__SIZE_TYPE__) __LONG_MAX__;
  else if (sizeof(start) == sizeof(long long))
    start = (__SIZE_TYPE__) __LONG_LONG_MAX__;
  else
    return 0;

  /* Arbitrarily align the pointer.  */
  start &= -32;

  /* Pretend that's good enough to start address arithmetic.  */
  p = (void *)start;

  /* Verify that GIV replacement computes the correct results.  */
  q[39] = 0;
  f (p, q);
  if (q[39] != (int *)p + 39)
    abort ();

  return 0;
}
// source: loop-2f.c
/* { dg-require-effective-target mmap } */
/* { dg-skip-if "the executable is at the same position the test tries to remap" { m68k-*-linux* } } */

#include <limits.h>

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#ifndef MAP_ANON
#ifdef MAP_ANONYMOUS
#define MAP_ANON MAP_ANONYMOUS
#else
#define MAP_ANON MAP_FILE
#endif
#endif
#ifndef MAP_FILE
#define MAP_FILE 0
#endif
#ifndef MAP_FIXED
#define MAP_FIXED 0
#endif

#define MAP_START (void *)0x7fff8000
#define MAP_LEN 0x10000

#define OFFSET (MAP_LEN/2 - 2 * sizeof (char));

f (int s, char *p)
{
  int i;
  for (i = s; i >= 0 && &p[i] < &p[40]; i++)
    {
      p[i] = -2;
    }
}

main ()
{
#ifdef MAP_ANON
  char *p;
  int dev_zero;

  dev_zero = open ("/dev/zero", O_RDONLY);
  /* -1 is OK when we have MAP_ANON; else mmap will flag an error.  */
  if (INT_MAX != 0x7fffffffL || sizeof (char *) != sizeof (int))
    exit (0);
  p = mmap (MAP_START, MAP_LEN, PROT_READ|PROT_WRITE,
	    MAP_ANON|MAP_FIXED|MAP_PRIVATE, dev_zero, 0);
  if (p != (char *)-1)
    {
      p += OFFSET;
      p[39] = 0;
      f (0, p);
      if (p[39] != (char)-2)
	abort ();
      p[39] = 0;
      f (-1, p);
      if (p[39] != 0)
	abort ();
    }
#endif
  exit (0);
}
// source: loop-2g.c
/* { dg-require-effective-target mmap } */
/* { dg-skip-if "the executable is at the same position the test tries to remap" { m68k-*-linux* } } */

#include <limits.h>

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#ifndef MAP_ANON
#ifdef MAP_ANONYMOUS
#define MAP_ANON MAP_ANONYMOUS
#else
#define MAP_ANON MAP_FILE
#endif
#endif
#ifndef MAP_FILE
#define MAP_FILE 0
#endif
#ifndef MAP_FIXED
#define MAP_FIXED 0
#endif

#define MAP_START (void *)0x7fff8000
#define MAP_LEN 0x10000

#define OFFSET (MAP_LEN/2 - 2 * sizeof (char));

f (int s, char *p)
{
  int i;
  for (i = s; &p[i] < &p[40] && i >= 0; i++)
    {
      p[i] = -2;
    }
}

main ()
{
#ifdef MAP_ANON
  char *p;
  int dev_zero;

  dev_zero = open ("/dev/zero", O_RDONLY);
  /* -1 is OK when we have MAP_ANON; else mmap will flag an error.  */
  if (INT_MAX != 0x7fffffffL || sizeof (char *) != sizeof (int))
    exit (0);
  p = mmap (MAP_START, MAP_LEN, PROT_READ|PROT_WRITE,
	    MAP_ANON|MAP_FIXED|MAP_PRIVATE, dev_zero, 0);
  if (p != (char *)-1)
    {
      p += OFFSET;
      p[39] = 0;
      f (0, p);
      if (p[39] != (char)-2)
	abort ();
      p[39] = 0;
      f (-1, p);
      if (p[39] != 0)
	abort ();
    }
#endif
  exit (0);
}
// source: loop-3.c
#include <limits.h>

int n = 0;

g (i)
{
  n++;
}

f (m)
{
  int i;
  i = m;
  do
    {
      g (i * INT_MAX / 2);
    }
  while (--i > 0);
}

main ()
{
  f (4);
  if (n != 4)
    abort ();
  exit (0);
}
// source: loop-3b.c
#include <limits.h>

int n = 0;

g (i)
{
  n++;
}

f (m)
{
  int i;
  i = m;
  do
    {
      g (i * 4);
      i -= INT_MAX / 8;
    }
  while (i > 0);
}

main ()
{
  f (INT_MAX/8*4);
  if (n != 4)
    abort ();
  exit (0);
}
// source: loop-3c.c
#include <limits.h>

void * a[255];

f (m)
{
  int i;
  int sh = 0x100;
  i = m;
  do
    {
      a[sh >>= 1] = ((unsigned)i << 3)  + (char*)a;
      i += 4;
    }
  while (i < INT_MAX/2 + 1 + 4 * 4);
}

main ()
{
  a[0x10] = 0;
  a[0x08] = 0;
  f (INT_MAX/2 + INT_MAX/4 + 2);
  if (a[0x10] || a[0x08])
    abort ();
  a[0x10] = 0;
  a[0x08] = 0;
  f (INT_MAX/2 + 1);
  if (! a[0x10] || a[0x08])
    abort ();
  exit (0);
}
// source: loop-4.c
int
f()
{
  int j = 1;
  long i;
  for (i = -0x70000000L; i < 0x60000000L; i += 0x10000000L) j <<= 1;
  return j;
}

int
main ()
{
  if (f () != 8192)
    abort ();
  exit (0);
}
// source: loop-4b.c
int
f()
{
  int j = 1;
  long i;
  i = 0x60000000L;
  do
    {
      j <<= 1;
      i += 0x10000000L;
    } while (i < -0x60000000L);
  return j;
}

int
main ()
{
  if (f () != 2)
    abort ();
  exit (0);
}
// source: loop-5.c
static int ap(int i);
static void testit(void){
  int ir[4] = {0,1,2,3};
  int ix,n,m;
  n=1; m=3;
  for (ix=1;ix<=4;ix++) {
    if (n == 1) m = 4;
    else        m = n-1;
    ap(ir[n-1]);
    n = m;
  }
}

static int t = 0;
static int a[4];

static int ap(int i){
  if (t > 3)
    abort();
  a[t++] = i;
  return 1;
}

int main(void)
{
  testit();
  if (a[0] != 0)
    abort();
  if (a[1] != 3)
    abort();
  if (a[2] != 2)
    abort();
  if (a[3] != 1)
    abort();
  exit(0);
}
// source: loop-6.c
main()
{
  char c;
  char d;
  int nbits;
  c = -1;
  for (nbits = 1 ; nbits < 100; nbits++) {
    d = (1 << nbits) - 1;
    if (d == c)
      break;
  }
  if (nbits == 100)
    abort();
  exit(0);
}
// source: loop-7.c
void foo (unsigned int n)
{
  int i, j = -1;

  for (i = 0; i < 10 && j < 0; i++)
    {
      if ((1UL << i) == n)
	j = i;
    }

  if (j < 0)
    abort ();
}

main()
{
  foo (64);
  exit (0);
}
// source: loop-8.c
double a[3] = { 0.0, 1.0, 2.0 };

void bar (int x, double *y)
{
  if (x || *y != 1.0)
    abort ();
}

int main ()
{
  double c;
  int d;
  for (d = 0; d < 3; d++)
  {
    c = a[d];
    if (c > 0.0) goto e;
  }
  bar(1, &c);
  exit (1);
e:
  bar(0, &c);
  exit (0);
}
// source: loop-9.c
/* Source: Neil Booth, from PR # 115.  */

int false()
{
  return 0;
}

extern void abort (void);

int main (int argc,char *argv[])
{
  int count = 0;

  while (false() || count < -123)
    ++count;

  if (count)
    abort ();

  return 0;
}
// source: loop-ivopts-1.c
/* From PR 18977.  */
void foo(float * x);

int main()
{
  float x[4];
  foo (x);
  return 0;
}

void foo (float *x)
{
    int i,j,k;
    float temp;
    static float t16[16]={1.,2.,3.,4.,5.,6.,7.,8.,9.,
			  10.,11.,12.,13.,14.,15.,16.};
    static float tmp[4]={0.,0.,0.,0.};

    for (i=0; i<4; i++) {
	k = 3 - i;
	temp = t16[5*k];
	for(j=k+1; j<4; j++) {
	    tmp[k] = t16[k+  j*4] * temp;
	}
    }
    x[0] = tmp[0];
    x[1] = tmp[1];
    x[2] = tmp[2];
    x[3] = tmp[3];
}
// source: loop-ivopts-2.c
/* PR rtl-optimization/20290  */

/* We used to mis-optimize the second loop in main on at least ppc and
   arm, because tree loop would change the loop to something like:

  ivtmp.65 = &l[i];
  ivtmp.16 = 113;
  goto <bb 4> (<L4>);

<L3>:;
  *(ivtmp.65 + 4294967292B) = 9;
  i = i + 1;

<L4>:;
  ivtmp.16 = ivtmp.16 - 1;
  ivtmp.65 = ivtmp.65 + 4B;
  if (ivtmp.16 != 0) goto <L3>;

  We used to consider the increment of i as executed in every
  iteration, so we'd miscompute the final value.  */

extern void abort (void);

void
check (unsigned int *l)
{
  int i;
  for (i = 0; i < 288; i++)
    if (l[i] != 7 + (i < 256 || i >= 280) + (i >= 144 && i < 256))
      abort ();
}

int
main (void)
{
  int i;
  unsigned int l[288];

  for (i = 0; i < 144; i++)
    l[i] = 8;
  for (; i < 256; i++)
    l[i] = 9;
  for (; i < 280; i++)
    l[i] = 7;
  for (; i < 288; i++)
    l[i] = 8;
  check (l);
  return 0;
}
// source: lshrdi-1.c
#include <limits.h>

extern void abort(void);
extern void exit(int);

#if __LONG_LONG_MAX__ == 9223372036854775807LL
#define BITS 64

static unsigned long long const zext[64] = {
  0x87654321fedcba90ULL,
  0x43b2a190ff6e5d48ULL,
  0x21d950c87fb72ea4ULL,
  0x10eca8643fdb9752ULL,
  0x87654321fedcba9ULL,
  0x43b2a190ff6e5d4ULL,
  0x21d950c87fb72eaULL,
  0x10eca8643fdb975ULL,
  0x87654321fedcbaULL,
  0x43b2a190ff6e5dULL,
  0x21d950c87fb72eULL,
  0x10eca8643fdb97ULL,
  0x87654321fedcbULL,
  0x43b2a190ff6e5ULL,
  0x21d950c87fb72ULL,
  0x10eca8643fdb9ULL,
  0x87654321fedcULL,
  0x43b2a190ff6eULL,
  0x21d950c87fb7ULL,
  0x10eca8643fdbULL,
  0x87654321fedULL,
  0x43b2a190ff6ULL,
  0x21d950c87fbULL,
  0x10eca8643fdULL,
  0x87654321feULL,
  0x43b2a190ffULL,
  0x21d950c87fULL,
  0x10eca8643fULL,
  0x87654321fULL,
  0x43b2a190fULL,
  0x21d950c87ULL,
  0x10eca8643ULL,
  0x87654321ULL,
  0x43b2a190ULL,
  0x21d950c8ULL,
  0x10eca864ULL,
  0x8765432ULL,
  0x43b2a19ULL,
  0x21d950cULL,
  0x10eca86ULL,
  0x876543ULL,
  0x43b2a1ULL,
  0x21d950ULL,
  0x10eca8ULL,
  0x87654ULL,
  0x43b2aULL,
  0x21d95ULL,
  0x10ecaULL,
  0x8765ULL,
  0x43b2ULL,
  0x21d9ULL,
  0x10ecULL,
  0x876ULL,
  0x43bULL,
  0x21dULL,
  0x10eULL,
  0x87ULL,
  0x43ULL,
  0x21ULL,
  0x10ULL,
  0x8ULL,
  0x4ULL,
  0x2ULL,
  0x1ULL
};

#elif __LONG_LONG_MAX__ == 2147483647LL
#define BITS 32

static unsigned long long const zext[32] = {
  0x87654321ULL,
  0x43b2a190ULL,
  0x21d950c8ULL,
  0x10eca864ULL,
  0x8765432ULL,
  0x43b2a19ULL,
  0x21d950cULL,
  0x10eca86ULL,
  0x876543ULL,
  0x43b2a1ULL,
  0x21d950ULL,
  0x10eca8ULL,
  0x87654ULL,
  0x43b2aULL,
  0x21d95ULL,
  0x10ecaULL,
  0x8765ULL,
  0x43b2ULL,
  0x21d9ULL,
  0x10ecULL,
  0x876ULL,
  0x43bULL,
  0x21dULL,
  0x10eULL,
  0x87ULL,
  0x43ULL,
  0x21ULL,
  0x10ULL,
  0x8ULL,
  0x4ULL,
  0x2ULL,
  0x1ULL,
};

#else
#error "Update the test case."
#endif

static unsigned long long
variable_shift(unsigned long long x, int i)
{
  return x >> i;
}

static unsigned long long
constant_shift(unsigned long long x, int i)
{
  switch (i)
    {
    case 0: x = x >> 0; break;
    case 1: x = x >> 1; break;
    case 2: x = x >> 2; break;
    case 3: x = x >> 3; break;
    case 4: x = x >> 4; break;
    case 5: x = x >> 5; break;
    case 6: x = x >> 6; break;
    case 7: x = x >> 7; break;
    case 8: x = x >> 8; break;
    case 9: x = x >> 9; break;
    case 10: x = x >> 10; break;
    case 11: x = x >> 11; break;
    case 12: x = x >> 12; break;
    case 13: x = x >> 13; break;
    case 14: x = x >> 14; break;
    case 15: x = x >> 15; break;
    case 16: x = x >> 16; break;
    case 17: x = x >> 17; break;
    case 18: x = x >> 18; break;
    case 19: x = x >> 19; break;
    case 20: x = x >> 20; break;
    case 21: x = x >> 21; break;
    case 22: x = x >> 22; break;
    case 23: x = x >> 23; break;
    case 24: x = x >> 24; break;
    case 25: x = x >> 25; break;
    case 26: x = x >> 26; break;
    case 27: x = x >> 27; break;
    case 28: x = x >> 28; break;
    case 29: x = x >> 29; break;
    case 30: x = x >> 30; break;
    case 31: x = x >> 31; break;
#if BITS > 32
    case 32: x = x >> 32; break;
    case 33: x = x >> 33; break;
    case 34: x = x >> 34; break;
    case 35: x = x >> 35; break;
    case 36: x = x >> 36; break;
    case 37: x = x >> 37; break;
    case 38: x = x >> 38; break;
    case 39: x = x >> 39; break;
    case 40: x = x >> 40; break;
    case 41: x = x >> 41; break;
    case 42: x = x >> 42; break;
    case 43: x = x >> 43; break;
    case 44: x = x >> 44; break;
    case 45: x = x >> 45; break;
    case 46: x = x >> 46; break;
    case 47: x = x >> 47; break;
    case 48: x = x >> 48; break;
    case 49: x = x >> 49; break;
    case 50: x = x >> 50; break;
    case 51: x = x >> 51; break;
    case 52: x = x >> 52; break;
    case 53: x = x >> 53; break;
    case 54: x = x >> 54; break;
    case 55: x = x >> 55; break;
    case 56: x = x >> 56; break;
    case 57: x = x >> 57; break;
    case 58: x = x >> 58; break;
    case 59: x = x >> 59; break;
    case 60: x = x >> 60; break;
    case 61: x = x >> 61; break;
    case 62: x = x >> 62; break;
    case 63: x = x >> 63; break;
#endif

    default:
      abort ();
    }
  return x;
}

int
main()
{
  int i;

  for (i = 0; i < BITS; ++i)
    {
      unsigned long long y = variable_shift (zext[0], i);
      if (y != zext[i])
	abort ();
    }
  for (i = 0; i < BITS; ++i)
    {
      unsigned long long y = constant_shift (zext[0], i);
      if (y != zext[i])
	abort ();
    }

  exit (0);
}
// source: lto-tbaa-1.c
/* { dg-additional-options "-fno-early-inlining -fno-ipa-cp" }  */
struct a {
  float *b;
} *a;
struct b {
  int *b;
} b;
struct c {
  float *b;
} *c;
int d;
use_a (struct a *a)
{
}
set_b (int **a)
{
  *a=&d;
}
use_c (struct c *a)
{
}
__attribute__ ((noinline)) int **retme(int **val)
{
  return val;
}
int e;
struct b b= {&e};
struct b b2;
struct b b3;
int **ptr = &b2.b;
main ()
{
  a= (void *)0;
  b.b=&e;
  ptr =retme ( &b.b);
  set_b (ptr);
  b3=b;
  if (b3.b != &d)
  __builtin_abort ();
  c= (void *)0;
  return 0;
}
// source: mayalias-1.c
/* Tests that the may_alias attribute works as expected.
   Author: Osku Salerma <osku@iki.fi> Apr 2002.  */

extern void abort(void);
extern void exit(int);

typedef short __attribute__((__may_alias__)) short_a;

int
main (void)
{
  int a = 0x12345678;
  short_a *b = (short_a*) &a;

  b[1] = 0;

  if (a == 0x12345678)
    abort();

  exit(0);
}
// source: mayalias-2.c
typedef struct __attribute__((__may_alias__)) { short x; } test;

int f() {
  int a=10;
  test *p=(test *)&a;
  p->x = 1;
  return a;
}

int main() {
  if (f() == 10)
    __builtin_abort();
  return 0;
}
// source: mayalias-3.c
typedef struct __attribute__((__may_alias__)) { short x; } test;

test *p;

int g(int *a)
{
 p = (test*)a;
}

int f()
{
  int a;
  g(&a);
  a = 10;
  test s={1};
  *p=s;
  return a;
}

int main() {
  if (f() == 10)
    __builtin_abort();
  return 0;
}
// source: medce-1.c

extern void abort (void);
extern void link_error (void);

static int ok = 0;

void bar (void)
{
  ok = 1;
}

void foo(int x)
{
  switch (x)
  {
  case 0:
    if (0)
    {
      link_error();
  case 1:
      bar();
    }
  }
}

int main()
{
  foo (1);
  if (!ok)
    abort ();
  return 0;
}
// source: memchr-1.c
/* PR tree-optimization/86711 - wrong folding of memchr

   Verify that memchr() of arrays initialized with string literals
   where the nul doesn't fit in the array doesn't find the nul.  */
typedef __SIZE_TYPE__  size_t;
typedef __WCHAR_TYPE__ wchar_t;

extern void* memchr (const void*, int, size_t);

#define A(expr)							\
  ((expr)							\
   ? (void)0							\
   : (__builtin_printf ("assertion failed on line %i: %s\n",	\
			__LINE__, #expr),			\
      __builtin_abort ()))

static const char c = '1';
static const char s1[1] = "1";
static const char s4[4] = "1234";

static const char s4_2[2][4] = { "1234", "5678" };
static const char s5_3[3][5] = { "12345", "6789", "01234" };

volatile int v0 = 0;
volatile int v1 = 1;
volatile int v2 = 2;
volatile int v3 = 3;
volatile int v4 = 3;

void test_narrow (void)
{
  int i0 = 0;
  int i1 = i0 + 1;
  int i2 = i1 + 1;
  int i3 = i2 + 1;
  int i4 = i3 + 1;

  A (memchr ("" + 1, 0, 0) == 0);

  A (memchr (&c, 0, sizeof c) == 0);
  A (memchr (&c + 1, 0, sizeof c - 1) == 0);
  A (memchr (&c + i1, 0, sizeof c - i1) == 0);
  A (memchr (&c + v1, 0, sizeof c - v1) == 0);

  A (memchr (s1, 0, sizeof s1) == 0);
  A (memchr (s1 + 1, 0, sizeof s1 - 1) == 0);
  A (memchr (s1 + i1, 0, sizeof s1 - i1) == 0);
  A (memchr (s1 + v1, 0, sizeof s1 - v1) == 0);

  A (memchr (&s1, 0, sizeof s1) == 0);
  A (memchr (&s1 + 1, 0, sizeof s1 - 1) == 0);
  A (memchr (&s1 + i1, 0, sizeof s1 - i1) == 0);
  A (memchr (&s1 + v1, 0, sizeof s1 - v1) == 0);

  A (memchr (&s1[0], 0, sizeof s1) == 0);
  A (memchr (&s1[0] + 1, 0, sizeof s1 - 1) == 0);
  A (memchr (&s1[0] + i1, 0, sizeof s1 - i1) == 0);
  A (memchr (&s1[0] + v1, 0, sizeof s1 - v1) == 0);

  A (memchr (&s1[i0], 0, sizeof s1) == 0);
  A (memchr (&s1[i0] + 1, 0, sizeof s1 - 1) == 0);
  A (memchr (&s1[i0] + i1, 0, sizeof s1 - i1) == 0);
  A (memchr (&s1[i0] + v1, 0, sizeof s1 - v1) == 0);

  A (memchr (&s1[v0], 0, sizeof s1) == 0);
  A (memchr (&s1[v0] + 1, 0, sizeof s1 - 1) == 0);
  A (memchr (&s1[v0] + i1, 0, sizeof s1 - i1) == 0);
  A (memchr (&s1[v0] + v1, 0, sizeof s1 - v1) == 0);


  A (memchr (s4 + i0, 0, sizeof s4 - i0) == 0);
  A (memchr (s4 + i1, 0, sizeof s4 - i1) == 0);
  A (memchr (s4 + i2, 0, sizeof s4 - i2) == 0);
  A (memchr (s4 + i3, 0, sizeof s4 - i3) == 0);
  A (memchr (s4 + i4, 0, sizeof s4 - i4) == 0);

  A (memchr (s4 + v0, 0, sizeof s4 - v0) == 0);
  A (memchr (s4 + v1, 0, sizeof s4 - v1) == 0);
  A (memchr (s4 + v2, 0, sizeof s4 - v2) == 0);
  A (memchr (s4 + v3, 0, sizeof s4 - v3) == 0);
  A (memchr (s4 + v4, 0, sizeof s4 - v4) == 0);


  A (memchr (s4_2, 0, sizeof s4_2) == 0);

  A (memchr (s4_2[0], 0, sizeof s4_2[0]) == 0);
  A (memchr (s4_2[1], 0, sizeof s4_2[1]) == 0);

  A (memchr (s4_2[0] + 1, 0, sizeof s4_2[0] - 1) == 0);
  A (memchr (s4_2[1] + 2, 0, sizeof s4_2[1] - 2) == 0);
  A (memchr (s4_2[1] + 3, 0, sizeof s4_2[1] - 3) == 0);

  A (memchr (s4_2[v0], 0, sizeof s4_2[v0]) == 0);
  A (memchr (s4_2[v0] + 1, 0, sizeof s4_2[v0] - 1) == 0);


  /* The following calls must find the nul.  */
  A (memchr ("", 0, 1) != 0);
  A (memchr (s5_3, 0, sizeof s5_3) == &s5_3[1][4]);

  A (memchr (&s5_3[0][0] + i0, 0, sizeof s5_3 - i0) == &s5_3[1][4]);
  A (memchr (&s5_3[0][0] + i1, 0, sizeof s5_3 - i1) == &s5_3[1][4]);
  A (memchr (&s5_3[0][0] + i2, 0, sizeof s5_3 - i2) == &s5_3[1][4]);
  A (memchr (&s5_3[0][0] + i4, 0, sizeof s5_3 - i4) == &s5_3[1][4]);

  A (memchr (&s5_3[1][i0], 0, sizeof s5_3[1] - i0) == &s5_3[1][4]);
}

#if 4 == __WCHAR_WIDTH__

static const wchar_t wc = L'1';
static const wchar_t ws1[] = L"1";
static const wchar_t ws4[] = L"\x00123456\x12005678\x12340078\x12345600";

void test_wide (void)
{
  int i0 = 0;
  int i1 = i0 + 1;
  int i2 = i1 + 1;
  int i3 = i2 + 1;
  int i4 = i3 + 1;

  A (memchr (L"" + 1, 0, 0) == 0);
  A (memchr (&wc + 1, 0, 0) == 0);
  A (memchr (L"\x12345678", 0, sizeof (wchar_t)) == 0);

  const size_t nb = sizeof ws4;
  const size_t nwb = sizeof (wchar_t);

  const char *pws1 = (const char*)ws1;
  const char *pws4 = (const char*)ws4;

#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  A (memchr (ws1, 0, sizeof ws1) == pws1 + 1);

  A (memchr (&ws4[0], 0, nb) == pws4 + 3);
  A (memchr (&ws4[1], 0, nb - 1 * nwb) == pws4 + 1 * nwb + 2);
  A (memchr (&ws4[2], 0, nb - 2 * nwb) == pws4 + 2 * nwb + 1);
  A (memchr (&ws4[3], 0, nb - 3 * nwb) == pws4 + 3 * nwb + 0);
#else
  A (memchr (ws1, 0, sizeof ws1) == pws1 + 0);

  A (memchr (&ws4[0], 0, nb) == pws4 + 0);
  A (memchr (&ws4[1], 0, nb - 1 * nwb) == pws4 + 1 * nwb + 1);
  A (memchr (&ws4[2], 0, nb - 2 * nwb) == pws4 + 2 * nwb + 2);
  A (memchr (&ws4[3], 0, nb - 3 * nwb) == pws4 + 3 * nwb + 3);
#endif
}

#elif 2 == __WCHAR_WIDTH__

static const wchar_t wc = L'1';
static const wchar_t ws1[] = L"1";
static const wchar_t ws2[2] = L"\x1234\x5678";   /* no terminating nul */
static const wchar_t ws4[] = L"\x0012\x1200\x1234";

void test_wide (void)
{
  int i0 = 0;
  int i1 = i0 + 1;
  int i2 = i1 + 1;

  A (sizeof (wchar_t) == 2);

  A (memchr (L"" + 1, 0, 0) == 0);
  A (memchr (&wc + 1, 0, 0) == 0);
  A (memchr (L"\x1234", 0, sizeof (wchar_t)) == 0);

  A (memchr (L"" + i1, i0, i0) == 0);
  A (memchr (&wc + i1, i0, i0) == 0);
  A (memchr (L"\x1234", i0, sizeof (wchar_t)) == 0);

  A (memchr (ws2, 0, sizeof ws2) == 0);
  A (memchr (ws2, i0, sizeof ws2) == 0);

  const size_t nb = sizeof ws4;
  const size_t nwb = sizeof (wchar_t);

  const char *pws1 = (const char*)ws1;
  const char *pws4 = (const char*)ws4;

#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  A (memchr (ws1, i0, sizeof ws1) == pws1 + 1);

  A (memchr (&ws4[0], i0, nb) == pws4 + i1);
  A (memchr (&ws4[1], i0, nb - i1 * nwb) == pws4 + i1 * nwb);
  A (memchr (&ws4[2], i0, nb - i2 * nwb) == pws4 + i2 * nwb + i2);
#else
  A (memchr (ws1, i0, sizeof ws1) == pws1 + 0);

  A (memchr (&ws4[0], i0, nb) == pws4 + 0);
  A (memchr (&ws4[1], i0, nb - i1 * nwb) == pws4 + i1 * nwb + i1);
  A (memchr (&ws4[2], i0, nb - i2 * nwb) == pws4 + i2 * nwb + i2);
#endif
}

#else

void test_wide (void) { }

#endif

int main ()
{
  test_narrow ();
  test_wide ();
}
// source: memcpy-1.c
/* { dg-add-options stack_size } */

#include <string.h>

#if defined (STACK_SIZE)
#define MEMCPY_SIZE (STACK_SIZE / 3)
#else
#define MEMCPY_SIZE (1 << 17)
#endif


void *copy (void *o, const void *i, unsigned l)
{
  return memcpy (o, i, l);
}

main ()
{
  unsigned i;
  unsigned char src[MEMCPY_SIZE];
  unsigned char dst[MEMCPY_SIZE];

  for (i = 0; i < MEMCPY_SIZE; i++)
    src[i] = (unsigned char) i,  dst[i] = 0;

  (void) memcpy (dst, src, MEMCPY_SIZE / 128);

  for (i = 0; i < MEMCPY_SIZE / 128; i++)
    if (dst[i] != (unsigned char) i)
      abort ();

  (void) memset (dst, 1, MEMCPY_SIZE / 128);

  for (i = 0; i < MEMCPY_SIZE / 128; i++)
    if (dst[i] != 1)
      abort ();

  (void) memcpy (dst, src, MEMCPY_SIZE);

  for (i = 0; i < MEMCPY_SIZE; i++)
    if (dst[i] != (unsigned char) i)
      abort ();

  (void) memset (dst, 0, MEMCPY_SIZE);

  for (i = 0; i < MEMCPY_SIZE; i++)
    if (dst[i] != 0)
      abort ();

  (void) copy (dst, src, MEMCPY_SIZE / 128);

  for (i = 0; i < MEMCPY_SIZE / 128; i++)
    if (dst[i] != (unsigned char) i)
      abort ();

  (void) memset (dst, 0, MEMCPY_SIZE);

  (void) copy (dst, src, MEMCPY_SIZE);

  for (i = 0; i < MEMCPY_SIZE; i++)
    if (dst[i] != (unsigned char) i)
      abort ();

  exit (0);
}
// source: memcpy-2.c
/* Copyright (C) 2002  Free Software Foundation.

   Test memcpy with various combinations of pointer alignments and lengths to
   make sure any optimizations in the library are correct.

   Written by Michael Meissner, March 9, 2002.  */

#include <string.h>

#ifndef MAX_OFFSET
#define MAX_OFFSET (sizeof (long long))
#endif

#ifndef MAX_COPY
#define MAX_COPY (10 * sizeof (long long))
#endif

#ifndef MAX_EXTRA
#define MAX_EXTRA (sizeof (long long))
#endif

#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + MAX_EXTRA)


/* Use a sequence length that is not divisible by two, to make it more
   likely to detect when words are mixed up.  */
#define SEQUENCE_LENGTH 31

static union {
  char buf[MAX_LENGTH];
  long long align_int;
  long double align_fp;
} u1, u2;

main ()
{
  int off1, off2, len, i;
  char *p, *q, c;

  for (off1 = 0; off1 < MAX_OFFSET; off1++)
    for (off2 = 0; off2 < MAX_OFFSET; off2++)
      for (len = 1; len < MAX_COPY; len++)
	{
	  for (i = 0, c = 'A'; i < MAX_LENGTH; i++, c++)
	    {
	      u1.buf[i] = 'a';
	      if (c >= 'A' + SEQUENCE_LENGTH)
		c = 'A';
	      u2.buf[i] = c;
	    }

	  p = memcpy (u1.buf + off1, u2.buf + off2, len);
	  if (p != u1.buf + off1)
	    abort ();

	  q = u1.buf;
	  for (i = 0; i < off1; i++, q++)
	    if (*q != 'a')
	      abort ();

	  for (i = 0, c = 'A' + off2; i < len; i++, q++, c++)
	    {
	      if (c >= 'A' + SEQUENCE_LENGTH)
		c = 'A';
	      if (*q != c)
		abort ();
	    }

	  for (i = 0; i < MAX_EXTRA; i++, q++)
	    if (*q != 'a')
	      abort ();
	}

  exit (0);
}
// source: memcpy-bi.c
/* Test builtin-memcpy (which may emit different code for different N).  */
#include <string.h>

#define TESTSIZE 80

char src[TESTSIZE] __attribute__ ((aligned));
char dst[TESTSIZE] __attribute__ ((aligned));

void
check (char *test, char *match, int n)
{
  if (memcmp (test, match, n))
    abort ();
}

#define TN(n) \
{ memset (dst, 0, n); memcpy (dst, src, n); check (dst, src, n); }
#define T(n) \
TN (n) \
TN ((n) + 1) \
TN ((n) + 2) \
TN ((n) + 3)

main ()
{
  int i,j;

  for (i = 0; i < sizeof (src); ++i)
      src[i] = 'a' + i % 26;

  T (0);
  T (4);
  T (8);
  T (12);
  T (16);
  T (20);
  T (24);
  T (28);
  T (32);
  T (36);
  T (40);
  T (44);
  T (48);
  T (52);
  T (56);
  T (60);
  T (64);
  T (68);
  T (72);
  T (76);

  return 0;
}
// source: memset-1.c
/* Copyright (C) 2002  Free Software Foundation.

   Test memset with various combinations of pointer alignments and lengths to
   make sure any optimizations in the library are correct.

   Written by Michael Meissner, March 9, 2002.  */

#include <string.h>

#ifndef MAX_OFFSET
#define MAX_OFFSET (sizeof (long long))
#endif

#ifndef MAX_COPY
#define MAX_COPY (10 * sizeof (long long))
#endif

#ifndef MAX_EXTRA
#define MAX_EXTRA (sizeof (long long))
#endif

#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + MAX_EXTRA)

static union {
  char buf[MAX_LENGTH];
  long long align_int;
  long double align_fp;
} u;

char A = 'A';

main ()
{
  int off, len, i;
  char *p, *q;

  for (off = 0; off < MAX_OFFSET; off++)
    for (len = 1; len < MAX_COPY; len++)
      {
	for (i = 0; i < MAX_LENGTH; i++)
	  u.buf[i] = 'a';

	p = memset (u.buf + off, '\0', len);
	if (p != u.buf + off)
	  abort ();

	q = u.buf;
	for (i = 0; i < off; i++, q++)
	  if (*q != 'a')
	    abort ();

	for (i = 0; i < len; i++, q++)
	  if (*q != '\0')
	    abort ();

	for (i = 0; i < MAX_EXTRA; i++, q++)
	  if (*q != 'a')
	    abort ();

	p = memset (u.buf + off, A, len);
	if (p != u.buf + off)
	  abort ();

	q = u.buf;
	for (i = 0; i < off; i++, q++)
	  if (*q != 'a')
	    abort ();

	for (i = 0; i < len; i++, q++)
	  if (*q != 'A')
	    abort ();

	for (i = 0; i < MAX_EXTRA; i++, q++)
	  if (*q != 'a')
	    abort ();

	p = memset (u.buf + off, 'B', len);
	if (p != u.buf + off)
	  abort ();

	q = u.buf;
	for (i = 0; i < off; i++, q++)
	  if (*q != 'a')
	    abort ();

	for (i = 0; i < len; i++, q++)
	  if (*q != 'B')
	    abort ();

	for (i = 0; i < MAX_EXTRA; i++, q++)
	  if (*q != 'a')
	    abort ();
      }

  exit (0);
}
// source: memset-2.c
/* Copyright (C) 2002  Free Software Foundation.

   Test memset with various combinations of pointer alignments and constant
   lengths to make sure any optimizations in the compiler are correct.

   Written by Roger Sayle, April 22, 2002.  */

#ifndef MAX_OFFSET
#define MAX_OFFSET (sizeof (long long))
#endif

#ifndef MAX_COPY
#define MAX_COPY 15
#endif

#ifndef MAX_EXTRA
#define MAX_EXTRA (sizeof (long long))
#endif

#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + MAX_EXTRA)

static union {
  char buf[MAX_LENGTH];
  long long align_int;
  long double align_fp;
} u;

char A = 'A';

void reset ()
{
  int i;

  for (i = 0; i < MAX_LENGTH; i++)
    u.buf[i] = 'a';
}

void check (int off, int len, int ch)
{
  char *q;
  int i;

  q = u.buf;
  for (i = 0; i < off; i++, q++)
    if (*q != 'a')
      abort ();

  for (i = 0; i < len; i++, q++)
    if (*q != ch)
      abort ();

  for (i = 0; i < MAX_EXTRA; i++, q++)
    if (*q != 'a')
      abort ();
}

int main ()
{
  int off;
  char *p;

  /* len == 1 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 1);
      if (p != u.buf + off) abort ();
      check (off, 1, '\0');

      p = memset (u.buf + off, A, 1);
      if (p != u.buf + off) abort ();
      check (off, 1, 'A');

      p = memset (u.buf + off, 'B', 1);
      if (p != u.buf + off) abort ();
      check (off, 1, 'B');
    }

  /* len == 2 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 2);
      if (p != u.buf + off) abort ();
      check (off, 2, '\0');

      p = memset (u.buf + off, A, 2);
      if (p != u.buf + off) abort ();
      check (off, 2, 'A');

      p = memset (u.buf + off, 'B', 2);
      if (p != u.buf + off) abort ();
      check (off, 2, 'B');
    }

  /* len == 3 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 3);
      if (p != u.buf + off) abort ();
      check (off, 3, '\0');

      p = memset (u.buf + off, A, 3);
      if (p != u.buf + off) abort ();
      check (off, 3, 'A');

      p = memset (u.buf + off, 'B', 3);
      if (p != u.buf + off) abort ();
      check (off, 3, 'B');
    }

  /* len == 4 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 4);
      if (p != u.buf + off) abort ();
      check (off, 4, '\0');

      p = memset (u.buf + off, A, 4);
      if (p != u.buf + off) abort ();
      check (off, 4, 'A');

      p = memset (u.buf + off, 'B', 4);
      if (p != u.buf + off) abort ();
      check (off, 4, 'B');
    }

  /* len == 5 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 5);
      if (p != u.buf + off) abort ();
      check (off, 5, '\0');

      p = memset (u.buf + off, A, 5);
      if (p != u.buf + off) abort ();
      check (off, 5, 'A');

      p = memset (u.buf + off, 'B', 5);
      if (p != u.buf + off) abort ();
      check (off, 5, 'B');
    }

  /* len == 6 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 6);
      if (p != u.buf + off) abort ();
      check (off, 6, '\0');

      p = memset (u.buf + off, A, 6);
      if (p != u.buf + off) abort ();
      check (off, 6, 'A');

      p = memset (u.buf + off, 'B', 6);
      if (p != u.buf + off) abort ();
      check (off, 6, 'B');
    }

  /* len == 7 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 7);
      if (p != u.buf + off) abort ();
      check (off, 7, '\0');

      p = memset (u.buf + off, A, 7);
      if (p != u.buf + off) abort ();
      check (off, 7, 'A');

      p = memset (u.buf + off, 'B', 7);
      if (p != u.buf + off) abort ();
      check (off, 7, 'B');
    }

  /* len == 8 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 8);
      if (p != u.buf + off) abort ();
      check (off, 8, '\0');

      p = memset (u.buf + off, A, 8);
      if (p != u.buf + off) abort ();
      check (off, 8, 'A');

      p = memset (u.buf + off, 'B', 8);
      if (p != u.buf + off) abort ();
      check (off, 8, 'B');
    }

  /* len == 9 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 9);
      if (p != u.buf + off) abort ();
      check (off, 9, '\0');

      p = memset (u.buf + off, A, 9);
      if (p != u.buf + off) abort ();
      check (off, 9, 'A');

      p = memset (u.buf + off, 'B', 9);
      if (p != u.buf + off) abort ();
      check (off, 9, 'B');
    }

  /* len == 10 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 10);
      if (p != u.buf + off) abort ();
      check (off, 10, '\0');

      p = memset (u.buf + off, A, 10);
      if (p != u.buf + off) abort ();
      check (off, 10, 'A');

      p = memset (u.buf + off, 'B', 10);
      if (p != u.buf + off) abort ();
      check (off, 10, 'B');
    }

  /* len == 11 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 11);
      if (p != u.buf + off) abort ();
      check (off, 11, '\0');

      p = memset (u.buf + off, A, 11);
      if (p != u.buf + off) abort ();
      check (off, 11, 'A');

      p = memset (u.buf + off, 'B', 11);
      if (p != u.buf + off) abort ();
      check (off, 11, 'B');
    }

  /* len == 12 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 12);
      if (p != u.buf + off) abort ();
      check (off, 12, '\0');

      p = memset (u.buf + off, A, 12);
      if (p != u.buf + off) abort ();
      check (off, 12, 'A');

      p = memset (u.buf + off, 'B', 12);
      if (p != u.buf + off) abort ();
      check (off, 12, 'B');
    }

  /* len == 13 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 13);
      if (p != u.buf + off) abort ();
      check (off, 13, '\0');

      p = memset (u.buf + off, A, 13);
      if (p != u.buf + off) abort ();
      check (off, 13, 'A');

      p = memset (u.buf + off, 'B', 13);
      if (p != u.buf + off) abort ();
      check (off, 13, 'B');
    }

  /* len == 14 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 14);
      if (p != u.buf + off) abort ();
      check (off, 14, '\0');

      p = memset (u.buf + off, A, 14);
      if (p != u.buf + off) abort ();
      check (off, 14, 'A');

      p = memset (u.buf + off, 'B', 14);
      if (p != u.buf + off) abort ();
      check (off, 14, 'B');
    }

  /* len == 15 */
  for (off = 0; off < MAX_OFFSET; off++)
    {
      reset ();

      p = memset (u.buf + off, '\0', 15);
      if (p != u.buf + off) abort ();
      check (off, 15, '\0');

      p = memset (u.buf + off, A, 15);
      if (p != u.buf + off) abort ();
      check (off, 15, 'A');

      p = memset (u.buf + off, 'B', 15);
      if (p != u.buf + off) abort ();
      check (off, 15, 'B');
    }

  exit (0);
}
// source: memset-3.c
/* Copyright (C) 2002  Free Software Foundation.

   Test memset with various combinations of constant pointer alignments and
   lengths to make sure any optimizations in the compiler are correct.

   Written by Roger Sayle, July 22, 2002.  */

#ifndef MAX_OFFSET
#define MAX_OFFSET (sizeof (long long))
#endif

#ifndef MAX_COPY
#define MAX_COPY 15
#endif

#ifndef MAX_EXTRA
#define MAX_EXTRA (sizeof (long long))
#endif

#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + MAX_EXTRA)

static union {
  char buf[MAX_LENGTH];
  long long align_int;
  long double align_fp;
} u;

char A = 'A';

void reset ()
{
  int i;

  for (i = 0; i < MAX_LENGTH; i++)
    u.buf[i] = 'a';
}

void check (int off, int len, int ch)
{
  char *q;
  int i;

  q = u.buf;
  for (i = 0; i < off; i++, q++)
    if (*q != 'a')
      abort ();

  for (i = 0; i < len; i++, q++)
    if (*q != ch)
      abort ();

  for (i = 0; i < MAX_EXTRA; i++, q++)
    if (*q != 'a')
      abort ();
}

int main ()
{
  int len;
  char *p;

  /* off == 0 */
  for (len = 0; len < MAX_COPY; len++)
    {
      reset ();

      p = memset (u.buf, '\0', len);
      if (p != u.buf) abort ();
      check (0, len, '\0');

      p = memset (u.buf, A, len);
      if (p != u.buf) abort ();
      check (0, len, 'A');

      p = memset (u.buf, 'B', len);
      if (p != u.buf) abort ();
      check (0, len, 'B');
    }

  /* off == 1 */
  for (len = 0; len < MAX_COPY; len++)
    {
      reset ();

      p = memset (u.buf+1, '\0', len);
      if (p != u.buf+1) abort ();
      check (1, len, '\0');

      p = memset (u.buf+1, A, len);
      if (p != u.buf+1) abort ();
      check (1, len, 'A');

      p = memset (u.buf+1, 'B', len);
      if (p != u.buf+1) abort ();
      check (1, len, 'B');
    }

  /* off == 2 */
  for (len = 0; len < MAX_COPY; len++)
    {
      reset ();

      p = memset (u.buf+2, '\0', len);
      if (p != u.buf+2) abort ();
      check (2, len, '\0');

      p = memset (u.buf+2, A, len);
      if (p != u.buf+2) abort ();
      check (2, len, 'A');

      p = memset (u.buf+2, 'B', len);
      if (p != u.buf+2) abort ();
      check (2, len, 'B');
    }

  /* off == 3 */
  for (len = 0; len < MAX_COPY; len++)
    {
      reset ();

      p = memset (u.buf+3, '\0', len);
      if (p != u.buf+3) abort ();
      check (3, len, '\0');

      p = memset (u.buf+3, A, len);
      if (p != u.buf+3) abort ();
      check (3, len, 'A');

      p = memset (u.buf+3, 'B', len);
      if (p != u.buf+3) abort ();
      check (3, len, 'B');
    }

  /* off == 4 */
  for (len = 0; len < MAX_COPY; len++)
    {
      reset ();

      p = memset (u.buf+4, '\0', len);
      if (p != u.buf+4) abort ();
      check (4, len, '\0');

      p = memset (u.buf+4, A, len);
      if (p != u.buf+4) abort ();
      check (4, len, 'A');

      p = memset (u.buf+4, 'B', len);
      if (p != u.buf+4) abort ();
      check (4, len, 'B');
    }

  /* off == 5 */
  for (len = 0; len < MAX_COPY; len++)
    {
      reset ();

      p = memset (u.buf+5, '\0', len);
      if (p != u.buf+5) abort ();
      check (5, len, '\0');

      p = memset (u.buf+5, A, len);
      if (p != u.buf+5) abort ();
      check (5, len, 'A');

      p = memset (u.buf+5, 'B', len);
      if (p != u.buf+5) abort ();
      check (5, len, 'B');
    }

  /* off == 6 */
  for (len = 0; len < MAX_COPY; len++)
    {
      reset ();

      p = memset (u.buf+6, '\0', len);
      if (p != u.buf+6) abort ();
      check (6, len, '\0');

      p = memset (u.buf+6, A, len);
      if (p != u.buf+6) abort ();
      check (6, len, 'A');

      p = memset (u.buf+6, 'B', len);
      if (p != u.buf+6) abort ();
      check (6, len, 'B');
    }

  /* off == 7 */
  for (len = 0; len < MAX_COPY; len++)
    {
      reset ();

      p = memset (u.buf+7, '\0', len);
      if (p != u.buf+7) abort ();
      check (7, len, '\0');

      p = memset (u.buf+7, A, len);
      if (p != u.buf+7) abort ();
      check (7, len, 'A');

      p = memset (u.buf+7, 'B', len);
      if (p != u.buf+7) abort ();
      check (7, len, 'B');
    }

  exit (0);
}
// source: memset-4.c
/* Test to make sure memset of small old size works
   correctly. */
#define SIZE 15

void f(char *a) __attribute__((noinline));
void f(char *a)
{
  __builtin_memset (a, 0, SIZE);
}


int main(void)
{
  int i;
  char b[SIZE];
  for(i = 0; i < sizeof(b); i++)
    {
      b[i] = i;
    }
  f(b);
  for(i = 0; i < sizeof(b); i++)
    {
      if (0 != b[i])
	__builtin_abort ();
    }
  return 0;
}
// source: mod-1.c
f (x, y)
{
  if (x % y != 0)
    abort ();
}

main ()
{
  f (-5, 5);
  exit (0);
}
// source: mode-dependent-address.c
/* { dg-require-effective-target stdint_types } */

#include <stdint.h>
#include <string.h>
#include <stdlib.h>

void f883b (int8_t * result,
    int16_t * __restrict arg1,
    uint32_t * __restrict arg2,
    uint64_t * __restrict arg3,
    uint8_t * __restrict arg4)
{
    int idx;
    for (idx=0;idx<96;idx += 1) {
	result[idx] = (((((((((((-27 + 2+1)>>1) || arg4[idx]) < arg1[idx])
				? (((-27 + 2+1)>>1) || arg4[idx])
				: arg1[idx])
			       >> (arg2[idx] & 31)) ^ 1) - -32)>>7) | -5) & arg3[idx]);
    }
}

int8_t result[96];
int16_t arg1[96];
uint32_t arg2[96];
uint64_t arg3[96];
uint8_t arg4[96];

int main (void)
{
  int i;
  int correct[] = {0x0,0x1,0x2,0x3,0x0,0x1,0x2,0x3,0x8,0x9,0xa,0xb,0x8,0x9,
                   0xa,0xb,0x10,0x11,0x12,0x13,0x10,0x11,0x12,0x13,
                   0x18,0x19,0x1a,0x1b,0x18,0x19,0x1a,0x1b,0x20,0x21,0x22,
                   0x23,0x20,0x21,0x22,0x23,0x28,0x29,0x2a,
                   0x2b,0x28,0x29,0x2a,0x2b,0x30,0x31,0x32,0x33,
                   0x30,0x31,0x32,0x33,0x38,0x39,0x3a,0x3b,0x38,0x39,0x3a,
                   0x3b,0x40,0x41,0x42,0x43,0x40,0x41,0x42,0x43,0x48,0x49,
                   0x4a,0x4b,0x48,0x49,0x4a,0x4b,0x50,0x51,
                   0x52,0x53,0x50,0x51,0x52,0x53,0x58,0x59,0x5a,0x5b,
                   0x58,0x59,0x5a,0x5b};

  for (i=0; i < 96; i++)
    arg3[i] = arg2[i] = arg1[i] = arg4[i] = i;

  f883b(result, arg1, arg2, arg3, arg4);

  for (i=0; i < 96; i++)
    if (result[i] != correct[i]) abort();

  return 0;
}
// source: multdi-1.c
/* PR target/9348 */

#define u_l_l unsigned long long
#define l_l long long

l_l mpy_res;

u_l_l mpy (long a, long b)
{
  return (u_l_l) a * (u_l_l) b;
}

int main(void)
{
  mpy_res = mpy(1,-1);
  if (mpy_res != -1LL)
    abort ();
  return 0;
}
// source: multi-ix.c
/* { dg-add-options stack_size } */

/* Test for a reload bug:
   if you have a memory reference using the indexed addressing
   mode, and the base address is a pseudo containing an address in the frame
   and this pseudo fails to get a hard register, we end up with a double PLUS,
   so the frame address gets reloaded.  Now, when the index got a hard register,
   and it dies in this insn, push_reload will consider that hard register as
   a reload register, and disregrad overlaps with rld[n_reloads].in .  That is
   fine as long as the add can be done with a single insn, but when the
   constant is so large that it has to be reloaded into a register first,
   that clobbers the index.  */

#include <stdarg.h>

#ifdef STACK_SIZE
/* We need to be careful that we don't blow our stack.  Function f, in the
   worst case, needs to fit on the stack:

   * 40 int[CHUNK] arrays;
   * ~40 ints;
   * ~40 pointers for stdarg passing.

   Subtract the last two off STACK_SIZE and figure out what the maximum
   chunk size can be.  We make the last bit conservative to account for
   register saves and other processor-dependent saving.  Limit the
   chunk size to some sane values.  */

#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))
#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))

#define CHUNK								\
  MIN (500, (MAX (1, (signed)(STACK_SIZE-40*sizeof(int)-256*sizeof(void *)) \
		      / (signed)(40*sizeof(int)))))
#else
#define CHUNK 500
#endif

void s(int, ...);
void z(int, ...);
void c(int, ...);

typedef int l[CHUNK];

void
f (int n)
{
  int i;
  l a0, a1, a2, a3, a4, a5, a6, a7, a8, a9;
  l a10, a11, a12, a13, a14, a15, a16, a17, a18, a19;
  l a20, a21, a22, a23, a24, a25, a26, a27, a28, a29;
  l a30, a31, a32, a33, a34, a35, a36, a37, a38, a39;
  int i0, i1, i2, i3, i4, i5, i6, i7, i8, i9;
  int i10, i11, i12, i13, i14, i15, i16, i17, i18, i19;
  int i20, i21, i22, i23, i24, i25, i26, i27, i28, i29;
  int i30, i31, i32, i33, i34, i35, i36, i37, i38, i39;

  for (i = 0; i < n; i++)
    {
      s (40, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9,
	 a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
         a20, a21, a22, a23, a24, a25, a26, a27, a28, a29,
         a30, a31, a32, a33, a34, a35, a36, a37, a38, a39);
      i0 = a0[0];
      i1 = a1[0];
      i2 = a2[0];
      i3 = a3[0];
      i4 = a4[0];
      i5 = a5[0];
      i6 = a6[0];
      i7 = a7[0];
      i8 = a8[0];
      i9 = a9[0];
      i10 = a10[0];
      i11 = a11[0];
      i12 = a12[0];
      i13 = a13[0];
      i14 = a14[0];
      i15 = a15[0];
      i16 = a16[0];
      i17 = a17[0];
      i18 = a18[0];
      i19 = a19[0];
      i20 = a20[0];
      i21 = a21[0];
      i22 = a22[0];
      i23 = a23[0];
      i24 = a24[0];
      i25 = a25[0];
      i26 = a26[0];
      i27 = a27[0];
      i28 = a28[0];
      i29 = a29[0];
      i30 = a30[0];
      i31 = a31[0];
      i32 = a32[0];
      i33 = a33[0];
      i34 = a34[0];
      i35 = a35[0];
      i36 = a36[0];
      i37 = a37[0];
      i38 = a38[0];
      i39 = a39[0];
      z (40, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9,
	 a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
         a20, a21, a22, a23, a24, a25, a26, a27, a28, a29,
         a30, a31, a32, a33, a34, a35, a36, a37, a38, a39);
      a0[i0] = i0;
      a1[i1] = i1;
      a2[i2] = i2;
      a3[i3] = i3;
      a4[i4] = i4;
      a5[i5] = i5;
      a6[i6] = i6;
      a7[i7] = i7;
      a8[i8] = i8;
      a9[i9] = i9;
      a10[i10] = i10;
      a11[i11] = i11;
      a12[i12] = i12;
      a13[i13] = i13;
      a14[i14] = i14;
      a15[i15] = i15;
      a16[i16] = i16;
      a17[i17] = i17;
      a18[i18] = i18;
      a19[i19] = i19;
      a20[i20] = i20;
      a21[i21] = i21;
      a22[i22] = i22;
      a23[i23] = i23;
      a24[i24] = i24;
      a25[i25] = i25;
      a26[i26] = i26;
      a27[i27] = i27;
      a28[i28] = i28;
      a29[i29] = i29;
      a30[i30] = i30;
      a31[i31] = i31;
      a32[i32] = i32;
      a33[i33] = i33;
      a34[i34] = i34;
      a35[i35] = i35;
      a36[i36] = i36;
      a37[i37] = i37;
      a38[i38] = i38;
      a39[i39] = i39;
      c (40, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9,
	 a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
         a20, a21, a22, a23, a24, a25, a26, a27, a28, a29,
         a30, a31, a32, a33, a34, a35, a36, a37, a38, a39);
    }
}

int
main ()
{
  /* CHUNK needs to be at least 40 to avoid stack corruption,
     since index variable i0 in "a[i0] = i0" equals 39.  */
  if (CHUNK < 40)
    exit (0);

  f (1);
  exit (0);
}

void s(int n, ...)
{
  va_list list;

  va_start (list, n);
  while (n--)
    {
      int *a = va_arg (list, int *);
      a[0] = n;
    }
  va_end (list);
}

void z(int n, ...)
{
  va_list list;

  va_start (list, n);
  while (n--)
    {
      int *a = va_arg (list, int *);
      __builtin_memset (a, 0, sizeof (l));
    }
  va_end (list);
}

void c(int n, ...)
{
  va_list list;

  va_start (list, n);
  while (n--)
    {
      int *a = va_arg (list, int *);
      if (a[n] != n)
	abort ();
    }
  va_end (list);
}
// source: nest-align-1.c
/* Test for alignment handling when a variable is accessed by nested
   function.  */
/* Origin: Joey Ye <joey.ye@intel.com> */

/* Force bigger stack alignment for PowerPC EABI targets.  */
/* { dg-options "-mno-eabi" { target powerpc-*-eabi* } } */

#include <stddef.h>

typedef int aligned __attribute__((aligned));
extern void abort (void);

void
check (int *i)
{
  *i = 20;
  if ((((ptrdiff_t) i) & (__alignof__(aligned) - 1)) != 0)
    abort ();
}

void
foo (void)
{
  aligned jj;
  void bar ()
    {
      jj = -20;
    }
  jj = 0;
  bar ();
  if (jj != -20)
    abort ();
  check (&jj);
  if (jj != 20)
    abort ();
}

int
main()
{
  foo ();
  return 0;
}
// source: nest-stdar-1.c
#include <stdarg.h>

main ()
{
  double f (int x, ...)
    {
      va_list args;
      double a;

      va_start (args, x);
      a = va_arg (args, double);
      va_end (args);
      return a;
    }

  if (f (1, (double)1) != 1.0)
    abort ();
  exit (0);
}
// source: nestfunc-1.c
/* { dg-require-effective-target trampolines } */

int
g (int a, int b, int (*gi) (int, int))
{
  if ((*gi) (a, b))
    return a;
  else
    return b;
}

f ()
{
  int i, j;
  int f2 (int a, int b)
    {
      return a > b;
    }

  if (g (1, 2, f2) != 2)
    abort ();
}

main ()
{
  f ();
  exit (0);
}
// source: nestfunc-2.c
/* { dg-require-effective-target trampolines } */

extern int foo (int, int, int (*) (int, int, int, int, int, int, int));

int z;

int
main (void)
{
  int sum = 0;
  int i;

  int nested (int a, int b, int c, int d, int e, int f, int g)
    {
      z = c + d + e + f + g;

      if (a > 2 * b)
        return a - b;
      else
        return b - a;
    }

  for (i = 0; i < 10; ++i)
    {
      int j;

      for (j = 0; j < 10; ++j)
        {
          int k;

          for (k = 0; k < 10; ++k)
            sum += foo (i, j > k ? j - k : k - j, nested);
        }
    }

  if (sum != 2300)
    abort ();

  if (z != 0x1b)
    abort ();

  exit (0);
}

int
foo (int a, int b, int (* fp) (int, int, int, int, int, int, int))
{
  return fp (a, b, a, b, a, b, a);
}
// source: nestfunc-3.c
/* { dg-require-effective-target trampolines } */

extern long foo (long, long, long (*) (long, long));
extern long use (long (*) (long, long), long, long);

int
main (void)
{
  long sum = 0;
  long i;

  long nested_0 (long a, long b)
    {
      if (a > 2 * b)
        return a - b;
      else
        return b - a;
    }

  long nested_1 (long a, long b)
    {
      return use (nested_0, b, a) + sum;
    }

  long nested_2 (long a, long b)
    {
      return nested_1 (b, a);
    }

  for (i = 0; i < 10; ++i)
    {
      long j;

      for (j = 0; j < 10; ++j)
        {
          long k;

          for (k = 0; k < 10; ++k)
            sum += foo (i, j > k ? j - k : k - j, nested_2);
        }
    }

  if ((sum & 0xffffffff) != 0xbecfcbf5)
    abort ();

  exit (0);
}

long
use (long (* func)(long, long), long a, long b)
{
  return func (b, a);
}

long
foo (long a, long b, long (* func) (long, long))
{
  return func (a, b);
}
// source: nestfunc-4.c
/* { dg-add-options stack_size } */

/* Origin: hp@bitrange.com
   Test that return values come out right from a 1000-level call chain to
   functions without parameters that each need at least one "long"
   preserved.  Exposed problems related to the MMIX port.  */

long level = 0;
extern long foo (void);
extern long bar (void);

#ifdef STACK_SIZE
#define DEPTH ((STACK_SIZE) / 512 + 1)
#else
#define DEPTH 500
#endif

int
main (void)
{
  if (foo () == -42)
    exit (0);

  abort ();
}

long
foo (void)
{
  long tmp = ++level;
  return bar () + tmp;
}

long
bar (void)
{
  long tmp = level;
  return tmp > DEPTH - 1 ? -42 - tmp : foo () - tmp;
}
// source: nestfunc-5.c
/* { dg-require-effective-target trampolines } */

extern void abort (void);
extern void exit (int);

static void recursive (int n, void (*proc) (void))
{
  __label__ l1;

  void do_goto (void)
  {
    goto l1;
  }

  if (n == 3)
      recursive (n - 1, do_goto);
  else if (n > 0)
    recursive (n - 1, proc);
  else
    (*proc) ();
  return;

l1:
  if (n == 3)
    exit (0);
  else
    abort ();
}

int main ()
{
  recursive (10, abort);
  abort ();
}
// source: nestfunc-6.c
/* { dg-require-effective-target trampolines } */

/* Test that the GP gets properly restored, either by the nonlocal
   receiver or the nested function.  */

typedef __SIZE_TYPE__ size_t;
extern void abort (void);
extern void exit (int);
extern void qsort(void *, size_t, size_t, int (*)(const void *, const void *));

int main ()
{
  __label__ nonlocal;
  int compare (const void *a, const void *b)
  {
    goto nonlocal;
  }

  char array[3];
  qsort (array, 3, 1, compare);
  abort ();

 nonlocal:
  exit (0);
}
// source: nestfunc-7.c
struct A
{
  int one;
  int two;
  int three;
  int four;
  int five;
  int six;
};

static int test (void)
{
  int base;

  struct A Foo (void)
    {
      struct A a;

      a.one = base + 1;
      a.two = base + 2;
      a.three = base + 3;
      a.four = base + 4;
      a.five = base + 5;
      a.six = base + 6;

      return a;
    }

  base = 10;
  struct A a = Foo ();

  return (a.one == 11
	  && a.two == 12
	  && a.three == 13
	  && a.four == 14
	  && a.five == 15
	  && a.six == 16);
}

int main (void)
{
  return !test ();
}
// source: noinit-attribute.c
/* { dg-do run } */
/* { dg-require-effective-target noinit } */
/* { dg-options "-O2" } */

/* This test checks that noinit data is handled correctly.  */

extern void _start (void) __attribute__ ((noreturn));
extern void abort (void) __attribute__ ((noreturn));
extern void exit (int) __attribute__ ((noreturn));

int var_common;
int var_zero = 0;
int var_one = 1;
int __attribute__((noinit)) var_noinit;
int var_init = 2;

int __attribute__((noinit)) func(); /* { dg-warning "attribute only applies to variables" } */
int __attribute__((section ("mysection"), noinit)) var_section1; /* { dg-warning "because it conflicts with attribute" } */
int __attribute__((noinit, section ("mysection"))) var_section2; /* { dg-warning "because it conflicts with attribute" } */


int
main (void)
{
  /* Make sure that the C startup code has correctly initialized the ordinary variables.  */
  if (var_common != 0)
    abort ();

  /* Initialized variables are not re-initialized during startup, so
     check their original values only during the first run of this
     test.  */
  if (var_init == 2)
    if (var_zero != 0 || var_one != 1)
      abort ();

  switch (var_init)
    {
    case 2:
      /* First time through - change all the values.  */
      var_common = var_zero = var_one = var_noinit = var_init = 3;
      break;

    case 3:
      /* Second time through - make sure that d has not been reset.  */
      if (var_noinit != 3)
	abort ();
      exit (0);

    default:
      /* Any other value for var_init is an error.  */
      abort ();
    }

  /* Simulate a processor reset by calling the C startup code.  */
  _start ();

  /* Should never reach here.  */
  abort ();
}
// source: p18298.c
/* { dg-options "-fgnu89-inline" } */

#include <stdbool.h>
#include <stdlib.h>
extern void abort (void);
int strcmp (const char*, const char*);
char s[2048] = "a";
inline bool foo(const char *str) {
  return !strcmp(s,str);
}
int main() {
int i = 0;
  while(!(foo(""))) {
    i ++;
    s[0] = '\0';
    if (i>2)
     abort ();
  }
  return 0;
}
// source: packed-1.c
short x1 = 17;

struct
{
  short i __attribute__ ((packed));
} t;

f ()
{
  t.i = x1;
  if (t.i != 17)
    abort ();
}

main ()
{
  f ();
  exit (0);
}
// source: packed-2.c
typedef struct s {
	unsigned short a;
	unsigned long b __attribute__ ((packed));
} s;

s t;

int main()
{
        t.b = 0;
	return 0;
}
// source: pending-4.c

void dummy (x, y)
     int *x;
     int y;
{}

int
main (argc, argv)
     int argc;
     char **argv;
{
  int number_columns=9;
  int cnt0 = 0;
  int cnt1 = 0;
  int i,A1;

  for (i = number_columns-1; i != 0; i--)
    {
      if (i == 1)
	{
	  dummy(&A1, i);
	  cnt0++;
	}
      else
	{
          dummy(&A1, i-1);
          cnt1++;
	}
    }
  if (cnt0 != 1 || cnt1 != 7)
    abort ();
  exit (0);
}
// source: postmod-1.c
#define DECLARE_ARRAY(A) array##A[0x10]
#define DECLARE_COUNTER(A) counter##A = 0
#define DECLARE_POINTER(A) *pointer##A = array##A + x
/* Create a loop that allows post-modification of pointerA, followed by
   a use of the post-modified address.  */
#define BEFORE(A) counter##A += *pointer##A, pointer##A += 3
#define AFTER(A) counter##A += pointer##A[x]

/* Set up the arrays so that one iteration of the loop sets the counter
   to 3.0f.  */
#define INIT_ARRAY(A) array##A[1] = 1.0f, array##A[5] = 2.0f

/* Check that the loop worked correctly for all values.  */
#define CHECK_ARRAY(A) exit_code |= (counter##A != 3.0f)

/* Having 6 copies triggered the bug for ARM and Thumb.  */
#define MANY(A) A (0), A (1), A (2), A (3), A (4), A (5)

/* Each addendA should be allocated a register.  */
#define INIT_VOLATILE(A) addend##A = vol
#define ADD_VOLATILE(A) vol += addend##A

/* Having 5 copies triggered the bug for ARM and Thumb.  */
#define MANY2(A) A (0), A (1), A (2), A (3), A (4)

float MANY (DECLARE_ARRAY);
float MANY (DECLARE_COUNTER);

volatile int stop = 1;
volatile int vol;

void __attribute__((noinline))
foo (int x)
{
  float MANY (DECLARE_POINTER);
  int i;

  do
    {
      MANY (BEFORE);
      MANY (AFTER);
      /* Create an inner loop that should ensure the code above
	 has registers free for reload inheritance.  */
      {
	int MANY2 (INIT_VOLATILE);
	for (i = 0; i < 10; i++)
	  MANY2 (ADD_VOLATILE);
      }
    }
  while (!stop);
}

int
main (void)
{
  int exit_code = 0;

  MANY (INIT_ARRAY);
  foo (1);
  MANY (CHECK_ARRAY);
  return exit_code;
}
// source: pr15262-1.c
/* PR 15262.
   The alias analyzer only considers relations between pointers and
   symbols.  If two pointers P and Q point to the same symbol S, then
   their respective memory tags will either be the same or they will
   have S in their alias set.

   However, if there are no common symbols between P and Q, TBAA will
   currently miss their alias relationship altogether.  */
struct A
{
  int t;
  int i;
};

int foo () { return 3; }

main ()
{
  struct A loc, *locp;
  float f, g, *p;
  int T355, *T356;

  /* Avoid the partial hack in TBAA that would consider memory tags if
     the program had no addressable symbols.  */
  f = 3;
  g = 2;
  p = foo () ? &g : &f;
  if (*p > 0.0)
    g = 1;

  /* Store into *locp and cache its current value.  */
  locp = malloc (sizeof (*locp));
  locp->i = 10;
  T355 = locp->i;

  /* Take the address of one of locp's fields and write to it.  */
  T356 = &locp->i;
  *T356 = 1;

  /* Read the recently stored value.  If TBAA fails, this will appear
     as a redundant load that will be replaced with '10'.  */
  T355 = locp->i;
  if (T355 != 1)
    abort ();

  return 0;
}
// source: pr15262-2.c
/* PR 15262.  Similar to pr15262-1.c but with no obvious addresses
   being taken in function foo().  Without IPA, by only looking inside
   foo() we cannot tell for certain whether 'q' and 'b' alias each
   other.  */
struct A
{
  int t;
  int i;
};

struct B
{
  int *p;
  float b;
};

float X;

foo (struct B b, struct A *q, float *h)
{
  X += *h;
  *(b.p) = 3;
  q->t = 2;
  return *(b.p);
}

main()
{
  struct A a;
  struct B b;

  b.p = &a.t;
  if (foo (b, &a, &X) == 3)
    abort ();

  return 0;
}
// source: pr15262.c
/* We used to mis-compile this testcase as we did not know that
   &a+offsetof(b,a) was the same as &a.b */
struct A
{
  int t;
  int i;
};

void
bar (float *p)
{
  *p = 5.2;
}

int
foo(struct A *locp, int i, int str)
{
  float f, g, *p;
  int T355;
  int *T356;
  /* Currently, the alias analyzer has limited support for handling
     aliases of structure fields when no other variables are aliased.
     Introduce additional aliases to confuse it.  */
  p =  i ? &g : &f;
  bar (p);
  if (*p > 0.0)
    str = 1;

  T355 = locp->i;
  T356 = &locp->i;
  *T356 = str;
  T355 = locp->i;

  return T355;
}

main ()
{
  struct A loc;
  int str;

  loc.i = 2;
  str = foo (&loc, 10, 3);
  if (str!=1)
    abort ();
  return 0;
}
// source: pr15296.c
/* PR optimization/15296.  The delayed-branch scheduler caused code that
   SEGV:d for CRIS; a register was set to -1 in a delay-slot for the
   fall-through code, while that register held a pointer used in code at
   the branch target.  */

typedef __INTPTR_TYPE__ intptr_t;
typedef intptr_t W;
union u0
{
  union u0 *r;
  W i;
};
struct s1
{
  union u0 **m0;
  union u0 m1[4];
};

void f (void *, struct s1 *, const union u0 *, W, W, W)
     __attribute__ ((__noinline__));
void g (void *, char *) __attribute__ ((__noinline__));

void
f (void *a, struct s1 *b, const union u0 *h, W v0, W v1, W v4)
{
  union u0 *e = 0;
  union u0 *k = 0;
  union u0 **v5 = b->m0;
  union u0 *c = b->m1;
  union u0 **d = &v5[0];
l0:;
  if (v0 < v1)
    goto l0;
  if (v0 == 0)
    goto l3;
  v0 = v4;
  if (v0 != 0)
    goto l3;
  c[0].r = *d;
  v1 = -1;
  e = c[0].r;
  if (e != 0)
    g (a, "");
  k = e + 3;
  k->i = v1;
  goto l4;
l3:;
  c[0].i = v0;
  e = c[1].r;
  if (e != 0)
    g (a, "");
  e = c[0].r;
  if (e == 0)
    g (a, "");
  k = e + 2;
  k->r = c[1].r;
l4:;
}

void g (void *a, char *b) { abort (); }

int
main ()
{
  union u0 uv[] = {{ .i = 111 }, { .i = 222 }, { .i = 333 }, { .i = 444 }};
  struct s1 s = { 0, {{ .i = 555 }, { .i = 0 }, { .i = 999 }, { .i = 777 }}};
  f (0, &s, 0, 20000, 10000, (W) uv);
  if (s.m1[0].i != (W) uv || s.m1[1].i != 0 || s.m1[2].i != 999
      || s.m1[3].i != 777 || uv[0].i != 111 || uv[1].i != 222
      || uv[2].i != 0 || uv[3].i != 444)
    abort ();
  exit (0);
}
// source: pr16790-1.c
/* PR middle-end/16790.  */

extern void abort ();

static void test1(unsigned int u1)
{
  unsigned int y_final_1;
  signed short y_middle;
  unsigned int y_final_2;

  y_final_1 = (unsigned int)( (signed short)(u1 * 2) * 3 );
  y_middle  =                 (signed short)(u1 * 2);
  y_final_2 = (unsigned int)( y_middle * 3 );

  if (y_final_1 != y_final_2)
    abort ();
}


static void test2(unsigned int u1)
{
  unsigned int y_final_1;
  signed short y_middle;
  unsigned int y_final_2;

  y_final_1 = (unsigned int)( (signed short)(u1 << 1) * 3 );
  y_middle  =                 (signed short)(u1 << 1);
  y_final_2 = (unsigned int)( y_middle * 3 );

  if (y_final_1 != y_final_2)
    abort ();
}


int main()
{
  test1(0x4000U);
  test2(0x4000U);
  return 0;
}
// source: pr17078-1.c
extern void abort(void);

void test(int *ptr)
{
  int i = 1;
  goto useless;
  if (0)
    {
      useless:
      i = 0;
    }
  else
    i = 1;
  *ptr = i;
}

int main()
{
  int i = 1;
  test(&i);
  if (i)
    abort ();
  return 0;
}
// source: pr17133.c
extern void abort (void);

int foo = 0;
void *bar = 0;
unsigned int baz = 100;

void *pure_alloc ()
{
  void *res;

  while (1)
    {
      res = (void *) ((((unsigned int) (foo + bar))) & ~1);
      foo += 2;
      if (foo < baz)
        return res;
      foo = 0;
    }
}

int main ()
{
  pure_alloc ();
  if (!foo)
    abort ();
  return 0;
}
// source: pr17252.c
/* PR 17252.  When a char * pointer P takes its own address, storing
   into *P changes P itself.  */

char *a;

main ()
{
  /* Make 'a' point to itself.  */
  a = (char *)&a;

  /* Change what 'a' is pointing to.  */
  a[0]++;

  /* If a's memory tag does not contain 'a' in its alias set, we will
     think that this predicate is superfluous and change it to
     'if (1)'.  */
  if (a == (char *)&a)
    abort ();

  return 0;
}
// source: pr17377.c
/* PR target/17377
   Bug in code emitted by "return" pattern on CRIS: missing pop of
   forced return address on stack.  */
/* { dg-require-effective-target return_address } */
int calls = 0;

void *f (int) __attribute__ ((__noinline__));
void *
f (int i)
{
  /* The code does a little brittle song and dance to trig the "return"
     pattern instead of the function epilogue.  This must still be a
     leaf function for the bug to be exposed.  */

  if (calls++ == 0)
    return __builtin_return_address (0);

  switch (i)
    {
    case 1:
      return f;
    case 0:
      return __builtin_return_address (0);
    }
  return 0;
}

int x;

void *y (int i) __attribute__ ((__noinline__,__noclone__));
void *
y (int i)
{
  x = 0;

  /* This must not be a sibling call: the return address must appear
     constant for different calls to this function.  Postincrementing x
     catches otherwise unidentified multiple returns (e.g. through the
     return-address register and then this epilogue popping the address
     stored on stack in "f").  */
  return (char *) f (i) + x++;
}

int
main (void)
{
  void *v = y (4);
  if (y (1) != f
      /* Can't reasonably check the validity of the return address
	 above, but it's not that important: the test-case will probably
	 crash on the first call to f with the bug present, or it will
	 run wild including returning early (in y or here), so we also
	 try and check the number of calls.  */
      || y (0) != v
      || y (3) != 0
      || y (-1) != 0
      || calls != 5)
    abort ();
  exit (0);
}
// source: pr19005.c
/* PR target/19005 */
extern void abort (void);

int v, s;

void
bar (int a, int b)
{
  unsigned char x = v;

  if (!s)
    {
      if (a != x || b != (unsigned char) (x + 1))
        abort ();
    }
  else if (a != (unsigned char) (x + 1) || b != x)
    abort ();
  s ^= 1;
}

int
foo (int x)
{
  unsigned char a = x, b = x + 1;

  bar (a, b);
  a ^= b; b ^= a; a ^= b;
  bar (a, b);
  return 0;
}

int
main (void)
{
  for (v = -10; v < 266; v++)
    foo (v);
  return 0;
}
// source: pr19449.c
/* PR c/19449 */

extern void abort (void);

int y;
int z = __builtin_choose_expr (!__builtin_constant_p (y), 3, 4);

int
foo (int x)
{
  return __builtin_choose_expr (!__builtin_constant_p (x), 3, y++);
}

int
main ()
{
  if (y || z != 3 || foo (4) != 3)
    abort ();
  return 0;
}
// source: pr19515.c
/* PR 19515 */

typedef union {
      char a2[8];
}aun;

void abort (void);

int main(void)
{
  aun a = {{0}};

  if (a.a2[2] != 0)
    abort ();
  return 0;
}
// source: pr19606.c
/* PR c/19606
   The C front end used to shorten the type of a division to a type
   that does not preserve the semantics of the original computation.
   Make sure that won't happen.  */

signed char a = -4;

int
foo (void)
{
  return ((unsigned int) (signed int) a) / 2LL;
}

int
bar (void)
{
  return ((unsigned int) (signed int) a) % 5LL;
}

int
main (void)
{
  int r;

  r = foo ();
  if (r != ((unsigned int) (signed int) (signed char) -4) / 2LL)
    abort ();

  r = bar ();
  if (r != ((unsigned int) (signed int) (signed char) -4) % 5LL)
    abort ();

  exit (0);
}
// source: pr19687.c
extern void abort (void);

union U
{
  int i, j[4];
};

int main ()
{
  union U t = {};
  int i;

  for (i = 0; i < 4; ++i)
    if (t.j[i] != 0)
      abort ();

  return 0;
}
// source: pr19689.c
/* { dg-require-effective-target int32plus } */
extern void abort (void);

struct
{
  int b : 29;
} f;

void foo (short j)
{
  f.b = j;
}

int main()
{
  foo (-55);
  if (f.b != -55)
    abort ();
  return 0;
}
// source: pr20100-1.c
/* PR tree-optimization/20100
   Pure function being treated as const.
   Author: Hans-Peter Nilsson.  */

static unsigned short g = 0;
static unsigned short p = 0;
unsigned char e;

static unsigned short
next_g (void)
{
  return g == e - 1 ? 0 : g + 1;
}

static unsigned short
curr_p (void)
{
  return p;
}

static unsigned short
inc_g (void)
{
  return g = next_g ();
}

static unsigned short
curr_g (void)
{
  return g;
}

static char
ring_empty (void)
{
  if (curr_p () == curr_g ())
    return 1;
  else
    return 0;
}

char
frob (unsigned short a, unsigned short b)
{
  g = a;
  p = b;
  inc_g ();
  return ring_empty ();
}

unsigned short
get_n (void)
{
  unsigned short n = 0;
  unsigned short org_g;
  org_g = curr_g ();
  while (!ring_empty () && n < 5)
    {
      inc_g ();
      n++;
    }

  return n;
}

void abort (void);
void exit (int);
int main (void)
{
  e = 3;
  if (frob (0, 2) != 0 || g != 1 || p != 2 || e != 3
      || get_n () != 1
      || g != 2 || p != 2)
    abort ();
  exit (0);
}
// source: pr20187-1.c
int a = 0x101;
int b = 0x100;

int
test (void)
{
  return (((unsigned char) (unsigned long long) ((a ? a : 1) & (a * b)))
	  ? 0 : 1);
}

int
main (void)
{
  return 1 - test ();
}
// source: pr20466-1.c
int f (int **, int *, int *, int **, int **) __attribute__ ((__noinline__));
int
f (int **ipp, int *i1p, int *i2p, int **i3, int **i4)
{
  **ipp = *i1p;
  *ipp = i2p;
  *i3 = *i4;
  **ipp = 99;
  return 3;
}

extern void exit (int);
extern void abort (void);

int main (void)
{
  int i = 42, i1 = 66, i2 = 1, i3 = -1, i4 = 55;
  int *ip = &i;
  int *i3p = &i3;
  int *i4p = &i4;

  f (&ip, &i1, &i2, &i3p, &i4p);
  if (i != 66 || ip != &i2 || i2 != 99 || i3 != -1 || i3p != i4p || i4 != 55)
    abort ();
  exit (0);
}
// source: pr20527-1.c
/* PR rtl-optimization/20527
   Mishandled postincrement.  This test-case is derived from the
   function BZ2_hbCreateDecodeTables in the file huffman.c from
   bzip2-1.0.2, hence requiring the following disclaimer copied here:  */

/*--
  This file is a part of bzip2 and/or libbzip2, a program and
  library for lossless, block-sorting data compression.

  Copyright (C) 1996-2002 Julian R Seward.  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. The origin of this software must not be misrepresented; you must
     not claim that you wrote the original software.  If you use this
     software in a product, an acknowledgment in the product
     documentation would be appreciated but is not required.

  3. Altered source versions must be plainly marked as such, and must
     not be misrepresented as being the original software.

  4. The name of the author may not be used to endorse or promote
     products derived from this software without specific prior written
     permission.

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  Julian Seward, Cambridge, UK.
  jseward@acm.org
  bzip2/libbzip2 version 1.0 of 21 March 2000

  This program is based on (at least) the work of:
     Mike Burrows
     David Wheeler
     Peter Fenwick
     Alistair Moffat
     Radford Neal
     Ian H. Witten
     Robert Sedgewick
     Jon L. Bentley

  For more information on these sources, see the manual.
--*/

void f (long *limit, long *base, long minLen, long maxLen) __attribute__ ((__noinline__));
void f (long *limit, long *base, long minLen, long maxLen)
{
  long i;
  long vec;
  vec = 0;
  for (i = minLen; i <= maxLen; i++) {
    vec += (base[i+1] - base[i]);
    limit[i] = vec-1;
  }
}
extern void abort (void);
extern void exit (int);
long b[] = {1, 5, 11, 23};
int main (void)
{
  long l[3];
  f (l, b, 0, 2);
  if (l[0] != 3 || l[1] != 9 || l[2] != 21)
    abort ();
  exit (0);
}
// source: pr20601-1.c
/* PR tree-optimization/20601 */
/* { dg-xfail-if "ptxas crashes" { nvptx-*-* } { "-O1" } { "" } } */
extern void abort (void);
extern void exit (int);

struct T
{
  char *t1;
  char t2[4096];
  char **t3;
};

int a[5];
int b;
char **c;
int d;
char **e;
struct T t;
char *f[16];
char *g[] = { "a", "-u", "b", "c" };

__attribute__ ((__noreturn__)) void
foo (void)
{
  while (1);
}

__attribute__ ((noinline)) char *
bar (char *x, unsigned int y)
{
  return 0;
}

static inline char *
baz (char *x, unsigned int y)
{
  if (sizeof (t.t2) != (unsigned int) -1 && y > sizeof (t.t2))
    foo ();
  return bar (x, y);
}

static inline int
setup1 (int x)
{
  char *p;
  int rval;

  if (!baz (t.t2, sizeof (t.t2)))
    baz (t.t2, sizeof (t.t2));

  if (x & 0x200)
    {
      char **h, **i = e;

      ++d;
      e = f;
      if (t.t1 && *t.t1)
        e[0] = t.t1;
      else
        abort ();

      for (h = e + 1; (*h = *i); ++i, ++h)
        ;
    }
  return 1;
}

static inline int
setup2 (void)
{
  int j = 1;

  e = c + 1;
  d = b - 1;
  while (d > 0 && e[0][0] == '-')
    {
      if (e[0][1] != '\0' && e[0][2] != '\0')
        abort ();

      switch (e[0][1])
        {
        case 'u':
          if (!e[1])
            abort ();

          t.t3 = &e[1];
          d--;
          e++;
          break;
        case 'P':
          j |= 0x1000;
          break;
        case '-':
          d--;
          e++;
          if (j == 1)
            j |= 0x600;
          return j;
        }
      d--;
      e++;
    }

  if (d > 0 && !(j & 1))
    abort ();

  return j;
}

int
main (void)
{
  int x;
  c = g;
  b = 4;
  x = setup2 ();
  t.t1 = "/bin/sh";
  setup1 (x);
  /* PRE shouldn't transform x into the constant 0x601 here, it's not legal.  */
  if ((x & 0x400) && !a[4])
    abort ();
  exit (0);
}
// source: pr20621-1.c
/* { dg-require-stack-size "0x10000" } */

/* When generating o32 MIPS PIC, main's $gp save slot was out of range
   of a single load instruction.  */
struct big { int i[sizeof (int) >= 4 && sizeof (void *) >= 4 ? 0x4000 : 4]; };
struct big gb;
int foo (struct big b, int x) { return b.i[x]; }
int main (void) { return foo (gb, 0) + foo (gb, 1); }
// source: pr21173.c
void abort (void);

char q;
void *a[2];

void foo (char *p)
{
  int i;
  for (i = 0; i < 2; i++)
    a[i] += p - &q;
}

int main (void)
{
  int i;
  foo (&q);
  for (i = 0; i < 2; i ++)
    if (a[i])
      abort ();
  return 0;
}
// source: pr21331.c
void abort (void);

int bar (void) {  return -1;  }

unsigned long
foo ()
{ unsigned long retval;
  retval = bar ();
  if (retval == -1)  return 0;
  return 3;  }

main ()
{ if (foo () != 0)  abort ();
  return 0;  }
// source: pr21964-1.c
void
foo (int n, int m)
{
  if (m == 0)
    exit (0);
  else if (n != 0)
    abort ();
  else
    foo (n++, m - 1);
}

int
main (void)
{
  foo (0, 4);
}
// source: pr22061-1.c
/* { dg-require-effective-target alloca } */
int N = 1;
void foo() {} /* Necessary to trigger the original ICE.  */
void bar (char a[2][N]) { a[1][0] = N; }
int
main (void)
{
  void *x;

  N = 4;
  x = alloca (2 * N);
  memset (x, 0, 2 * N);
  bar (x);
  if (N[(char *) x] != N)
    abort ();
  exit (0);
}
// source: pr22061-2.c
int *x;
static void bar (char a[2][(*x)++]) {}
int
main (void)
{
  exit (0);
}
// source: pr22061-3.c
void
bar (int N)
{
  int foo (char a[2][++N]) { N += 4; return sizeof (a[0]); }
  if (foo (0) != 2)
    abort ();
  if (foo (0) != 7)
    abort ();
  if (N != 11)
    abort ();
}

int
main()
{
  bar (1);
  exit (0);
}
// source: pr22061-4.c
/* { dg-skip-if "requires alloca" { ! alloca } { "-O0" } { "" } } */
void
bar (int N)
{
  void foo (int a[2][N++]) {}
  int a[2][N];
  foo (a);
  int b[2][N];
  foo (b);
  if (sizeof (a) != sizeof (int) * 2 * 1)
    abort ();
  if (sizeof (b) != sizeof (int) * 2 * 2)
    abort ();
  if (N != 3)
    abort ();
}

int
main (void)
{
  bar (1);
  exit (0);
}
// source: pr22098-1.c
extern void abort (void);
extern void exit (int);
typedef __UINTPTR_TYPE__ uintptr_t;
int
main (void)
{
  int a = 0;
  int *p;
  uintptr_t b;
  b = (uintptr_t)(p = &(int []){0, 1, 2}[++a]);
  if (a != 1 || *p != 1 || *(int *)b != 1)
    abort ();
  exit (0);
}
// source: pr22098-2.c
extern void abort (void);
extern void exit (int);
typedef __UINTPTR_TYPE__ uintptr_t;
int
main (void)
{
  int a = 0;
  int *p;
  uintptr_t b;
  b = (uintptr_t)(p = &(int []){0, 1, 2}[1]);
  if (*p != 1 || *(int *)b != 1)
    abort ();
  exit (0);
}
// source: pr22098-3.c
extern void abort (void);
extern void exit (int);
typedef __UINTPTR_TYPE__ uintptr_t;
int n = 0;
int f (void) { return ++n; }
int
main (void)
{
  int a = 0;
  int *p;
  uintptr_t b;
  b = (uintptr_t)(p = &(int []){0, f(), 2}[1]);
  if (*p != 1 || *(int *)b != 1 || n != 1)
    abort ();
  exit (0);
}
// source: pr22141-1.c
/* PR middle-end/22141 */

extern void abort (void);

struct S
{
  struct T
    {
      char a;
      char b;
      char c;
      char d;
    } t;
} u;

struct U
{
  struct S s[4];
};

void __attribute__((noinline))
c1 (struct T *p)
{
  if (p->a != 1 || p->b != 2 || p->c != 3 || p->d != 4)
    abort ();
  __builtin_memset (p, 0xaa, sizeof (*p));
}

void __attribute__((noinline))
c2 (struct S *p)
{
  c1 (&p->t);
}

void __attribute__((noinline))
c3 (struct U *p)
{
  c2 (&p->s[2]);
}

void __attribute__((noinline))
f1 (void)
{
  u = (struct S) { { 1, 2, 3, 4 } };
}

void __attribute__((noinline))
f2 (void)
{
  u.t.a = 1;
  u.t.b = 2;
  u.t.c = 3;
  u.t.d = 4;
}

void __attribute__((noinline))
f3 (void)
{
  u.t.d = 4;
  u.t.b = 2;
  u.t.a = 1;
  u.t.c = 3;
}

void __attribute__((noinline))
f4 (void)
{
  struct S v;
  v.t.a = 1;
  v.t.b = 2;
  v.t.c = 3;
  v.t.d = 4;
  c2 (&v);
}

void __attribute__((noinline))
f5 (struct S *p)
{
  p->t.a = 1;
  p->t.c = 3;
  p->t.d = 4;
  p->t.b = 2;
}

void __attribute__((noinline))
f6 (void)
{
  struct U v;
  v.s[2].t.a = 1;
  v.s[2].t.b = 2;
  v.s[2].t.c = 3;
  v.s[2].t.d = 4;
  c3 (&v);
}

void __attribute__((noinline))
f7 (struct U *p)
{
  p->s[2].t.a = 1;
  p->s[2].t.c = 3;
  p->s[2].t.d = 4;
  p->s[2].t.b = 2;
}

int
main (void)
{
  struct U w;
  f1 ();
  c2 (&u);
  f2 ();
  c1 (&u.t);
  f3 ();
  c2 (&u);
  f4 ();
  f5 (&u);
  c2 (&u);
  f6 ();
  f7 (&w);
  c3 (&w);
  return 0;
}
// source: pr22141-2.c
/* PR middle-end/22141 */

extern void abort (void);

struct S
{
  struct T
    {
      char a;
      char b;
      char c;
      char d;
    } t;
} u __attribute__((aligned));

struct U
{
  struct S s[4];
};

void __attribute__((noinline))
c1 (struct T *p)
{
  if (p->a != 1 || p->b != 2 || p->c != 3 || p->d != 4)
    abort ();
  __builtin_memset (p, 0xaa, sizeof (*p));
}

void __attribute__((noinline))
c2 (struct S *p)
{
  c1 (&p->t);
}

void __attribute__((noinline))
c3 (struct U *p)
{
  c2 (&p->s[2]);
}

void __attribute__((noinline))
f1 (void)
{
  u = (struct S) { { 1, 2, 3, 4 } };
}

void __attribute__((noinline))
f2 (void)
{
  u.t.a = 1;
  u.t.b = 2;
  u.t.c = 3;
  u.t.d = 4;
}

void __attribute__((noinline))
f3 (void)
{
  u.t.d = 4;
  u.t.b = 2;
  u.t.a = 1;
  u.t.c = 3;
}

void __attribute__((noinline))
f4 (void)
{
  struct S v __attribute__((aligned));
  v.t.a = 1;
  v.t.b = 2;
  v.t.c = 3;
  v.t.d = 4;
  c2 (&v);
}

void __attribute__((noinline))
f5 (struct S *p)
{
  p->t.a = 1;
  p->t.c = 3;
  p->t.d = 4;
  p->t.b = 2;
}

void __attribute__((noinline))
f6 (void)
{
  struct U v __attribute__((aligned));
  v.s[2].t.a = 1;
  v.s[2].t.b = 2;
  v.s[2].t.c = 3;
  v.s[2].t.d = 4;
  c3 (&v);
}

void __attribute__((noinline))
f7 (struct U *p)
{
  p->s[2].t.a = 1;
  p->s[2].t.c = 3;
  p->s[2].t.d = 4;
  p->s[2].t.b = 2;
}

int
main (void)
{
  struct U w __attribute__((aligned));
  f1 ();
  c2 (&u);
  f2 ();
  c1 (&u.t);
  f3 ();
  c2 (&u);
  f4 ();
  f5 (&u);
  c2 (&u);
  f6 ();
  f7 (&w);
  c3 (&w);
  return 0;
}
// source: pr22348.c
void abort (void);
void f(int i)
{
  if (i>4 + 3 * 16)
    abort();
}

int main()
{
  unsigned int buflen, i;
  buflen = 4 + 3 * 16;
  for (i = 4; i < buflen; i+= 3)
    f(i);
  return 0;
}
// source: pr22429.c
extern void abort (void);

#define N	(1 << (sizeof(int) * __CHAR_BIT__ - 2))

int f(int n)
{
  if (-N <= n && n <= N-1)
    return 1;
  return 0;
}

int main ()
{
  if (f (N))
    abort ();
  return 0;
}
// source: pr22493-1.c
/* { dg-options "-fwrapv" } */

#include <limits.h>
extern void abort ();
extern void exit (int);
void f(int i)
{
  if (i>0)
    abort();
  i = -i;
  if (i<0)
    return;
  abort ();
}

int main(int argc, char *argv[])
{
  f(INT_MIN);
  exit (0);
}
// source: pr22630.c
void abort (void);

int j;

void bla (int *r)
{
  int *p, *q;

  p = q = r;
  if (!p)
    p = &j;

  if (p != q)
    j = 1;
}

int main (void)
{
  bla (0);
  if (!j)
    abort ();
  return 0;
}
// source: pr23047.c
/* { dg-options "-fwrapv" } */
#include <limits.h>
extern void abort ();
extern void exit (int);
void f(int i)
{
  i = i > 0 ? i : -i;
  if (i<0)
    return;
  abort ();
}

int main(int argc, char *argv[])
{
  f(INT_MIN);
  exit (0);
}
// source: pr23135.c
/* Based on execute/simd-1.c, modified by joern.rennecke@st.com to
   trigger a reload bug.  Verified for gcc mainline from 20050722 13:00 UTC
   for sh-elf -m4 -O2.  */
/* { dg-options "-Wno-psabi" } */
/* { dg-add-options stack_size } */

#ifndef STACK_SIZE
#define STACK_SIZE (256*1024)
#endif

extern void abort (void);
extern void exit (int);

typedef struct { char c[STACK_SIZE/2]; } big_t;

typedef int __attribute__((mode(SI))) __attribute__((vector_size (8))) vecint;
typedef int __attribute__((mode(SI))) siint;

vecint i = { 150, 100 };
vecint j = { 10, 13 };
vecint k;

union {
  vecint v;
  siint i[2];
} res;

void
verify (siint a1, siint a2, siint b1, siint b2, big_t big)
{
  if (a1 != b1
      || a2 != b2)
    abort ();
}

int
main ()
{
  big_t big;
  vecint k0, k1, k2, k3, k4, k5, k6, k7;

  k0 = i + j;
  res.v = k0;

  verify (res.i[0], res.i[1], 160, 113, big);

  k1 = i * j;
  res.v = k1;

  verify (res.i[0], res.i[1], 1500, 1300, big);

  k2 = i / j;
/* This is the observed failure - reload 0 has the wrong type and thus the
   conflict with reload 1 is missed:

(insn:HI 94 92 96 1 pr23135.c:46 (parallel [
            (set (subreg:SI (reg:DI 253) 0)
                (div:SI (reg:SI 4 r4)
                    (reg:SI 5 r5)))
            (clobber (reg:SI 146 pr))
            (clobber (reg:DF 64 fr0))
            (clobber (reg:DF 66 fr2))
            (use (reg:PSI 151 ))
            (use (reg/f:SI 256))
        ]) 60 {divsi3_i4} (insn_list:REG_DEP_TRUE 90 (insn_list:REG_DEP_TRUE 89
(insn_list:REG_DEP_TRUE 42 (insn_list:REG_DEP_TRUE 83 (insn_list:REG_DEP_TRUE 92
 (insn_list:REG_DEP_TRUE 91 (nil)))))))
    (expr_list:REG_DEAD (reg:SI 4 r4)
        (expr_list:REG_DEAD (reg:SI 5 r5)
            (expr_list:REG_UNUSED (reg:DF 66 fr2)
                (expr_list:REG_UNUSED (reg:DF 64 fr0)
                    (expr_list:REG_UNUSED (reg:SI 146 pr)
                        (insn_list:REG_RETVAL 91 (nil))))))))

Reloads for insn # 94
Reload 0: reload_in (SI) = (plus:SI (reg/f:SI 14 r14)
                                                    (const_int 64 [0x40]))
        GENERAL_REGS, RELOAD_FOR_OUTADDR_ADDRESS (opnum = 0)
        reload_in_reg: (plus:SI (reg/f:SI 14 r14)
                                                    (const_int 64 [0x40]))
        reload_reg_rtx: (reg:SI 3 r3)
Reload 1: GENERAL_REGS, RELOAD_FOR_OUTPUT_ADDRESS (opnum = 0), can't combine, se
condary_reload_p
        reload_reg_rtx: (reg:SI 3 r3)
Reload 2: reload_out (SI) = (mem:SI (plus:SI (plus:SI (reg/f:SI 14 r14)
                                                            (const_int 64 [0x40]))
                                                        (const_int 28 [0x1c])) [ 16 S8 A32])
        FPUL_REGS, RELOAD_FOR_OUTPUT (opnum = 0)
        reload_out_reg: (subreg:SI (reg:DI 253) 0)
        reload_reg_rtx: (reg:SI 150 fpul)
        secondary_out_reload = 1

Reload 3: reload_in (SI) = (symbol_ref:SI ("__sdivsi3_i4") [flags 0x1])
        GENERAL_REGS, RELOAD_FOR_INPUT (opnum = 1), can't combine
        reload_in_reg: (reg/f:SI 256)
        reload_reg_rtx: (reg:SI 3 r3)
  */


  res.v = k2;

  verify (res.i[0], res.i[1], 15, 7, big);

  k3 = i & j;
  res.v = k3;

  verify (res.i[0], res.i[1], 2, 4, big);

  k4 = i | j;
  res.v = k4;

  verify (res.i[0], res.i[1], 158, 109, big);

  k5 = i ^ j;
  res.v = k5;

  verify (res.i[0], res.i[1], 156, 105, big);

  k6 = -i;
  res.v = k6;
  verify (res.i[0], res.i[1], -150, -100, big);

  k7 = ~i;
  res.v = k7;
  verify (res.i[0], res.i[1], -151, -101, big);

  k = k0 + k1 + k3 + k4 + k5 + k6 + k7;
  res.v = k;
  verify (res.i[0], res.i[1], 1675, 1430, big);

  k = k0 * k1 * k3 * k4 * k5 * k6 * k7;
  res.v = k;
  verify (res.i[0], res.i[1], 1456467968, -1579586240, big);

  k = k0 / k1 / k2 / k3 / k4 / k5 / k6 / k7;
  res.v = k;
  verify (res.i[0], res.i[1], 0, 0, big);

  exit (0);
}
// source: pr23324.c
extern void abort (void);
#define A(x) if (!(x)) abort ()

static union at6 {} vv6 = {};
static struct et6
{
  struct bt6
  {
    signed av6:6;
    signed bv6:7;
    signed cv6:6;
    signed dv6:5;
    unsigned char ev6;
    unsigned int fv6;
    long int gv6;
  } mv6;
  unsigned long int nv6;
  signed ov6:12;
  signed pv6:3;
  signed qv6:2;
  signed rv6:10;
  union ct6 { long int hv6; float iv6; float jv6; } sv6;
  int *tv6;
  union dt6 { double kv6; float lv6; } uv6;
} wv6 = {
  { 8, 9, 2, 4, '\x10', 67426805U, 1047191860L },
  1366022414UL, 858, 1, 1, 305,
  { 1069379046L }, (int *) 358273621U,
  { 3318.041978 }
};
static double xv6 = 19239.101269;
static long long int yv6 = 1207859169L;
static int zv6 = 660195606;

static union at6
callee_af6 (struct et6 ap6, double bp6, long long int cp6, int dp6)
{
  A (wv6.mv6.av6 == ap6.mv6.av6);
  A (wv6.mv6.bv6 == ap6.mv6.bv6);
  A (wv6.mv6.cv6 == ap6.mv6.cv6);
  A (wv6.mv6.dv6 == ap6.mv6.dv6);
  A (wv6.mv6.ev6 == ap6.mv6.ev6);
  A (wv6.mv6.fv6 == ap6.mv6.fv6);
  A (wv6.mv6.gv6 == ap6.mv6.gv6);
  A (wv6.nv6 == ap6.nv6);
  A (wv6.ov6 == ap6.ov6);
  A (wv6.pv6 == ap6.pv6);
  A (wv6.qv6 == ap6.qv6);
  A (wv6.rv6 == ap6.rv6);
  A (wv6.sv6.hv6 == ap6.sv6.hv6);
  A (wv6.tv6 == ap6.tv6);
  A (wv6.uv6.kv6 == ap6.uv6.kv6);
  A (xv6 == bp6);
  A (yv6 == cp6);
  A (zv6 == dp6);
  return vv6;
}

static void
caller_bf6 (void)
{
  union at6 bav6;
  bav6 = callee_af6 (wv6, xv6, yv6, zv6);
}

static unsigned char uv7 = '\x46';
static float vv7 = 96636.982442;
static double wv7 = 28450.711801;
static union ct7 {} xv7 = {};
static struct et7
{
  struct dt7
  {
    float iv7;
    unsigned short int jv7;
  } kv7;
  float lv7[0];
  signed mv7:9;
  short int nv7;
  double ov7;
  float pv7;
} yv7 = {
  { 30135.996213, 42435 },
  {}, 170, 22116, 26479.628148, 4082.960685
};
static union ft7
{
  float qv7;
  float *rv7;
  unsigned int *sv7;
} zv7 = { 5042.227886 };
static int bav7 = 1345451862;
static struct gt7 { double tv7; } bbv7 = { 47875.491954 };
static long int bcv7[1] = { 1732133482L };
static long long int bdv7 = 381678602L;

static unsigned char
callee_af7 (float ap7, double bp7, union ct7 cp7, struct et7 dp7,
            union ft7 ep7, int fp7, struct gt7 gp7, long int hp7[1],
            long long int ip7)
{
  A (vv7 == ap7);
  A (wv7 == bp7);
  A (yv7.kv7.iv7 == dp7.kv7.iv7);
  A (yv7.kv7.jv7 == dp7.kv7.jv7);
  A (yv7.mv7 == dp7.mv7);
  A (yv7.nv7 == dp7.nv7);
  A (yv7.ov7 == dp7.ov7);
  A (yv7.pv7 == dp7.pv7);
  A (zv7.qv7 == ep7.qv7);
  A (bav7 == fp7);
  A (bbv7.tv7 == gp7.tv7);
  A (bcv7[0] == hp7[0]);
  A (bdv7 == ip7);
  return uv7;
}

static void
caller_bf7 (void)
{
  unsigned char bev7;

  bev7 = callee_af7 (vv7, wv7, xv7, yv7, zv7, bav7, bbv7, bcv7, bdv7);
  A (uv7 == bev7);
}

int
main ()
{
  caller_bf6 ();
  caller_bf7 ();
  return 0;
}
// source: pr23467.c
/* { dg-skip-if "small alignment" { pdp11-*-* } } */

struct s1
{
  int __attribute__ ((aligned (8))) a;
};

struct
{
  char c;
  struct s1 m;
} v;

int
main (void)
{
  if ((int)&v.m & 7)
    abort ();
  exit (0);
}
// source: pr23604.c
extern void abort (void);

int g(int i, int j)
{
  if (i>-1)
    if (i<2)
     {
        if (i != j)
          {
            if (j != 0)
                return 0;
          }
     }
  return 1;
}

int main(void)
{
  if (!g(1, 0))
   abort ();
  return 0;
}
// source: pr23941.c
extern void abort (void);
double d = __FLT_MIN__ / 2.0;
int main()
{
  double x = __FLT_MIN__ / 2.0;
  if (x != d)
    abort ();
  return 0;
}
// source: pr24135.c
/* { dg-require-effective-target trampolines } */

extern void abort (void);

int x(int a, int b)
{
  __label__ xlab;
  __label__ xlab2;

  void y(int b)
    {
       switch (b)
        {
          case 1: goto xlab;
          case 2: goto xlab;
        }
    }

  a = a + 2;
  y (b);

 xlab:
  return a;

 xlab2:
  a++;
  return a;

}

int main ()
{
  int i, j;

  for (j = 1; j <= 2; ++j)
    for (i = 1; i <= 2; ++i)
      {
	int a = x (j, i);
	if (a != 2 + j)
	  abort ();
      }

  return 0;
}
// source: pr24141.c
// reduced testcase, compile with -O2. Also, with --disable-checking
// gcc produces wrong code.

void abort (void);
int i;

void g (void)
{
  i = 1;
}

void f (int a, int b)
{
  int c = 0;
  if (a == 0)
    c = 1;
  if (c)
    return;
  if (c == 1)
    c = 0;
  if (b == 0)
    c = 1;
  if (c)
    g ();
}

int main (void)
{
  f (1, 0);
  if (i != 1)
    abort ();
  return 0;
}
// source: pr24142.c
void abort (void);

int f (int a, int b)
{
  if (a == 1)
    a = 0;
  if (b == 0)
    a = 1;
  if (a != 0)
    return 0;
  return 1;
}

int main (void)
{
  if (f (1, 1) != 1)
    abort ();
  return 0;
}
// source: pr24716.c
/* PR24716, scalar evolution returning the wrong result
   for pdest.  */

int Link[] = { -1 };
int W[] = { 2 };

extern void abort (void);

int f (int k, int p)
{
  int pdest, j, D1361;
  j = 0;
  pdest = 0;
  for (;;) {
    if (pdest > 2)
      do
        j--, pdest++;
      while (j > 2);

    if (j == 1)
      break;

    while (pdest > p)
      if (j == p)
        pdest++;

    do
      {
        D1361 = W[k];
        do
          if (D1361 != 0)
            pdest = 1, W[k] = D1361 = 0;
        while (p < 1);
    } while (k > 0);

    do
      {
        p = 0;
        k = Link[k];
        while (p < j)
          if (k != -1)
            pdest++, p++;
      }
    while (k != -1);
    j = 1;
  }

  /* The correct return value should be pdest (1 in the call from main).
     DOM3 is mistaken and propagates a 0 here.  */
  return pdest;
}

int main ()
{
  if (!f (0, 2))
    abort ();
  return 0;
}
// source: pr24851.c
/* We used to handle pointer addition wrongly
   at the time of recombining to an ARRAY_REF
   in the case of
     p + -4B
   where -4B is represented as unsigned.  */

void abort(void);
int main()
{
  int a[10], *p, *q;
  q = &a[1];
  p = &q[-1];
  if (p >= &a[9])
    abort ();
  return 0;
}
// source: pr25125.c
extern void exit (int);
extern void abort (void);
extern unsigned short f (short a) __attribute__((__noinline__));

unsigned short
f (short a)
{
  short b;

  if (a > 0)
    return 0;
  b = ((int) a) + - (int) 32768;
  return b;
}

int
main (void)
{
  if (sizeof (short) < 2
      || sizeof (short) >= sizeof (int))
    exit (0);

  if (f (-32767) != 1)
    abort ();

  exit (0);
}
// source: pr25737.c
extern void abort (void);

struct delay_block {
  struct delay_block *succ;
};

static struct delay_block Timer_Queue;

struct delay_block* time_enqueue (struct delay_block *d)
{
  struct delay_block *q = Timer_Queue.succ;
  d->succ =  (void *)0;
  return Timer_Queue.succ;
}

int main(void)
{
  Timer_Queue.succ = &Timer_Queue;
  if (time_enqueue (&Timer_Queue) != (void*)0)
    abort ();
  return 0;
}
// source: pr27073.c
void __attribute__((noinline))
foo (int *p, int d1, int d2, int d3,
     short count, int s1, int s2, int s3, int s4, int s5)
{
  int n = count;
  while (n--)
    {
      *p++ = s1;
      *p++ = s2;
      *p++ = s3;
      *p++ = s4;
      *p++ = s5;
    }
}

int main()
{
  int x[10], i;

  foo (x, 0, 0, 0, 2, 100, 200, 300, 400, 500);
  for (i = 0; i < 10; i++)
    if (x[i] != (i % 5 + 1) * 100)
      abort ();
  exit (0);
}
// source: pr27260.c
/* PR middle-end/27260 */

extern void abort (void);
extern void *memset (void *, int, __SIZE_TYPE__);

char buf[65];

void
foo (int x)
{
  memset (buf, x != 2 ? 1 : 0, 64);
}

int
main (void)
{
  int i;
  buf[64] = 2;
  for (i = 0; i < 64; i++)
    if (buf[i] != 0)
      abort ();
  foo (0);
  for (i = 0; i < 64; i++)
    if (buf[i] != 1)
      abort ();
  foo (2);
  for (i = 0; i < 64; i++)
    if (buf[i] != 0)
      abort ();
  if (buf[64] != 2)
    abort ();
  return 0;
}
// source: pr27285.c
/* PR tree-optimization/27285 */

extern void abort (void);

struct S { unsigned char a, b, c, d[16]; };

void __attribute__ ((noinline))
foo (struct S *x, struct S *y)
{
  int a, b;
  unsigned char c, *d, *e;

  b = x->b;
  d = x->d;
  e = y->d;
  a = 0;
  while (b)
    {
      if (b >= 8)
	{
	  c = 0xff;
	  b -= 8;
	}
      else
	{
	  c = 0xff << (8 - b);
	  b = 0;
	}

      e[a] = d[a] & c;
      a++;
    }
}

int
main (void)
{
  struct S x = { 0, 25, 0, { 0xaa, 0xbb, 0xcc, 0xdd }};
  struct S y = { 0, 0, 0, { 0 }};

  foo (&x, &y);
  if (x.d[0] != y.d[0] || x.d[1] != y.d[1]
      || x.d[2] != y.d[2] || (x.d[3] & 0x80) != y.d[3])
    abort ();
   return 0;
}
// source: pr27364.c
int f(unsigned number_of_digits_to_use)
{
  if (number_of_digits_to_use >1294)
    return 0;
  return (number_of_digits_to_use * 3321928 / 1000000 + 1) /16;
}

int main(void)
{
  if (f(11) != 2)
    __builtin_abort ();
  exit (0);
}
// source: pr27671-1.c
/* PR rtl-optimization/27671.
   The combiner used to simplify "a ^ b == a" to "a" via
   simplify_relational_operation_1 in simplify-rtx.c.  */

extern void abort (void) __attribute__ ((noreturn));
extern void exit (int) __attribute__ ((noreturn));

static int __attribute__((noinline))
foo (int a, int b)
{
  int c = a ^ b;
  if (c == a)
    abort ();
}

int
main (void)
{
  foo (0, 1);
  exit (0);
}
// source: pr28289.c
extern int ok (int);
extern void exit ();
static int gen_x86_64_shrd (int);
static int
gen_x86_64_shrd(int a __attribute__ ((__unused__)))
{
  return 0;
}

extern int gen_x86_shrd_1 (int);
extern void ix86_split_ashr (int);

void
ix86_split_ashr (int mode)
{
          (mode != 0
                      ? ok
                      : gen_x86_64_shrd) (0);
}

volatile int one = 1;
int
main (void)
{
  ix86_split_ashr (one);
  return 1;
}

int
ok (int i)
{
  exit (i);
}
// source: pr28403.c
typedef unsigned long long ull;
int global;

int __attribute__((noinline))
foo (int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8)
{
  global = x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8;
}

ull __attribute__((noinline))
bar (ull x)
{
  foo (1, 2, 1, 3, 1, 4, 1, 5);
  return x >> global;
}

int
main (void)
{
  if (bar (0x123456789abcdefULL) != (0x123456789abcdefULL >> 18))
    abort ();
  exit (0);
}
// source: pr28651.c
#include <limits.h>

extern void abort (void);
int __attribute__((noinline))
foo (unsigned int u)
{
  return (int)(u + 4) < (int)u;
}

int
main (int argc, char *argv[])
{
  unsigned int u = INT_MAX;

  if (foo (u) == 0)
    abort();
  return 0;
}
// source: pr28778.c
extern void abort(void);
typedef long GLint;
void aglChoosePixelFormat (const GLint *);

void
find (const int *alistp)
{
  const int *blist;
  int list[32];
  if (alistp)
    blist = alistp;
  else
    {
      list[3] = 42;
      blist = list;
    }
  aglChoosePixelFormat ((GLint *) blist);
}

void
aglChoosePixelFormat (const GLint * a)
{
  int *b = (int *) a;
  if (b[3] != 42)
    abort ();
}

int
main (void)
{
  find (0);
  return 0;
}
// source: pr28865.c
struct A { int a; char b[]; };
union B { struct A a; char b[sizeof (struct A) + 31]; };
union B b = { { 1, "123456789012345678901234567890" } };
union B c = { { 2, "123456789012345678901234567890" } };

__attribute__((noinline, noclone)) void
foo (int *x[2])
{
  x[0] = &b.a.a;
  x[1] = &c.a.a;
}

int
main ()
{
  int *x[2];
  foo (x);
  if (*x[0] != 1 || *x[1] != 2)
    __builtin_abort ();
  return 0;
}
// source: pr28982a.c
/* PR rtl-optimization/28982.  Function foo() does the equivalent of:

     float tmp_results[NVARS];
     for (int i = 0; i < NVARS; i++)
       {
	 int inc = incs[i];
	 float *ptr = ptrs[i], result = 0;
	 for (int j = 0; j < n; j++)
	   result += *ptr, ptr += inc;
	 tmp_results[i] = result;
       }
     memcpy (results, tmp_results, sizeof (results));

   but without the outermost loop.  The idea is to create high register
   pressure and ensure that some INC and PTR variables are spilled.

   On ARM targets, sequences like "result += *ptr, ptr += inc" can
   usually be implemented using (mem (post_modify ...)), and we do
   indeed create such MEMs before reload for this testcase.  However,
   (post_modify ...) is not a valid address for coprocessor loads, so
   for -mfloat-abi=softfp, reload reloads the POST_MODIFY into a base
   register.  GCC did not deal correctly with cases where the base and
   index of the POST_MODIFY are themselves reloaded.  */
#define NITER 4
#define NVARS 20
#define MULTI(X) \
  X( 0), X( 1), X( 2), X( 3), X( 4), X( 5), X( 6), X( 7), X( 8), X( 9), \
  X(10), X(11), X(12), X(13), X(14), X(15), X(16), X(17), X(18), X(19)

#define DECLAREI(INDEX) inc##INDEX = incs[INDEX]
#define DECLAREF(INDEX) *ptr##INDEX = ptrs[INDEX], result##INDEX = 0
#define LOOP(INDEX) result##INDEX += *ptr##INDEX, ptr##INDEX += inc##INDEX
#define COPYOUT(INDEX) results[INDEX] = result##INDEX

float *ptrs[NVARS];
float results[NVARS];
int incs[NVARS];

void __attribute__((noinline))
foo (int n)
{
  int MULTI (DECLAREI);
  float MULTI (DECLAREF);
  while (n--)
    MULTI (LOOP);
  MULTI (COPYOUT);
}

float input[NITER * NVARS];

int
main (void)
{
  int i;

  for (i = 0; i < NVARS; i++)
    ptrs[i] = input + i, incs[i] = i;
  for (i = 0; i < NITER * NVARS; i++)
    input[i] = i;
  foo (NITER);
  for (i = 0; i < NVARS; i++)
    if (results[i] != i * NITER * (NITER + 1) / 2)
      return 1;
  return 0;
}
// source: pr28982b.c
/* { dg-require-stack-size "0x80100" } */

/* Like pr28982a.c, but with the spill slots outside the range of
   a single sp-based load on ARM.  This test tests for cases where
   the addresses in the base and index reloads require further reloads.  */
#define NITER 4
#define NVARS 20
#define MULTI(X) \
  X( 0), X( 1), X( 2), X( 3), X( 4), X( 5), X( 6), X( 7), X( 8), X( 9), \
  X(10), X(11), X(12), X(13), X(14), X(15), X(16), X(17), X(18), X(19)

#define DECLAREI(INDEX) inc##INDEX = incs[INDEX]
#define DECLAREF(INDEX) *ptr##INDEX = ptrs[INDEX], result##INDEX = 0
#define LOOP(INDEX) result##INDEX += *ptr##INDEX, ptr##INDEX += inc##INDEX
#define COPYOUT(INDEX) results[INDEX] = result##INDEX

float *ptrs[NVARS];
float results[NVARS];
int incs[NVARS];

struct big { int i[0x10000]; };
void __attribute__((noinline))
bar (struct big b)
{
  incs[0] += b.i[0];
}

void __attribute__((noinline))
foo (int n)
{
  struct big b = {};
  int MULTI (DECLAREI);
  float MULTI (DECLAREF);
  while (n--)
    MULTI (LOOP);
  MULTI (COPYOUT);
  bar (b);
}

float input[NITER * NVARS];

int
main (void)
{
  int i;

  for (i = 0; i < NVARS; i++)
    ptrs[i] = input + i, incs[i] = i;
  for (i = 0; i < NITER * NVARS; i++)
    input[i] = i;
  foo (NITER);
  for (i = 0; i < NVARS; i++)
    if (results[i] != i * NITER * (NITER + 1) / 2)
      return 1;
  return 0;
}
// source: pr29006.c
struct __attribute__((__packed__)) s { char c; unsigned long long x; };
void __attribute__((__noinline__)) foo (struct s *s) { s->x = 0; }
int main (void) { struct s s = { 1, ~0ULL }; foo (&s); return s.x != 0; }
// source: pr29156.c
extern void abort(void);
struct test1
{
  int a;
  int b;
};
struct test2
{
  float d;
  struct test1 sub;
};

int global;

int bla(struct test1 *xa, struct test2 *xb)
{
  global = 1;
  xb->sub.a = 1;
  xa->a = 8;
  return xb->sub.a;
}

int main(void)
{
  struct test2 pom;

  if (bla (&pom.sub, &pom) != 8)
    abort ();

  return 0;
}
// source: pr29695-1.c
/* PR middle-end/29695 */

extern void abort (void);

int
f1 (void)
{
  int a = 128;
  return (a & 0x80) ? 0x80 : 0;
}

int
f2 (void)
{
  unsigned char a = 128;
  return (a & 0x80) ? 0x80 : 0;
}

int
f3 (void)
{
  unsigned char a = 128;
  return (a & 0x80) ? 0x380 : 0;
}

int
f4 (void)
{
  unsigned char a = 128;
  return (a & 0x80) ? -128 : 0;
}

long long
f5 (void)
{
  long long a = 0x80000000LL;
  return (a & 0x80000000) ? 0x80000000LL : 0LL;
}

long long
f6 (void)
{
  unsigned int a = 0x80000000;
  return (a & 0x80000000) ? 0x80000000LL : 0LL;
}

long long
f7 (void)
{
  unsigned int a = 0x80000000;
  return (a & 0x80000000) ? 0x380000000LL : 0LL;
}

long long
f8 (void)
{
  unsigned int a = 0x80000000;
  return (a & 0x80000000) ? -2147483648LL : 0LL;
}

int
main (void)
{
  if ((char) 128 != -128 || (int) 0x80000000 != -2147483648)
    return 0;
  if (f1 () != 128)
    abort ();
  if (f2 () != 128)
    abort ();
  if (f3 () != 896)
    abort ();
  if (f4 () != -128)
    abort ();
  if (f5 () != 0x80000000LL)
    abort ();
  if (f6 () != 0x80000000LL)
    abort ();
  if (f7 () != 0x380000000LL)
    abort ();
  if (f8 () != -2147483648LL)
    abort ();
  return 0;
}
// source: pr29695-2.c
/* PR middle-end/29695 */

extern void abort (void);

int a = 128;
unsigned char b = 128;
long long c = 0x80000000LL;
unsigned int d = 0x80000000;

int
f1 (void)
{
  return (a & 0x80) ? 0x80 : 0;
}

int
f2 (void)
{
  return (b & 0x80) ? 0x80 : 0;
}

int
f3 (void)
{
  return (b & 0x80) ? 0x380 : 0;
}

int
f4 (void)
{
  return (b & 0x80) ? -128 : 0;
}

long long
f5 (void)
{
  return (c & 0x80000000) ? 0x80000000LL : 0LL;
}

long long
f6 (void)
{
  return (d & 0x80000000) ? 0x80000000LL : 0LL;
}

long long
f7 (void)
{
  return (d & 0x80000000) ? 0x380000000LL : 0LL;
}

long long
f8 (void)
{
  return (d & 0x80000000) ? -2147483648LL : 0LL;
}

int
main (void)
{
  if ((char) 128 != -128 || (int) 0x80000000 != -2147483648)
    return 0;
  if (f1 () != 128)
    abort ();
  if (f2 () != 128)
    abort ();
  if (f3 () != 896)
    abort ();
  if (f4 () != -128)
    abort ();
  if (f5 () != 0x80000000LL)
    abort ();
  if (f6 () != 0x80000000LL)
    abort ();
  if (f7 () != 0x380000000LL)
    abort ();
  if (f8 () != -2147483648LL)
    abort ();
  return 0;
}
// source: pr29797-1.c
/* { dg-require-effective-target int32plus } */
extern void abort(void);

unsigned int bar(void) { return 32768; }

int main()
{
  unsigned int nStyle = bar ();
  if (nStyle & 32768)
    nStyle |= 65536;
  if (nStyle != (32768 | 65536))
    abort ();
  return 0;
}
// source: pr29797-2.c
extern void abort(void);

unsigned long bar(void) { return 32768; }

int main()
{
  unsigned long nStyle = bar ();
  if (nStyle & 32768)
    nStyle |= 65536;
  if (nStyle != (32768 | 65536))
    abort ();
  return 0;
}
// source: pr29798.c
extern void abort ();

int
main ()
{
  int i;
  double oldrho;
  double beta = 0.0;
  double work = 1.0;
  for (i = 1; i <= 2; i++)
    {
      double rho = work * work;
      if (i != 1)
        beta = rho / oldrho;
      if (beta == 1.0)
        abort ();

      /* All targets even remotely likely to ever get supported
	 use at least an even base, so there will never be any
	 floating-point rounding. All computation in this test
	 case is exact for even bases.  */
      work /= 2.0;
      oldrho = rho;
    }
  return 0;
}
// source: pr30185.c
/* PR target/30185 */

extern void abort (void);

typedef struct S { char a; long long b; } S;

S
foo (S x, S y)
{
  S z;
  z.b = x.b / y.b;
  return z;
}

int
main (void)
{
  S a, b;
  a.b = 32LL;
  b.b = 4LL;
  if (foo (a, b).b != 8LL)
    abort ();
  a.b = -8LL;
  b.b = -2LL;
  if (foo (a, b).b != 4LL)
    abort ();
  return 0;
}
// source: pr30778.c
extern void *memset (void *, int, __SIZE_TYPE__);
extern void abort (void);

struct reg_stat {
  void *last_death;
  void *last_set;
  void *last_set_value;
  int   last_set_label;
  char  last_set_sign_bit_copies;
  int   last_set_mode : 8;
  char  last_set_invalid;
  char sign_bit_copies;
  long nonzero_bits;
};

static struct reg_stat *reg_stat;

void __attribute__((noinline))
init_reg_last (void)
{
  memset (reg_stat, 0, __builtin_offsetof (struct reg_stat, sign_bit_copies));
}

int main (void)
{
  struct reg_stat r;

  reg_stat = &r;
  r.nonzero_bits = -1;
  init_reg_last ();
  if (r.nonzero_bits != -1)
    abort ();
  return 0;
}
// source: pr31072.c
extern volatile int ReadyFlag_NotProperlyInitialized;

volatile int ReadyFlag_NotProperlyInitialized=1;

int main(void)
{
  if (ReadyFlag_NotProperlyInitialized != 1)
    __builtin_abort ();
  return 0;
}
// source: pr31136.c
extern void abort (void);

struct S {
  unsigned b4:4;
  unsigned b6:6;
} s;

int main()
{
  s.b6 = 31;
  s.b4 = s.b6;
  s.b6 = s.b4;
  if (s.b6 != 15)
    abort ();
  return 0;
}
// source: pr31169.c
extern void abort();

#define HOST_WIDE_INT long
#define HOST_BITS_PER_WIDE_INT (sizeof(long)*8)

struct tree_type
{
  unsigned int precision : 9;
};

int
sign_bit_p (struct tree_type *t, HOST_WIDE_INT val_hi, unsigned HOST_WIDE_INT val_lo)
{
  unsigned HOST_WIDE_INT mask_lo, lo;
  HOST_WIDE_INT mask_hi, hi;
  int width = t->precision;

  if (width > HOST_BITS_PER_WIDE_INT)
    {
      hi = (unsigned HOST_WIDE_INT) 1 << (width - HOST_BITS_PER_WIDE_INT - 1);
      lo = 0;

      mask_hi = ((unsigned HOST_WIDE_INT) -1
                 >> (2 * HOST_BITS_PER_WIDE_INT - width));
      mask_lo = -1;
    }
  else
    {
      hi = 0;
      lo = (unsigned HOST_WIDE_INT) 1 << (width - 1);

      mask_hi = 0;
      mask_lo = ((unsigned HOST_WIDE_INT) -1
                 >> (HOST_BITS_PER_WIDE_INT - width));
    }

  if ((val_hi & mask_hi) == hi
      && (val_lo & mask_lo) == lo)
    return 1;

  return 0;
}

int main()
{
  struct tree_type t;
  t.precision = 1;
  if (!sign_bit_p (&t, 0, -1))
    abort ();
  return 0;
}
// source: pr31448-2.c
/* PR middle-end/31448, this used to ICE during expand because
   reduce_to_bit_field_precision was not ready to handle constants. */

typedef struct _st {
    long int iIndex : 24;
    long int iIndex1 : 24;
} st;
st *next;
void g(void)
{
    st *next = 0;
    int nIndx;
    const static int constreg[] = { 0,};
    nIndx = 0;
    next->iIndex = constreg[nIndx];
}
void f(void)
{
    int nIndx;
    const static long int constreg[] = { 0xFEFEFEFE,};
    nIndx = 0;
    next->iIndex = constreg[nIndx];
    next->iIndex1 = constreg[nIndx];
}
int main(void)
{
  st a;
  next = &a;
  f();
  if (next->iIndex != 0xFFFEFEFE)
    __builtin_abort ();
  if (next->iIndex1 != 0xFFFEFEFE)
    __builtin_abort ();
  return 0;
}
// source: pr31448.c
/* PR middle-end/31448, this used to ICE during expand because
   reduce_to_bit_field_precision was not ready to handle constants. */
/* { dg-require-effective-target int32plus } */

typedef struct _st {
    int iIndex : 24;
    int iIndex1 : 24;
} st;
st *next;
void g(void)
{
    st *next = 0;
    int nIndx;
    const static int constreg[] = { 0,};
    nIndx = 0;
    next->iIndex = constreg[nIndx];
}
void f(void)
{
    int nIndx;
    const static int constreg[] = { 0xFEFEFEFE,};
    nIndx = 0;
    next->iIndex = constreg[nIndx];
    next->iIndex1 = constreg[nIndx];
}
int main(void)
{
  st a;
  next = &a;
  f();
  if (next->iIndex != 0xFFFEFEFE)
    __builtin_abort ();
  if (next->iIndex1 != 0xFFFEFEFE)
    __builtin_abort ();
  return 0;
}
// source: pr31605.c
void put_field (unsigned int start, unsigned int len)
{
  int cur_bitshift = ((start + len) % 8) - 8;
  if (cur_bitshift > -8)
    exit (0);
}

int
main ()
{
  put_field (0, 1);
  abort ();
}
// source: pr32244-1.c
struct foo
{
  unsigned long long b:40;
} x;

extern void abort (void);

void test1(unsigned long long res)
{
  /* The shift is carried out in 40 bit precision.  */
  if (x.b<<32 != res)
    abort ();
}

int main()
{
  x.b = 0x0100;
  test1(0);
  return 0;
}
// source: pr32500.c
extern void abort(void);
extern void exit(int);
void foo(int) __attribute__((noinline));
void bar(void) __attribute__((noinline));

/* Make sure foo is not inlined or considered pure/const.  */
int x;
void foo(int i) { x = i; }
void bar(void) { exit(0); }

int
main(int argc, char *argv[])
{
	int i;
	int numbers[4] = { 0xdead, 0xbeef, 0x1337, 0x4242 };

	for (i = 1; i <= 12; i++) {
		if (i <= 4)
			foo(numbers[i-1]);
		else if (i >= 7 && i <= 9)
			bar();
	}

	abort();
}
// source: pr33142.c
int abs(int j);
extern void abort(void);

__attribute__((noinline)) int lisp_atan2(long dy, long dx) {
    if (dx <= 0)
        if (dy > 0)
            return abs(dx) <= abs(dy);
    return 0;
}

int main() {
    volatile long dy = 63, dx = -77;
    if (lisp_atan2(dy, dx))
        abort();
    return 0;
}
// source: pr33382.c
struct Foo {
  int i;
  int j[];
};

struct Foo x = { 1, { 2, 0, 2, 3 } };

int foo(void)
{
  x.j[0] = 1;
  return x.j[1];
}

extern void abort(void);

int main()
{
  if (foo() != 0)
    abort();
  return 0;
}
// source: pr33631.c
typedef union
{
  int __lock;
} pthread_mutex_t;

extern void abort (void);

int main()
{
    struct { int c; pthread_mutex_t m; } r = { .m = 0 };
    if (r.c != 0)
      abort ();
    return 0;
}
// source: pr33669.c
extern void abort (void);

typedef struct foo_t
{
  unsigned int blksz;
  unsigned int bf_cnt;
} foo_t;

#define _RNDUP(x, unit)  ((((x) + (unit) - 1) / (unit)) * (unit))
#define _RNDDOWN(x, unit)  ((x) - ((x)%(unit)))

long long
foo (foo_t *const pxp,  long long offset, unsigned int extent)
{
  long long blkoffset = _RNDDOWN(offset, (long long )pxp->blksz);
  unsigned int diff = (unsigned int)(offset - blkoffset);
  unsigned int blkextent = _RNDUP(diff + extent, pxp->blksz);

  if (pxp->blksz < blkextent)
    return -1LL;

  if (pxp->bf_cnt > pxp->blksz)
    pxp->bf_cnt = pxp->blksz;

  return blkoffset;
}

int
main ()
{
  foo_t x;
  long long xx;

  x.blksz = 8192;
  x.bf_cnt = 0;
  xx = foo (&x, 0, 4096);
  if (xx != 0LL)
    abort ();
  return 0;
}
// source: pr33779-1.c
int foo(int i)
{
  if (((unsigned)(i + 1)) * 4 == 0)
    return 1;
  return 0;
}

extern void abort(void);
int main()
{
  if (foo(0x3fffffff) == 0)
    abort ();
  return 0;
}
// source: pr33779-2.c
int foo(int i)
{
  return ((int)((unsigned)(i + 1) * 4)) / 4;
}

extern void abort(void);
int main()
{
  if (foo(0x3fffffff) != 0)
    abort ();
  return 0;
}
// source: pr33870-1.c
extern void abort (void);

typedef struct PgHdr PgHdr;
typedef unsigned char u8;
struct PgHdr {
int y;
struct {
 unsigned int pgno;
 PgHdr *pNextHash, *pPrevHash;
 PgHdr *pNextFree, *pPrevFree;
 PgHdr *pNextAll;
 u8 inJournal;
 short int nRef;
 PgHdr *pDirty, *pPrevDirty;
 unsigned int notUsed;
} x;
};
PgHdr **xx;
volatile int vx;
static inline PgHdr *merge_pagelist(PgHdr *pA, PgHdr *pB)
{
 PgHdr result;
 PgHdr *pTail;
 xx = &result.x.pDirty;
 pTail = &result;
 while( pA && pB ){
   if( pA->x.pgno<pB->x.pgno ){
     pTail->x.pDirty = pA;
     pTail = pA;
     pA = pA->x.pDirty;
   }else{
     pTail->x.pDirty = pB;
     pTail = pB;
     pB = pB->x.pDirty;
   }
   vx = (*xx)->y;
 }
 if( pA ){
   pTail->x.pDirty = pA;
 }else if( pB ){
   pTail->x.pDirty = pB;
 }else{
   pTail->x.pDirty = 0;
 }
 return result.x.pDirty;
}

PgHdr * __attribute__((noinline)) sort_pagelist(PgHdr *pIn)
{
 PgHdr *a[25], *p;
 int i;
 __builtin_memset (a, 0, sizeof (a));
 while( pIn ){
   p = pIn;
   pIn = p->x.pDirty;
   p->x.pDirty = 0;
   for(i=0; i<25 -1; i++){
     if( a[i]==0 ){
       a[i] = p;
       break;
     }else{
       p = merge_pagelist(a[i], p);
       a[i] = 0;
       a[i] = 0;
     }
   }
   if( i==25 -1 ){
     a[i] = merge_pagelist(a[i], p);
   }
 }
 p = a[0];
 for(i=1; i<25; i++){
   p = merge_pagelist (p, a[i]);
 }
 return p;
}

int main()
{
 PgHdr a[5];
 PgHdr *p;
 a[0].x.pgno = 5;
 a[0].x.pDirty = &a[1];
 a[1].x.pgno = 4;
 a[1].x.pDirty = &a[2];
 a[2].x.pgno = 1;
 a[2].x.pDirty = &a[3];
 a[3].x.pgno = 3;
 a[3].x.pDirty = 0;
 p = sort_pagelist (&a[0]);
 if (p->x.pDirty == p)
   abort ();
 return 0;
}
// source: pr33870.c
extern void abort (void);

typedef struct PgHdr PgHdr;
typedef unsigned char u8;
struct PgHdr {
  unsigned int pgno;
  PgHdr *pNextHash, *pPrevHash;
  PgHdr *pNextFree, *pPrevFree;
  PgHdr *pNextAll;
  u8 inJournal;
  short int nRef;
  PgHdr *pDirty, *pPrevDirty;
  unsigned int notUsed;
};

static inline PgHdr *merge_pagelist(PgHdr *pA, PgHdr *pB)
{
  PgHdr result;
  PgHdr *pTail;
  pTail = &result;
  while( pA && pB ){
    if( pA->pgno<pB->pgno ){
      pTail->pDirty = pA;
      pTail = pA;
      pA = pA->pDirty;
    }else{
      pTail->pDirty = pB;
      pTail = pB;
      pB = pB->pDirty;
    }
  }
  if( pA ){
    pTail->pDirty = pA;
  }else if( pB ){
    pTail->pDirty = pB;
  }else{
    pTail->pDirty = 0;
  }
  return result.pDirty;
}

PgHdr * __attribute__((noinline)) sort_pagelist(PgHdr *pIn)
{
  PgHdr *a[25], *p;
  int i;
  __builtin_memset (a, 0, sizeof (a));
  while( pIn ){
    p = pIn;
    pIn = p->pDirty;
    p->pDirty = 0;
    for(i=0; i<25 -1; i++){
      if( a[i]==0 ){
        a[i] = p;
        break;
      }else{
        p = merge_pagelist(a[i], p);
        a[i] = 0;
      }
    }
    if( i==25 -1 ){
      a[i] = merge_pagelist(a[i], p);
    }
  }
  p = a[0];
  for(i=1; i<25; i++){
    p = merge_pagelist (p, a[i]);
  }
  return p;
}

int main()
{
  PgHdr a[5];
  PgHdr *p;
  a[0].pgno = 5;
  a[0].pDirty = &a[1];
  a[1].pgno = 4;
  a[1].pDirty = &a[2];
  a[2].pgno = 1;
  a[2].pDirty = &a[3];
  a[3].pgno = 3;
  a[3].pDirty = 0;
  p = sort_pagelist (&a[0]);
  if (p->pDirty == p)
    abort ();
  return 0;
}
// source: pr33992.c
extern void abort ();

void __attribute__((noinline))
bar (unsigned long long i)
{
  if (i)
    abort ();
}

static void __attribute__((always_inline))
foo (unsigned long long *r)
{
  int i;

  for (i = 0; ; i++)
    if (*r & ((unsigned long long)1 << (63 - i)))
      break;

  bar (i);
}

void __attribute__((noinline))
do_test (unsigned long long *r)
{
  int i;

  for (i = 0; i < 2; ++i)
    foo (r);
}

int main()
{
  unsigned long long r = 0x8000000000000001ull;

  do_test (&r);
  return 0;
}
// source: pr34070-1.c
extern void abort (void);

int f(unsigned int x)
{
    return ((int)x) % 4;
}

int main()
{
  if (f(-1) != -1)
    abort ();
  return 0;
}
// source: pr34070-2.c
extern void abort (void);

int f(unsigned int x, int n)
{
    return ((int)x) / (1 << n);
}

int main()
{
  if (f(-1, 1) != 0)
    abort ();
  return 0;
}
// source: pr34099-2.c
int test1 (int b, int c)
{
  char x;
  if (b)
    return x / c;
  else
    return 1;
}
int test2 (int b, int c)
{
  int x;
  if (b)
    return x * c;
  else
    return 1;
}
int test3 (int b, int c)
{
  int x;
  if (b)
    return x % c;
  else
    return 1;
}
int test4 (int b, int c)
{
  char x;
  if (b)
    return x == c;
  else
    return 1;
}

extern void abort (void);
int main()
{
  if (test1(1, 1000) != 0)
    abort ();
  if (test2(1, 0) != 0)
    abort ();
  if (test3(1, 1) != 0)
    abort ();
  if (test4(1, 1000) != 0)
    abort ();
  return 0;
}
// source: pr34099.c
int foo (int b, int c)
{
  int x;
  if (b)
    return x & c;
  else
    return 1;
}
extern void abort (void);
int main()
{
  if (foo(1, 0) != 0)
    abort ();
  return 0;
}
// source: pr34130.c
extern void abort (void);
int foo (int i)
{
  return -2 * __builtin_abs(i - 2);
}
int main()
{
  if (foo(1) != -2
      || foo(3) != -2)
    abort ();
  return 0;
}
// source: pr34154.c
int foo( unsigned long long aLL )
{
    switch( aLL )
    {
        case 1000000000000000000ULL ... 9999999999999999999ULL : return 19 ;
        default                                 : return 20 ;
    };
};
extern void abort (void);
int main()
{
    unsigned long long aLL = 1000000000000000000ULL;
    if (foo (aLL) != 19)
	abort ();
    return 0;
}
// source: pr34176.c

typedef __SIZE_TYPE__ size_t;
typedef unsigned int index_ty;
typedef index_ty *index_list_ty;

struct mult_index
{
  index_ty index;
  unsigned int count;
};

struct mult_index_list
{
  struct mult_index *item;
  size_t nitems;
  size_t nitems_max;

  struct mult_index *item2;
  size_t nitems2_max;
};

int __attribute__((noinline))
hash_find_entry (size_t *result)
{
    *result = 2;
    return 0;
}

extern void abort (void);
struct mult_index * __attribute__((noinline))
foo (size_t n)
{
  static count = 0;
  if (count++ > 0)
    abort ();
  return 0;
}

int
main (void)
{
    size_t nitems = 0;

    for (;;)
    {
        size_t list;

        hash_find_entry (&list);
        {
            size_t len2 = list;
            struct mult_index *destptr;
            struct mult_index *dest;
            size_t new_max  = nitems + len2;

            if (new_max != len2)
                break;
            dest = foo (new_max);

            destptr = dest;
            while (len2--)
                destptr++;

            nitems = destptr - dest;
        }
    }

    return 0;
}
// source: pr34415.c
const char *__attribute__((noinline))
foo (const char *p)
{
  const char *end;
  int len = 1;
  for (;;)
    {
      int c = *p;
      c = (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);
      if (c == 'B')
	end = p;
      else if (c == 'A')
	{
	  end = p;
	  do
	    p++;
	  while (*p == '+');
	}
      else
	break;
      p++;
      len++;
    }
  if (len > 2 && *p == ':')
    p = end;
  return p;
}

int
main (void)
{
  const char *input = "Bbb:";
  return foo (input) != input + 2;
}
// source: pr34456.c
/* { dg-skip-if "requires qsort" { freestanding } }  */

#include <stdlib.h>

int __attribute__ ((noinline)) debug (void) { return 1; }
int errors;

struct s { int elt; int (*compare) (int); };

static int
compare (const void *x, const void *y)
{
  const struct s *s1 = x, *s2 = y;
  int (*compare1) (int);
  int elt2;

  compare1 = s1->compare;
  elt2 = s2->elt;
  if (elt2 != 0 && debug () && compare1 (s1->elt) != 0)
    errors++;
  return compare1 (elt2);
}

int bad_compare (int x) { return -x; }
struct s array[2] = { { 1, bad_compare }, { -1, bad_compare } };

int
main (void)
{
  qsort (array, 2, sizeof (struct s), compare);
  return errors == 0;
}
// source: pr34768-1.c
int x;

void __attribute__((noinline)) foo (void)
{
  x = -x;
}
void __attribute__((const,noinline)) bar (void)
{
}

int __attribute__((noinline))
test (int c)
{
  int tmp = x;
  (c ? foo : bar) ();
  return tmp + x;
}

extern void abort (void);
int main()
{
  x = 1;
  if (test (1) != 0)
    abort ();
  return 0;
}
// source: pr34768-2.c
int x;

int __attribute__((noinline)) foo (void)
{
  x = -x;
  return 0;
}
int __attribute__((const,noinline)) bar (void)
{
  return 0;
}

int __attribute__((noinline))
test (int c)
{
  int tmp = x;
  int res = (c ? foo : bar) ();
  return tmp + x + res;
}

extern void abort (void);
int main()
{
  x = 1;
  if (test (1) != 0)
    abort ();
  return 0;
}
// source: pr34971.c
struct foo
{
  unsigned long long b:40;
} x;

extern void abort (void);

void test1(unsigned long long res)
{
  /* Build a rotate expression on a 40 bit argument.  */
  if ((x.b<<8) + (x.b>>32) != res)
    abort ();
}

int main()
{
  x.b = 0x0100000001;
  test1(0x0000000101);
  x.b = 0x0100000000;
  test1(0x0000000001);
  return 0;
}
// source: pr34982.c
extern void abort (void);

static void something();

int main()
{
  something(-1);
  return 0;
}

static void something(int i)
{
  if (i != -1)
    abort ();
}
// source: pr35163.c
extern void abort(void);

int main()
{
  signed char a = -30;
  signed char b = -31;
  #if(__SIZEOF_INT__ >= 4)
  if (a > (unsigned short)b)
#else
  if ((long) a > (unsigned short)b)
#endif
    abort ();
  return 0;
}
// source: pr35231.c
extern void abort(void);

int __attribute__((noinline))
foo(int bits_per_pixel, int depth)
{
  if ((bits_per_pixel | depth) == 1)
    abort ();
  return bits_per_pixel;
}

int main()
{
  if (foo(2, 0) != 2)
    abort ();
  return 0;
}
// source: pr35390.c
extern void abort (void);

unsigned int foo (int n)
{
  return ~((unsigned int)~n);
}

int main()
{
  if (foo(0) != 0)
    abort ();
  return 0;
}
// source: pr35456.c
/* { dg-skip-if "signed zero not supported" { "vax-*-*" } } */
extern void abort (void);

double
__attribute__ ((noinline))
not_fabs (double x)
{
  return x >= 0.0 ? x : -x;
}

int main()
{
  double x = -0.0;
  double y;

  y = not_fabs (x);

  if (!__builtin_signbit (y))
    abort();

  return 0;
}
// source: pr35472.c
extern void abort (void);
extern void *memset (void *s, int c, __SIZE_TYPE__ n);
struct S { int i[16]; };
struct S *p;
void __attribute__((noinline,noclone))
foo(struct S *a, struct S *b) { a->i[0] = -1; p = b; }
void test (void)
{
  struct S a, b;
  memset (&a.i[0], '\0', sizeof (a.i));
  memset (&b.i[0], '\0', sizeof (b.i));
  foo (&a, &b);
  *p = a;
  *p = b;
  if (b.i[0] != -1)
    abort ();
}
int main()
{
  test();
  return 0;
}
// source: pr35800.c
extern void abort (void);

int stab_xcoff_builtin_type (int typenum)
{
  const char *name;
  if (typenum >= 0 || typenum < -34)
    {
      return 0;
    }
  switch (-typenum)
    {
    case 1:
      name = "int";
      break;
    case 2:
      name = "char";
    case 3:
      name = "short";
      break;
    case 4:
      name = "long";
    case 5:
      name = "unsigned char";
    case 6:
      name = "signed char";
    case 7:
      name = "unsigned short";
    case 8:
      name = "unsigned int";
    case 9:
      name = "unsigned";
    case 10:
      name = "unsigned long";
    case 11:
      name = "void";
    case 12:
      name = "float";
    case 13:
      name = "double";
    case 14:
      name = "long double";
    case 15:
      name = "integer";
    case 16:
      name = "boolean";
    case 17:
      name = "short real";
    case 18:
      name = "real";
    case 19:
      name = "stringptr";
    case 20:
      name = "character";
    case 21:
      name = "logical*1";
    case 22:
      name = "logical*2";
    case 23:
      name = "logical*4";
    case 24:
      name = "logical";
    case 25:
      name = "complex";
    case 26:
      name = "double complex";
    case 27:
      name = "integer*1";
    case 28:
      name = "integer*2";
    case 29:
      name = "integer*4";
    case 30:
      name = "wchar";
    case 31:
      name = "long long";
    case 32:
      name = "unsigned long long";
    case 33:
      name = "logical*8";
    case 34:
      name = "integer*8";
    }
  return name[0];
}

int main()
{
  int i;
  if (stab_xcoff_builtin_type(0) != 0)
    abort ();
  if (stab_xcoff_builtin_type(-1) != 'i')
    abort ();
  if (stab_xcoff_builtin_type(-2) != 's')
    abort ();
  if (stab_xcoff_builtin_type(-3) != 's')
    abort ();
  for (i = -4; i >= -34; --i)
    if (stab_xcoff_builtin_type(i) != 'i')
      abort ();
  if (stab_xcoff_builtin_type(-35) != 0)
    abort ();
  return 0;
}
// source: pr36034-1.c
double x[5][10] = { { 10, 11, 12, 13, 14, 15, -1, -1, -1, -1 },
                    { 21, 22, 23, 24, 25, 26, -1, -1, -1, -1 },
                    { 32, 33, 34, 35, 36, 37, -1, -1, -1, -1 },
                    { 43, 44, 45, 46, 47, 48, -1, -1, -1, -1 },
                    { 54, 55, 56, 57, 58, 59, -1, -1, -1, -1 } };
double tmp[5][6];

void __attribute__((noinline))
test (void)
{
  int i, j;
  for (i = 0; i < 5; ++i)
    {
      tmp[i][0] = x[i][0];
      tmp[i][1] = x[i][1];
      tmp[i][2] = x[i][2];
      tmp[i][3] = x[i][3];
      tmp[i][4] = x[i][4];
      tmp[i][5] = x[i][5];
    }
}
extern void abort (void);
int main()
{
  int i, j;
  test();
  for (i = 0; i < 5; ++i)
    for (j = 0; j < 6; ++j)
      if (tmp[i][j] == -1)
        abort ();
  return 0;
}
// source: pr36034-2.c
double x[50] = { 10, 11, 12, 13, 14, 15, -1, -1, -1, -1,
                 21, 22, 23, 24, 25, 26, -1, -1, -1, -1,
                 32, 33, 34, 35, 36, 37, -1, -1, -1, -1,
                 43, 44, 45, 46, 47, 48, -1, -1, -1, -1,
                 54, 55, 56, 57, 58, 59, -1, -1, -1, -1 };
double tmp[30];

void __attribute__((noinline))
test (void)
{
  int i, j;
  for (i = 0; i < 5; ++i)
    {
      tmp[i*6] = x[i*10];
      tmp[i*6+1] = x[i*10+1];
      tmp[i*6+2] = x[i*10+2];
      tmp[i*6+3] = x[i*10+3];
      tmp[i*6+4] = x[i*10+4];
      tmp[i*6+5] = x[i*10+5];
    }
}
extern void abort (void);
int main()
{
  int i, j;
  test();
  for (i = 0; i < 5; ++i)
    for (j = 0; j < 6; ++j)
      if (tmp[i*6+j] == -1)
        abort ();
  return 0;
}
// source: pr36038.c
/* PR tree-optimization/36038 */

long long list[10];
long long expect[10] = { 0, 1, 2, 3, 4, 4, 5, 6, 7, 9 };
long long *stack_base;
int indices[10];
int *markstack_ptr;

void
doit (void)
{
  long long *src;
  long long *dst;
  long long *sp = stack_base + 5;
  int diff = 2;
  int shift;
  int count;

  shift = diff - (markstack_ptr[-1] - markstack_ptr[-2]);
  count = (sp - stack_base) - markstack_ptr[-1] + 2;
  src = sp;
  dst = (sp += shift);
  while (--count)
    *dst-- = *src--;
}

int
main ()
{
  int i;
  for (i = 0; i < 10; i++)
    list[i] = i;

  markstack_ptr = indices + 9;
  markstack_ptr[-1] = 2;
  markstack_ptr[-2] = 1;

  stack_base = list + 2;
  doit ();
  if (__builtin_memcmp (expect, list, sizeof (list)))
    __builtin_abort ();
  return 0;
}
// source: pr36077.c
extern void abort (void);

unsigned int test (unsigned int x)
{
  return x / 0x80000001U / 0x00000002U;
}

int main()
{
  if (test(2) != 0)
    abort ();
  return 0;
}
// source: pr36093.c
/* { dg-skip-if "small alignment" { pdp11-*-* } } */

extern void abort (void);

typedef struct Bar {
      char c[129];
} Bar __attribute__((__aligned__(128)));

typedef struct Foo {
      Bar bar[4];
} Foo;

Foo foo[4];

int main()
{
   int i, j;
   Foo *foop = &foo[0];

   for (i=0; i < 4; i++) {
      Bar *bar = &foop->bar[i];
      for (j=0; j < 129; j++) {
         bar->c[j] = 'a' + i;
      }
   }

   if (foo[0].bar[3].c[128] != 'd')
     abort ();
   return 0;
}
// source: pr36321.c
/* { dg-skip-if "requires alloca" { ! alloca } { "-O0" } { "" } } */
extern void abort (void);

extern __SIZE_TYPE__ strlen (const char *);
void foo(char *str)
{
  int len2 = strlen (str);
  char *a = (char *) __builtin_alloca (0);
  char *b = (char *) __builtin_alloca (len2*3);

  if ((int) (a-b) < (len2*3))
    {
#ifdef _WIN32
      abort ();
#endif
      return;
    }
}

static char * volatile argp = "pr36321.x";

int main(int argc, char **argv)
{
  foo (argp);
  return 0;
}
// source: pr36339.c
extern void abort (void);

typedef unsigned long my_uintptr_t;

int check_a(my_uintptr_t tagged_ptr);

int __attribute__((noinline)) try_a(my_uintptr_t x)
{
  my_uintptr_t heap[2];
  my_uintptr_t *hp = heap;

  hp[0] = x;
  hp[1] = 0;
  return check_a((my_uintptr_t)(void*)((char*)hp + 1));
}

int __attribute__((noinline)) check_a(my_uintptr_t tagged_ptr)
{
  my_uintptr_t *hp = (my_uintptr_t*)(void*)((char*)tagged_ptr - 1);

  if (hp[0] == 42 && hp[1] == 0)
    return 0;
  return -1;
}

int main(void)
{
  if (try_a(42) < 0)
    abort ();
  return 0;
}
// source: pr36343.c
extern void abort (void);

void __attribute__((noinline))
bar (int **p)
{
  float *q = (float *)p;
  *q = 0.0;
}

float __attribute__((noinline))
foo (int b)
{
  int *i = 0;
  float f = 1.0;
  int **p;
  if (b)
    p = &i;
  else
    p = (int **)&f;
  bar (p);
  if (b)
    return **p;
  return f;
}

int main()
{
  if (foo(0) != 0.0)
    abort ();
  return 0;
}
// source: pr36691.c
unsigned char g_5;

void func_1 (void)
{
  for (g_5 = 9; g_5 >= 4; g_5 -= 5)
    ;
}

extern void abort (void);
int main (void)
{
  func_1 ();
  if (g_5 != 0)
    abort ();
  return 0;
}
// source: pr36765.c
int __attribute__((noinline))
foo(int i)
{
  int *p = __builtin_malloc (4 * sizeof(int));
  *p = 0;
  p[i] = 1;
  return *p;
}
extern void abort (void);
int main()
{
  if (foo(0) != 1)
    abort ();
  return 0;
}
// source: pr37102.c
extern void abort (void);

unsigned int a, b = 1, c;

void __attribute__ ((noinline))
foo (int x)
{
  if (x != 5)
    abort ();
}

int
main ()
{
  unsigned int d, e;
  for (d = 1; d < 5; d++)
    if (c)
      a = b;
  a = b;
  e = a << 1;
  if (e)
    e = (e << 1) ^ 1;
  foo (e);
  return 0;
}
// source: pr37125.c
extern void abort (void);

static inline unsigned int
mod_rhs(int rhs)
{
  if (rhs == 0) return 1;
  return rhs;
}

void func_44 (unsigned int p_45);
void func_44 (unsigned int p_45)
{
  if (!((p_45 * -9) % mod_rhs (-9))) {
      abort();
  }
}

int main (void)
{
  func_44 (2);
  return 0;
}
// source: pr37573.c
/* PR tree-optimization/37573 */
/* { dg-require-effective-target int32plus } */

struct S
{
  unsigned int *a;
  unsigned int b;
  unsigned int c[624];
};

static unsigned char __attribute__((noinline))
foo (struct S *s)
{
  unsigned int r;
  if (!--s->b)
    {
      unsigned int *c = s->c;
      unsigned int i;
      s->a = c;
      for (i = 0; i < 227; i++)
	c[i] = ((((c[i] ^ c[i + 1]) & 0x7ffffffe) ^ c[i]) >> 1)
	    ^ ((0 - (c[i + 1] & 1)) & 0x9908b0df) ^ c[i + 397];
    }
  r = *(s->a++);
  r ^= (r >> 11);
  r ^= ((r & 0xff3a58ad) << 7);
  r ^= ((r & 0xffffdf8c) << 15);
  r ^= (r >> 18);
  return (unsigned char) (r >> 1);
}

static void __attribute__((noinline))
bar (unsigned char *p, unsigned int q, unsigned int r)
{
  struct S s;
  unsigned int i;
  unsigned int *c = s.c;
  *c = r;
  for (i = 1; i < 624; i++)
    c[i] = i + 0x6c078965 * ((c[i - 1] >> 30) ^ c[i - 1]);
  s.b = 1;
  while (q--)
    *p++ ^= foo (&s);
};

static unsigned char p[23] = {
  0xc0, 0x49, 0x17, 0x32, 0x62, 0x1e, 0x2e, 0xd5, 0x4c, 0x19, 0x28, 0x49,
  0x91, 0xe4, 0x72, 0x83, 0x91, 0x3d, 0x93, 0x83, 0xb3, 0x61, 0x38
};

static unsigned char q[23] = {
  0x3e, 0x41, 0x55, 0x54, 0x4f, 0x49, 0x54, 0x20, 0x55, 0x4e, 0x49, 0x43,
  0x4f, 0x44, 0x45, 0x20, 0x53, 0x43, 0x52, 0x49, 0x50, 0x54, 0x3c
};

int
main (void)
{
  unsigned int s;
  s = 23;
  bar (p, s, s + 0xa25e);
  if (__builtin_memcmp (p, q, s) != 0)
    __builtin_abort ();
  return 0;
}
// source: pr37780.c
/* PR middle-end/37780.  */

#define VAL (8 * sizeof (int))

int __attribute__ ((noinline, noclone))
fooctz (int i)
{
  return (i == 0) ? VAL : __builtin_ctz (i);
}

int __attribute__ ((noinline, noclone))
fooctz2 (int i)
{
  return (i != 0) ? __builtin_ctz (i) : VAL;
}

unsigned int __attribute__ ((noinline, noclone))
fooctz3 (unsigned int i)
{
  return (i > 0) ?  __builtin_ctz (i) : VAL;
}

int __attribute__ ((noinline, noclone))
fooclz (int i)
{
  return (i == 0) ? VAL : __builtin_clz (i);
}

int __attribute__ ((noinline, noclone))
fooclz2 (int i)
{
  return (i != 0) ? __builtin_clz (i) : VAL;
}

unsigned int __attribute__ ((noinline, noclone))
fooclz3 (unsigned int i)
{
  return (i > 0) ? __builtin_clz (i) : VAL;
}

int
main (void)
{
  if (fooctz (0) != VAL || fooctz2 (0) != VAL || fooctz3 (0) != VAL
      || fooclz (0) != VAL || fooclz2 (0) != VAL || fooclz3 (0) != VAL)
    __builtin_abort ();

  return 0;
}// source: pr37882.c
/* PR middle-end/37882 */

struct S
{
  unsigned char b : 3;
} s;

int
main ()
{
  s.b = 4;
  if (s.b > 0 && s.b < 4)
    __builtin_abort ();
  return 0;
}
// source: pr37924.c
/* PR c/37924 */

extern void abort (void);

signed char a;
unsigned char b;

int
test1 (void)
{
  int c = -1;
  return ((unsigned int) (a ^ c)) >> 9;
}

int
test2 (void)
{
  int c = -1;
  return ((unsigned int) (b ^ c)) >> 9;
}

int
main (void)
{
  a = 0;
  if (test1 () != (-1U >> 9))
    abort ();
  a = 0x40;
  if (test1 () != (-1U >> 9))
    abort ();
  a = 0x80;
  if (test1 () != (a < 0) ? 0 : (-1U >> 9))
    abort ();
  a = 0xff;
  if (test1 () != (a < 0) ? 0 : (-1U >> 9))
    abort ();
  b = 0;
  if (test2 () != (-1U >> 9))
    abort ();
  b = 0x40;
  if (test2 () != (-1U >> 9))
    abort ();
  b = 0x80;
  if (test2 () != (-1U >> 9))
    abort ();
  b = 0xff;
  if (test2 () != (-1U >> 9))
    abort ();
  return 0;
}
// source: pr37931.c
/* PR middle-end/37931 */

extern void abort (void);

int
foo (int a, unsigned int b)
{
  return (a | 1) & (b | 1);
}

int
main (void)
{
  if (foo (6, 0xc6) != 7)
    abort ();
  if (foo (0x80, 0xc1) != 0x81)
    abort ();
  if (foo (4, 4) != 5)
    abort ();
  if (foo (5, 4) != 5)
    abort ();
  return 0;
}
// source: pr38048-1.c
extern void abort(void);

int foo ()
{
  int mat[2][1];
  int (*a)[1] = mat;
  int det = 0;
  int i;
  mat[0][0] = 1;
  mat[1][0] = 2;
  for (i = 0; i < 2; ++i)
    det += a[i][0];
  return det;
}

int main()
{
  if (foo () != 3)
    abort ();
  return 0;
}
// source: pr38048-2.c
extern void abort (void);

static int inv_J(int a[][2])
{
  int i, j;
  int det = 0.0;
   for (j=0; j<2; ++j)
     det += a[j][0] + a[j][1];
  return det;
}

int foo()
{
  int mat[2][2];
  mat[0][0] = 1;
  mat[0][1] = 2;
  mat[1][0] = 4;
  mat[1][1] = 8;
  return inv_J(mat);
}

int main()
{
  if (foo () != 15)
    abort ();
  return 0;
}
// source: pr38051.c
typedef __SIZE_TYPE__ size_t;
static int mymemcmp1 (unsigned long int, unsigned long int)
  __attribute__ ((__nothrow__));

__inline static int
mymemcmp1 (unsigned long int a, unsigned long int b)
{
  long int srcp1 = (long int) &a;
  long int srcp2 = (long int) &b;
  unsigned long int a0, b0;
  do
    {
      a0 = ((unsigned char *) srcp1)[0];
      b0 = ((unsigned char *) srcp2)[0];
      srcp1 += 1;
      srcp2 += 1;
    }
  while (a0 == b0);
  return a0 - b0;
}

static int mymemcmp2 (long, long, size_t) __attribute__ ((__nothrow__));

static int
mymemcmp2 (long int srcp1, long int srcp2, size_t len)
{
  unsigned long int a0, a1;
  unsigned long int b0, b1;
  switch (len % 4)
    {
    default:
    case 2:
      a0 = ((unsigned long int *) srcp1)[0];
      b0 = ((unsigned long int *) srcp2)[0];
      srcp1 -= 2 * (sizeof (unsigned long int));
      srcp2 -= 2 * (sizeof (unsigned long int));
      len += 2;
      goto do1;
    case 3:
      a1 = ((unsigned long int *) srcp1)[0];
      b1 = ((unsigned long int *) srcp2)[0];
      srcp1 -= (sizeof (unsigned long int));
      srcp2 -= (sizeof (unsigned long int));
      len += 1;
      goto do2;
    case 0:
      if (16 <= 3 * (sizeof (unsigned long int)) && len == 0)
        return 0;
      a0 = ((unsigned long int *) srcp1)[0];
      b0 = ((unsigned long int *) srcp2)[0];
      goto do3;
    case 1:
      a1 = ((unsigned long int *) srcp1)[0];
      b1 = ((unsigned long int *) srcp2)[0];
      srcp1 += (sizeof (unsigned long int));
      srcp2 += (sizeof (unsigned long int));
      len -= 1;
      if (16 <= 3 * (sizeof (unsigned long int)) && len == 0)
        goto do0;
    }
  do
    {
      a0 = ((unsigned long int *) srcp1)[0];
      b0 = ((unsigned long int *) srcp2)[0];
      if (a1 != b1)
        return mymemcmp1 ((a1), (b1));
    do3:
      a1 = ((unsigned long int *) srcp1)[1];
      b1 = ((unsigned long int *) srcp2)[1];
      if (a0 != b0)
        return mymemcmp1 ((a0), (b0));
    do2:
      a0 = ((unsigned long int *) srcp1)[2];
      b0 = ((unsigned long int *) srcp2)[2];
      if (a1 != b1)
        return mymemcmp1 ((a1), (b1));
    do1:
      a1 = ((unsigned long int *) srcp1)[3];
      b1 = ((unsigned long int *) srcp2)[3];
      if (a0 != b0)
        return mymemcmp1 ((a0), (b0));
      srcp1 += 4 * (sizeof (unsigned long int));
      srcp2 += 4 * (sizeof (unsigned long int));
      len -= 4;
    }
  while (len != 0);
do0:
  if (a1 != b1)
    return mymemcmp1 ((a1), (b1));
  return 0;
}

static int mymemcmp3 (long, long, size_t) __attribute__ ((__nothrow__));

static int
mymemcmp3 (long int srcp1, long int srcp2, size_t len)
{
  unsigned long int a0, a1, a2, a3;
  unsigned long int b0, b1, b2, b3;
  unsigned long int x;
  int shl, shr;
  shl = 8 * (srcp1 % (sizeof (unsigned long int)));
  shr = 8 * (sizeof (unsigned long int)) - shl;
  srcp1 &= -(sizeof (unsigned long int));
  switch (len % 4)
    {
    default:
    case 2:
      a1 = ((unsigned long int *) srcp1)[0];
      a2 = ((unsigned long int *) srcp1)[1];
      b2 = ((unsigned long int *) srcp2)[0];
      srcp1 -= 1 * (sizeof (unsigned long int));
      srcp2 -= 2 * (sizeof (unsigned long int));
      len += 2;
      goto do1;
    case 3:
      a0 = ((unsigned long int *) srcp1)[0];
      a1 = ((unsigned long int *) srcp1)[1];
      b1 = ((unsigned long int *) srcp2)[0];
      srcp2 -= 1 * (sizeof (unsigned long int));
      len += 1;
      goto do2;
    case 0:
      if (16 <= 3 * (sizeof (unsigned long int)) && len == 0)
        return 0;
      a3 = ((unsigned long int *) srcp1)[0];
      a0 = ((unsigned long int *) srcp1)[1];
      b0 = ((unsigned long int *) srcp2)[0];
      srcp1 += 1 * (sizeof (unsigned long int));
      goto do3;
    case 1:
      a2 = ((unsigned long int *) srcp1)[0];
      a3 = ((unsigned long int *) srcp1)[1];
      b3 = ((unsigned long int *) srcp2)[0];
      srcp1 += 2 * (sizeof (unsigned long int));
      srcp2 += 1 * (sizeof (unsigned long int));
      len -= 1;
      if (16 <= 3 * (sizeof (unsigned long int)) && len == 0)
        goto do0;
    }
  do
    {
      a0 = ((unsigned long int *) srcp1)[0];
      b0 = ((unsigned long int *) srcp2)[0];
      x = (((a2) >> (shl)) | ((a3) << (shr)));
      if (x != b3)
        return mymemcmp1 ((x), (b3));
    do3:
      a1 = ((unsigned long int *) srcp1)[1];
      b1 = ((unsigned long int *) srcp2)[1];
      x = (((a3) >> (shl)) | ((a0) << (shr)));
      if (x != b0)
        return mymemcmp1 ((x), (b0));
    do2:
      a2 = ((unsigned long int *) srcp1)[2];
      b2 = ((unsigned long int *) srcp2)[2];
      x = (((a0) >> (shl)) | ((a1) << (shr)));
      if (x != b1)
        return mymemcmp1 ((x), (b1));
    do1:
      a3 = ((unsigned long int *) srcp1)[3];
      b3 = ((unsigned long int *) srcp2)[3];
      x = (((a1) >> (shl)) | ((a2) << (shr)));
      if (x != b2)
        return mymemcmp1 ((x), (b2));
      srcp1 += 4 * (sizeof (unsigned long int));
      srcp2 += 4 * (sizeof (unsigned long int));
      len -= 4;
    }
  while (len != 0);
do0:
  x = (((a2) >> (shl)) | ((a3) << (shr)));
  if (x != b3)
    return mymemcmp1 ((x), (b3));
  return 0;
}

__attribute__ ((noinline))
int mymemcmp (const void *s1, const void *s2, size_t len)
{
  unsigned long int a0;
  unsigned long int b0;
  long int srcp1 = (long int) s1;
  long int srcp2 = (long int) s2;
  if (srcp1 % (sizeof (unsigned long int)) == 0)
    return mymemcmp2 (srcp1, srcp2, len / (sizeof (unsigned long int)));
  else
    return mymemcmp3 (srcp1, srcp2, len / (sizeof (unsigned long int)));
}

char buf[256];

int
main (void)
{
  char *p;
  union { long int l; char c[sizeof (long int)]; } u;

  /* The test above assumes little endian and long being the same size
     as pointer.  */
  if (sizeof (long int) != sizeof (void *) || sizeof (long int) < 4)
    return 0;
  u.l = 0x12345678L;
  if (u.c[0] != 0x78 || u.c[1] != 0x56 || u.c[2] != 0x34 || u.c[3] != 0x12)
    return 0;

  p = buf + 16 - (((long int) buf) & 15);
  __builtin_memcpy (p + 9,
"\x1\x37\x82\xa7\x55\x49\x9d\xbf\xf8\x44\xb6\x55\x17\x8e\xf9", 15);
  __builtin_memcpy (p + 128 + 24,
"\x1\x37\x82\xa7\x55\x49\xd0\xf3\xb7\x2a\x6d\x23\x71\x49\x6a", 15);
  if (mymemcmp (p + 9, p + 128 + 24, 33) != -51)
    __builtin_abort ();
  return 0;
}
// source: pr38151.c
/* { dg-options "-Wno-psabi" } */
/* { dg-require-effective-target int32plus } */
void abort (void);

struct S2848
{
  unsigned int a;
  _Complex int b;
  struct
  {
  } __attribute__ ((aligned)) c;
};

struct S2848 s2848;

int fails;

void  __attribute__((noinline))
check2848va (int z, ...)
{
  struct S2848 arg;
  __builtin_va_list ap;

  __builtin_va_start (ap, z);

  arg = __builtin_va_arg (ap, struct S2848);

  if (s2848.a != arg.a)
    ++fails;
  if (s2848.b != arg.b)
    ++fails;

  __builtin_va_end (ap);
}

int main (void)
{
  s2848.a = 4027477739U;
  s2848.b = (723419448 + -218144346 * __extension__ 1i);

  check2848va (1, s2848);

  if (fails)
    abort ();

  return 0;
}
// source: pr38212.c
int __attribute__((noinline))
foo (int *__restrict p, int i)
{
  int *__restrict q;
  int *__restrict r;
  int v, w;
  q = p + 1;
  r = q - i;
  v = *r;
  *p = 1;
  w = *r;
  return v + w;
}
extern void abort (void);
int main()
{
  int i = 0;
  if (foo (&i, 1) != 1)
    abort ();
  return 0;
}
// source: pr38236.c
struct X { int i; };

int __attribute__((noinline))
foo (struct X *p, int *q, int a, int b)
{
  struct X x, y;
  if (a)
    p = &x;
  if (b)
    q = &x.i;
  else
    q = &y.i;
  *q = 1;
  return p->i;
}
extern void abort (void);
int main()
{
  if (foo((void *)0, (void *)0, 1, 1) != 1)
    abort ();
  return 0;
}
// source: pr38422.c
/* PR middle-end/38422 */

extern void abort (void);

struct S
{
  int s : (sizeof (int) * __CHAR_BIT__ - 2);
} s;

void
foo (void)
{
  s.s *= 2;
}

int
main ()
{
  s.s = 24;
  foo ();
  if (s.s != 48)
    abort ();
  return 0;
}
// source: pr38533.c
/* PR middle-end/38533 */

#define A asm volatile ("" : "=r" (f) : "0" (0)); e |= f;
#define B A A A A A A A A A A A
#define C B B B B B B B B B B B

int
foo (void)
{
  int e = 0, f;
  C C B B B B B A A A A A A
  return e;
}

int
main (void)
{
  if (foo ())
    __builtin_abort ();
  return 0;
}
// source: pr38819.c
extern void exit (int);
extern void abort (void);

volatile int a = 1;
volatile int b = 0;
volatile int x = 2;
volatile signed int r = 8;

void __attribute__((noinline))
foo (void)
{
  exit (0);
}

int
main (void)
{
  int si1 = a;
  int si2 = b;
  int i;

  for (i = 0; i < 100; ++i) {
      foo ();
      if (x == 8)
	i++;
      r += i + si1 % si2;
  }
  abort ();
}
// source: pr38969.c
__complex__ float
__attribute__ ((noinline)) foo (__complex__ float x)
{
  return x;
}

__complex__ float
__attribute__ ((noinline)) bar (__complex__ float x)
{
  return foo (x);
}

int main()
{
  __complex__ float a, b;
  __real__ a = 9;
  __imag__ a = 42;

  b = bar (a);

  if (a != b)
    abort ();

  return 0;
}
// source: pr39100.c
/* Bad PTA results (incorrect store handling) was causing us to delete
   *na = 0 store.  */

typedef struct E
{
  int p;
  struct E *n;
} *EP;

typedef struct C
{
  EP x;
  short cn, cp;
} *CP;

__attribute__((noinline)) CP
foo (CP h, EP x)
{
  EP pl = 0, *pa = &pl;
  EP nl = 0, *na = &nl;
  EP n;

  while (x)
    {
      n = x->n;
      if ((x->p & 1) == 1)
        {
          h->cp++;
          *pa = x;
          pa = &((*pa)->n);
        }
      else
        {
          h->cn++;
          *na = x;
          na = &((*na)->n);
        }
      x = n;
    }
  *pa = nl;
  *na = 0;
  h->x = pl;
  return h;
}

int
main (void)
{
  struct C c = { 0, 0, 0 };
  struct E e[2] = { { 0, &e[1] }, { 1, 0 } };
  EP p;

  foo (&c, &e[0]);
  if (c.cn != 1 || c.cp != 1)
    __builtin_abort ();
  if (c.x != &e[1])
    __builtin_abort ();
  if (e[1].n != &e[0])
    __builtin_abort ();
  if (e[0].n)
    __builtin_abort ();
  return 0;
}
// source: pr39120.c
struct X { int *p; } x;

struct X __attribute__((noinline))
foo(int *p) { struct X x; x.p = p; return x; }

void __attribute((noinline))
bar() { *x.p = 1; }

extern void abort (void);
int main()
{
  int i = 0;
  x = foo(&i);
  bar();
  if (i != 1)
    abort ();
  return 0;
}
// source: pr39228.c
/* { dg-add-options ieee } */
/* { dg-skip-if "No Inf/NaN support" { spu-*-* } } */

extern void abort (void);

static inline int __attribute__((always_inline)) testf (float b)
{
  float c = 1.01f * b;

  return __builtin_isinff (c);
}

static inline int __attribute__((always_inline)) test (double b)
{
  double c = 1.01 * b;

  return __builtin_isinf (c);
}

static inline int __attribute__((always_inline)) testl (long double b)
{
  long double c = 1.01L * b;

  return __builtin_isinfl (c);
}

int main()
{
  if (testf (__FLT_MAX__) < 1)
    abort ();

  if (test (__DBL_MAX__) < 1)
    abort ();

  if (testl (__LDBL_MAX__) < 1)
    abort ();

  return 0;
}
// source: pr39233.c
extern void abort (void);

__attribute__((noinline)) void
foo (void *p)
{
  long l = (long) p;
  if (l < 0 || l > 6)
    abort ();
}

int
main ()
{
  short i;
  for (i = 6; i >= 0; i--)
    foo ((void *) (long) i);
  return 0;
}
// source: pr39240.c
/* PR target/39240 */

extern void abort (void);

__attribute__ ((noinline))
static int foo1 (int x)
{
  return x;
}

__attribute__ ((noinline))
unsigned int bar1 (int x)
{
  return foo1 (x + 6);
}

volatile unsigned long l1 = (unsigned int) -4;

__attribute__ ((noinline))
static short int foo2 (int x)
{
  return x;
}

__attribute__ ((noinline))
unsigned short int bar2 (int x)
{
  return foo2 (x + 6);
}

volatile unsigned long l2 = (unsigned short int) -4;

__attribute__ ((noinline))
static signed char foo3 (int x)
{
  return x;
}

__attribute__ ((noinline))
unsigned char bar3 (int x)
{
  return foo3 (x + 6);
}

volatile unsigned long l3 = (unsigned char) -4;

__attribute__ ((noinline))
static unsigned int foo4 (int x)
{
  return x;
}

__attribute__ ((noinline))
int bar4 (int x)
{
  return foo4 (x + 6);
}

volatile unsigned long l4 = (int) -4;

__attribute__ ((noinline))
static unsigned short int foo5 (int x)
{
  return x;
}

__attribute__ ((noinline))
short int bar5 (int x)
{
  return foo5 (x + 6);
}

volatile unsigned long l5 = (short int) -4;

__attribute__ ((noinline))
static unsigned char foo6 (int x)
{
  return x;
}

__attribute__ ((noinline))
signed char bar6 (int x)
{
  return foo6 (x + 6);
}

volatile unsigned long l6 = (signed char) -4;

int
main (void)
{
  if (bar1 (-10) != l1)
    abort ();
  if (bar2 (-10) != l2)
    abort ();
  if (bar3 (-10) != l3)
    abort ();
  if (bar4 (-10) != l4)
    abort ();
  if (bar5 (-10) != l5)
    abort ();
  if (bar6 (-10) != l6)
    abort ();
  return 0;
}
// source: pr39339.c
struct C
{
  unsigned int c;
  struct D
  {
    unsigned int columns : 4;
    unsigned int fore : 12;
    unsigned int back : 6;
    unsigned int fragment : 1;
    unsigned int standout : 1;
    unsigned int underline : 1;
    unsigned int strikethrough : 1;
    unsigned int reverse : 1;
    unsigned int blink : 1;
    unsigned int half : 1;
    unsigned int bold : 1;
    unsigned int invisible : 1;
    unsigned int pad : 1;
  } attr;
};

struct A
{
  struct C *data;
  unsigned int len;
};

struct B
{
  struct A *cells;
  unsigned char soft_wrapped : 1;
};

struct E
{
  long row, col;
  struct C defaults;
};

__attribute__ ((noinline))
void foo (struct E *screen, unsigned int c, int columns, struct B *row)
{
  struct D attr;
  long col;
  int i;
  col = screen->col;
  attr = screen->defaults.attr;
  attr.columns = columns;
  row->cells->data[col].c = c;
  row->cells->data[col].attr = attr;
  col++;
  attr.fragment = 1;
  for (i = 1; i < columns; i++)
    {
      row->cells->data[col].c = c;
      row->cells->data[col].attr = attr;
      col++;
    }
}

int
main (void)
{
  struct E e = {.row = 5,.col = 0,.defaults =
      {6, {-1, -1, -1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0}} };
  struct C c[4];
  struct A a = { c, 4 };
  struct B b = { &a, 1 };
  struct D d;
  __builtin_memset (&c, 0, sizeof c);
  foo (&e, 65, 2, &b);
  d = e.defaults.attr;
  d.columns = 2;
  if (__builtin_memcmp (&d, &c[0].attr, sizeof d))
    __builtin_abort ();
  d.fragment = 1;
  if (__builtin_memcmp (&d, &c[1].attr, sizeof d))
    __builtin_abort ();
  return 0;
}
// source: pr39501.c
/* { dg-options "-ffast-math" } */

extern void abort (void);
extern void exit (int);

#define min1(a,b) ((a) < (b) ? (a) : (b))
#define max1(a,b) ((a) > (b) ? (a) : (b))

#define min2(a,b) ((a) <= (b) ? (a) : (b))
#define max2(a,b) ((a) >= (b) ? (a) : (b))

#define F(type,n)						\
  type __attribute__((noinline)) type##_##n(type a, type b)	\
  {								\
    return n(a, b);						\
  }

F(float,min1)
F(float,min2)
F(float,max1)
F(float,max2)

F(double,min1)
F(double,min2)
F(double,max1)
F(double,max2)

int main()
{
  if (float_min1(0.f, -1.f) != -1.f) abort();
  if (float_min1(-1.f, 0.f) != -1.f) abort();
  if (float_min1(0.f, 1.f)  != 0.f)  abort();
  if (float_min1(1.f, 0.f)  != 0.f)  abort();
  if (float_min1(-1.f, 1.f) != -1.f) abort();
  if (float_min1(1.f, -1.f) != -1.f) abort();

  if (float_max1(0.f, -1.f) != 0.f)  abort();
  if (float_max1(-1.f, 0.f) != 0.f)  abort();
  if (float_max1(0.f, 1.f)  != 1.f)  abort();
  if (float_max1(1.f, 0.f)  != 1.f)  abort();
  if (float_max1(-1.f, 1.f) != 1.f)  abort();
  if (float_max1(1.f, -1.f) != 1.f)  abort();

  if (float_min2(0.f, -1.f) != -1.f) abort();
  if (float_min2(-1.f, 0.f) != -1.f) abort();
  if (float_min2(0.f, 1.f)  != 0.f)  abort();
  if (float_min2(1.f, 0.f)  != 0.f)  abort();
  if (float_min2(-1.f, 1.f) != -1.f) abort();
  if (float_min2(1.f, -1.f) != -1.f) abort();

  if (float_max2(0.f, -1.f) != 0.f)  abort();
  if (float_max2(-1.f, 0.f) != 0.f)  abort();
  if (float_max2(0.f, 1.f)  != 1.f)  abort();
  if (float_max2(1.f, 0.f)  != 1.f)  abort();
  if (float_max2(-1.f, 1.f) != 1.f)  abort();
  if (float_max2(1.f, -1.f) != 1.f)  abort();

  if (double_min1(0., -1.) != -1.) abort();
  if (double_min1(-1., 0.) != -1.) abort();
  if (double_min1(0., 1.)  != 0.)  abort();
  if (double_min1(1., 0.)  != 0.)  abort();
  if (double_min1(-1., 1.) != -1.) abort();
  if (double_min1(1., -1.) != -1.) abort();

  if (double_max1(0., -1.) != 0.)  abort();
  if (double_max1(-1., 0.) != 0.)  abort();
  if (double_max1(0., 1.)  != 1.)  abort();
  if (double_max1(1., 0.)  != 1.)  abort();
  if (double_max1(-1., 1.) != 1.)  abort();
  if (double_max1(1., -1.) != 1.)  abort();

  if (double_min2(0., -1.) != -1.) abort();
  if (double_min2(-1., 0.) != -1.) abort();
  if (double_min2(0., 1.)  != 0.)  abort();
  if (double_min2(1., 0.)  != 0.)  abort();
  if (double_min2(-1., 1.) != -1.) abort();
  if (double_min2(1., -1.) != -1.) abort();

  if (double_max2(0., -1.) != 0.)  abort();
  if (double_max2(-1., 0.) != 0.)  abort();
  if (double_max2(0., 1.)  != 1.)  abort();
  if (double_max2(1., 0.)  != 1.)  abort();
  if (double_max2(-1., 1.) != 1.)  abort();
  if (double_max2(1., -1.) != 1.)  abort();

  exit(0);
}
// source: pr40022.c
extern void abort (void);

struct A
{
  struct A *a;
};

struct B
{
  struct A *b;
};

__attribute__((noinline))
struct A *
foo (struct A *x)
{
  asm volatile ("" : : "g" (x) : "memory");
  return x;
}

__attribute__((noinline))
void
bar (struct B *w, struct A *x, struct A *y, struct A *z)
{
  struct A **c;
  c = &w->b;
  *c = foo (x);
  while (*c)
    c = &(*c)->a;
  *c = foo (y);
  while (*c)
    c = &(*c)->a;
  *c = foo (z);
}

struct B d;
struct A e, f, g;

int
main (void)
{
  f.a = &g;
  bar (&d, &e, &f, 0);
  if (d.b == 0
      || d.b->a == 0
      || d.b->a->a == 0
      || d.b->a->a->a != 0)
    abort ();
  return 0;
}
// source: pr40057.c
/* PR middle-end/40057 */

extern void abort (void);

__attribute__((noinline)) int
foo (unsigned long long x)
{
  unsigned long long y = (x >> 31ULL) & 1ULL;
  if (y == 0ULL)
    return 0;
  return -1;
}

__attribute__((noinline)) int
bar (long long x)
{
  long long y = (x >> 31LL) & 1LL;
  if (y == 0LL)
    return 0;
  return -1;
}

int
main (void)
{
  if (sizeof (long long) != 8)
    return 0;
  if (foo (0x1682a9aaaULL))
    abort ();
  if (!foo (0x1882a9aaaULL))
    abort ();
  if (bar (0x1682a9aaaLL))
    abort ();
  if (!bar (0x1882a9aaaLL))
    abort ();
  return 0;
}
// source: pr40386.c
/* { dg-options "-fno-ira-share-spill-slots -Wno-shift-overflow" } */

extern void abort (void);
extern void exit (int);

#define CHAR_BIT 8

#define ROR(a,b) (((a) >> (b)) | ((a) << ((sizeof (a) * CHAR_BIT) - (b))))
#define ROL(a,b) (((a) << (b)) | ((a) >> ((sizeof (a) * CHAR_BIT) - (b))))

#define CHAR_VALUE ((char)0xf234)
#define SHORT_VALUE ((short)0xf234)
#define INT_VALUE ((int)0xf234)
#define LONG_VALUE ((long)0xf2345678L)
#define LL_VALUE ((long long)0xf2345678abcdef0LL)

#define SHIFT1 4
#define SHIFT2 ((sizeof (long long) * CHAR_BIT) - SHIFT1)

char c = CHAR_VALUE;
short s = SHORT_VALUE;
int i = INT_VALUE;
long l = LONG_VALUE;
long long ll = LL_VALUE;
int shift1 = SHIFT1;
int shift2 = SHIFT2;

int
main ()
{
  if (ROR (c, shift1) != ROR (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROR (c, SHIFT1) != ROR (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROR (s, shift1) != ROR (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROR (s, SHIFT1) != ROR (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROR (i, shift1) != ROR (INT_VALUE, SHIFT1))
    abort ();

  if (ROR (i, SHIFT1) != ROR (INT_VALUE, SHIFT1))
    abort ();

  if (ROR (l, shift1) != ROR (LONG_VALUE, SHIFT1))
    abort ();

  if (ROR (l, SHIFT1) != ROR (LONG_VALUE, SHIFT1))
    abort ();

  if (ROR (ll, shift1) != ROR (LL_VALUE, SHIFT1))
    abort ();

  if (ROR (ll, SHIFT1) != ROR (LL_VALUE, SHIFT1))
    abort ();

  if (ROR (ll, shift2) != ROR (LL_VALUE, SHIFT2))
    abort ();

  if (ROR (ll, SHIFT2) != ROR (LL_VALUE, SHIFT2))
    abort ();

  if (ROL (c, shift1) != ROL (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROL (c, SHIFT1) != ROL (CHAR_VALUE, SHIFT1))
    abort ();

  if (ROL (s, shift1) != ROL (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROL (s, SHIFT1) != ROL (SHORT_VALUE, SHIFT1))
    abort ();

  if (ROL (i, shift1) != ROL (INT_VALUE, SHIFT1))
    abort ();

  if (ROL (i, SHIFT1) != ROL (INT_VALUE, SHIFT1))
    abort ();

  if (ROL (l, shift1) != ROL (LONG_VALUE, SHIFT1))
    abort ();

  if (ROL (l, SHIFT1) != ROL (LONG_VALUE, SHIFT1))
    abort ();

  if (ROL (ll, shift1) != ROL (LL_VALUE, SHIFT1))
    abort ();

  if (ROL (ll, SHIFT1) != ROL (LL_VALUE, SHIFT1))
    abort ();

  if (ROL (ll, shift2) != ROL (LL_VALUE, SHIFT2))
    abort ();

  if (ROL (ll, SHIFT2) != ROL (LL_VALUE, SHIFT2))
    abort ();

  exit (0);
}
// source: pr40404.c
extern void abort (void);

#if (__SIZEOF_INT__ <= 2)
struct S {
  unsigned long ui17 : 17;
} s;
#else
struct S {
  unsigned int ui17 : 17;
} s;
#endif
int main()
{
  s.ui17 = 0x1ffff;
  if (s.ui17 >= 0xfffffffeu)
    abort ();
  return 0;
}
// source: pr40493.c
extern void abort (void);

typedef union i386_operand_type
{
  struct
    {
      unsigned int reg8:1;
      unsigned int reg16:1;
      unsigned int reg32:1;
      unsigned int reg64:1;
      unsigned int floatreg:1;
      unsigned int regmmx:1;
      unsigned int regxmm:1;
      unsigned int regymm:1;
      unsigned int control:1;
      unsigned int debug:1;
      unsigned int test:1;
      unsigned int sreg2:1;
      unsigned int sreg3:1;
      unsigned int imm1:1;
      unsigned int imm8:1;
      unsigned int imm8s:1;
      unsigned int imm16:1;
      unsigned int imm32:1;
      unsigned int imm32s:1;
      unsigned int imm64:1;
      unsigned int disp8:1;
      unsigned int disp16:1;
      unsigned int disp32:1;
      unsigned int disp32s:1;
      unsigned int disp64:1;
      unsigned int acc:1;
      unsigned int floatacc:1;
      unsigned int baseindex:1;
      unsigned int inoutportreg:1;
      unsigned int shiftcount:1;
      unsigned int jumpabsolute:1;
      unsigned int esseg:1;
      unsigned int regmem:1;
      unsigned int mem:1;
      unsigned int byte:1;
      unsigned int word:1;
      unsigned int dword:1;
      unsigned int fword:1;
      unsigned int qword:1;
      unsigned int tbyte:1;
      unsigned int xmmword:1;
      unsigned int ymmword:1;
      unsigned int unspecified:1;
      unsigned int anysize:1;
    } bitfield;
  unsigned int array[2];
} i386_operand_type;

unsigned int x00, x01, y00, y01;

int main (int argc, char *argv[])
{
  i386_operand_type a,b,c,d;

  a.bitfield.reg16 = 1;
  a.bitfield.imm16 = 0;
  a.array[1] = 22;

  b = a;
  x00 = b.array[0];
  x01 = b.array[1];

  c = b;
  y00 = c.array[0];
  y01 = c.array[1];

  d = c;
  if (d.bitfield.reg16 != 1)
    abort();
  if (d.bitfield.imm16 != 0)
    abort();
  if (d.array[1] != 22)
    abort();

  return 0;
}
// source: pr40579.c
extern void abort (void);
static char * __attribute__((noinline))
itos(int num)
{
  return (char *)0;
}
static void __attribute__((noinline))
foo(int i, const char *x)
{
  if (i >= 4)
    abort ();
}
int main()
{
  int x = -__INT_MAX__ + 3;
  int i;

  for (i = 0; i < 4; ++i)
    {
      char *p;
      --x;
      p = itos(x);
      foo(i, p);
    }

  return 0;
}
// source: pr40657.c
/* Verify that that Thumb-1 epilogue size optimization does not clobber the
   return value.  */

long long v = 0x123456789abc;

__attribute__((noinline)) void bar (int *x)
{
  asm volatile ("" : "=m" (x) ::);
}

__attribute__((noinline)) long long foo()
{
  int x;
  bar(&x);
  return v;
}

int main ()
{
  if (foo () != v)
    abort ();
  exit (0);
}
// source: pr40668.c
#if (__SIZEOF_INT__ == 2)
#define TESTVALUE 0x1234
#else
#define TESTVALUE 0x12345678
#endif
static void
foo (unsigned int x, void *p)
{
  __builtin_memcpy (p, &x, sizeof x);
}

void
bar (int type, void *number)
{
  switch (type)
    {
    case 1:
      foo (TESTVALUE, number);
      break;
    case 7:
      foo (0, number);
      break;
    case 8:
      foo (0, number);
      break;
    case 9:
      foo (0, number);
      break;
    }
}

int
main (void)
{
  unsigned int x;
  bar (1, &x);
  if (x != TESTVALUE)
    __builtin_abort ();
  return 0;
}
// source: pr40747.c
/* PR middle-end/40747 */

extern void abort (void);

int
foo (int i)
{
  return (i < 4 && i >= 0) ? i : 4;
}

int
main ()
{
  if (foo (-1) != 4) abort ();
  if (foo (0) != 0) abort ();
  if (foo (1) != 1) abort ();
  if (foo (2) != 2) abort ();
  if (foo (3) != 3) abort ();
  if (foo (4) != 4) abort ();
  if (foo (5) != 4) abort ();
  return 0;
}
// source: pr41239.c
/* PR rtl-optimization/41239 */

struct S
{
  short nargs;
  unsigned long arg[2];
};

extern void abort (void);
extern void exit (int);
extern char fn1 (int, const char *, int, const char *, const char *);
extern void fn2 (int, ...);
extern int fn3 (int);
extern int fn4 (const char *fmt, ...) __attribute__ ((format (printf, 1, 2)));

unsigned long
test (struct S *x)
{
  signed int arg1 = x->arg[0];
  long int arg2 = x->arg[1];

  if (arg2 == 0)
    (fn1 (20, "foo", 924, __func__, ((void *) 0))
     ? (fn2 (fn3 (0x2040082), fn4 ("division by zero")))
     : (void) 0);

  return (long int) arg1 / arg2;
}

int
main (void)
{
  struct S s = { 2, { 5, 0 } };
  test (&s);
  abort ();
}

__attribute__((noinline)) char
fn1 (int x, const char *y, int z, const char *w, const char *v)
{
  asm volatile ("" : : "r" (w), "r" (v) : "memory");
  asm volatile ("" : "+r" (x) : "r" (y), "r" (z) : "memory");
  return x;
}

__attribute__((noinline)) int
fn3 (int x)
{
  asm volatile ("" : "+r" (x) : : "memory");
  return x;
}

__attribute__((noinline)) int
fn4 (const char *x, ...)
{
  asm volatile ("" : "+r" (x) : : "memory");
  return *x;
}

__attribute__((noinline)) void
fn2 (int x, ...)
{
  asm volatile ("" : "+r" (x) : : "memory");
  if (x)
    /* Could be a longjmp or throw too.  */
    exit (0);
}
// source: pr41317.c
extern void abort (void);

struct A
{
  int i;
};
struct B
{
  struct A a;
  int j;
};

static void
foo (struct B *p)
{
  ((struct A *)p)->i = 1;
}

int main()
{
  struct A a;
  a.i = 0;
  foo ((struct B *)&a);
  if (a.i != 1)
    abort ();
  return 0;
}
// source: pr41395-1.c
struct VEC_char_base
{
  unsigned num;
  unsigned alloc;
  short vec[1];
};

short __attribute__((noinline))
foo (struct VEC_char_base *p, int i)
{
  short *q;
  p->vec[i] = 0;
  q = &p->vec[8];
  *q = 1;
  return p->vec[i];
}

extern void abort (void);
extern void *malloc (__SIZE_TYPE__);

int
main()
{
  struct VEC_char_base *p = malloc (sizeof (struct VEC_char_base) + 256);
  if (foo (p, 8) != 1)
    abort ();
  return 0;
}
// source: pr41395-2.c
struct VEC_char_base
{
  unsigned num;
  unsigned alloc;
  union {
      short vec[1];
      struct {
	  int i;
	  int j;
	  int k;
      } a;
  } u;
};

short __attribute__((noinline))
foo (struct VEC_char_base *p, int i)
{
  short *q;
  p->u.vec[i] = 0;
  q = &p->u.vec[16];
  *q = 1;
  return p->u.vec[i];
}

extern void abort (void);
extern void *malloc (__SIZE_TYPE__);

int
main()
{
  struct VEC_char_base *p = malloc (sizeof (struct VEC_char_base) + 256);
  if (foo (p, 16) != 1)
    abort ();
  return 0;
}
// source: pr41463.c
#include <stdlib.h>

union tree_node;

struct tree_common
{
  int a;
  long b;
  long c;
  void *p;
  int d;
};

struct other_tree
{
  struct tree_common common;
  int arr[14];
};

struct tree_vec
{
  struct tree_common common;
  int length;
  union tree_node *a[1];
};

union tree_node
{
  struct other_tree othr;
  struct tree_vec vec;
};

union tree_node global;

union tree_node * __attribute__((noinline))
foo (union tree_node *p, int i)
{
  union tree_node **q;
  p->vec.a[i] = (union tree_node *) 0;
  q = &p->vec.a[1];
  *q = &global;
  return p->vec.a[i];
}

extern void abort (void);
extern void *malloc (__SIZE_TYPE__);

int
main()
{
  union tree_node *p = malloc (sizeof (union tree_node));
  if (foo (p, 1) != &global)
    abort ();
  return 0;
}
// source: pr41750.c
/* PR 41750 - IPA-SRA used to pass hash->sgot by value rather than by
   reference.  */

struct bfd_link_hash_table
{
  int hash;
};

struct foo_link_hash_table
{
  struct bfd_link_hash_table root;
  int *dynobj;
  int *sgot;
};

struct foo_link_info
{
  struct foo_link_hash_table *hash;
};

extern void abort (void);

int __attribute__((noinline))
foo_create_got_section (int *abfd, struct foo_link_info *info)
{
  info->hash->sgot = abfd;
  return 1;
}

static int *
get_got (int *abfd, struct foo_link_info *info,
	 struct foo_link_hash_table *hash)
{
  int *got;
  int *dynobj;

  got = hash->sgot;
  if (!got)
    {
      dynobj = hash->dynobj;
      if (!dynobj)
	hash->dynobj = dynobj = abfd;
      if (!foo_create_got_section (dynobj, info))
	return 0;
      got = hash->sgot;
    }
  return got;
}

int * __attribute__((noinline,noclone))
elf64_ia64_check_relocs (int *abfd, struct foo_link_info *info)
{
  return get_got (abfd, info, info->hash);
}

struct foo_link_info link_info;
struct foo_link_hash_table hash;
int abfd;

int
main ()
{
  link_info.hash = &hash;
  if (elf64_ia64_check_relocs (&abfd, &link_info) != &abfd)
    abort ();
  return 0;
}
// source: pr41917.c
/* PR rtl-optimization/41917 */

extern void abort (void);
unsigned int a = 1;

int
main (void)
{
  unsigned int b, c, d;

  if (sizeof (int) != 4 || (int) 0xc7d24b5e > 0)
    return 0;

  c = 0xc7d24b5e;
  d = a | -2;
  b = (d == 0) ? c : (c % d);
  if (b != c)
    abort ();

  return 0;
}
// source: pr41919.c
extern void abort (void);

#define assert(x) if(!(x)) abort()

struct S1
{
  signed char f0;
};

int g_23 = 0;

static struct S1
foo (void)
{
  int *l_100 = &g_23;
  int **l_110 = &l_100;
  struct S1 l_128 = { 1 };
  assert (l_100 == &g_23);
  assert (l_100 == &g_23);
  assert (l_100 == &g_23);
  assert (l_100 == &g_23);
  assert (l_100 == &g_23);
  assert (l_100 == &g_23);
  assert (l_100 == &g_23);
  return l_128;
}

static signed char bar(signed char si1, signed char si2)
{
  return (si1 <= 0) ? si1 : (si2 * 2);
}
int main (void)
{
  struct S1 s = foo();
  if (bar(0x99 ^ (s.f0 && 1), 1) != -104)
    abort ();
  return 0;
}
// source: pr41935.c
/* PR middle-end/41935 */

extern void abort (void);

long int
foo (int n, int i, int j)
{
  typedef int T[n];
  struct S { int a; T b[n]; };
  return __builtin_offsetof (struct S, b[i][j]);
}

int
main (void)
{
  typedef int T[5];
  struct S { int a; T b[5]; };
  if (foo (5, 2, 3)
      != __builtin_offsetof (struct S, b) + (5 * 2 + 3) * sizeof (int))
    abort ();
  if (foo (5, 5, 5)
      != __builtin_offsetof (struct S, b) + (5 * 5 + 5) * sizeof (int))
    abort ();
  return 0;
}
// source: pr42006.c
extern void abort (void);

static unsigned int
my_add(unsigned int si1, unsigned int si2)
{
  return (si1 > (50-si2)) ? si1 : (si1 + si2);
}

static unsigned int
my_shift(unsigned int left, unsigned int right)
{
  return  (right > 100) ? left : (left >> right);
}

static int func_4(unsigned int p_6)
{
  int count = 0;
  for (p_6 = 1; p_6 < 3; p_6 = my_add(p_6, 1))
    {
      if (count++ > 1)
	abort ();

      if (my_shift(p_6, p_6))
	return 0;
    }
  return 0;
}

int main(void)
{
  func_4(0);
  return 0;
}
// source: pr42142.c
int __attribute__((noinline,noclone))
sort(int L)
{
  int end[2] = { 10, 10, }, i=0, R;
  while (i<2)
    {
      R = end[i];
      if (L<R)
        {
          end[i+1] = 1;
          end[i] = 10;
          ++i;
        }
      else
        break;
    }
  return i;
}
extern void abort (void);
int main()
{
  if (sort (5) != 1)
    abort ();
  return 0;
}
// source: pr42154.c
struct A { char x[1]; };
extern void abort (void);
void __attribute__((noinline,noclone))
foo (struct A a)
{
  if (a.x[0] != 'a')
    abort ();
}
int main ()
{
  struct A a;
  int i;
  for (i = 0; i < 1; ++i)
    a.x[i] = 'a';
  foo (a);
  return 0;
}
// source: pr42231.c
extern void abort (void);

static max;

static void __attribute__((noinline)) storemax (int i)
{
  if (i > max)
    max = i;
}

static int CallFunctionRec(int (*fun)(int depth), int depth) {
  if (!fun(depth)) {
    return 0;
  }
  if (depth < 10) {
    CallFunctionRec(fun, depth + 1);
  }
  return 1;
}

static int CallFunction(int (*fun)(int depth)) {
  return CallFunctionRec(fun, 1) && !fun(0);
}

static int callback(int depth) {
  storemax (depth);
  return depth != 0;
}

int main() {
  CallFunction(callback);
  if (max != 10)
    abort ();
  return 0;
}
// source: pr42248.c
typedef struct {
  _Complex double a;
  _Complex double b;
} Scf10;

Scf10 g1s;

void
check (Scf10 x, _Complex double y)
{
  if (x.a != y) __builtin_abort ();
}

void
init (Scf10 *p, _Complex double y)
{
  p->a = y;
}

int
main ()
{
  init (&g1s, (_Complex double)1);
  check (g1s, (_Complex double)1);

  return 0;
}
// source: pr42269-2.c
/* Make sure that language + abi extensions in passing S interoperate.  */

static long long __attribute__((noinline))
foo (unsigned short s)
{
  return (short) s;
}

unsigned short s = 0xFFFF;

int
main (void)
{
  return foo (s) + 1 != 0;
}
// source: pr42512.c
extern void abort (void);

short g_3;

int main (void)
{
    int l_2;
    for (l_2 = -1; l_2 != 0; l_2 = (unsigned char)(l_2 - 1))
      g_3 |= l_2;
    if (g_3 != -1)
      abort ();
    return 0;
}
// source: pr42544.c
/* PR c/42544 */

extern void abort (void);

int
main ()
{
  signed short s = -1;
  if (sizeof (long long) == sizeof (unsigned int))
    return 0;
  if ((unsigned int) s >= 0x100000000ULL)
    abort ();
  return 0;
}
// source: pr42570.c
typedef unsigned char uint8_t;
uint8_t foo[1][0];
extern void abort (void);
int main()
{
  if (sizeof (foo) != 0)
    abort ();
  return 0;
}
// source: pr42614.c
extern void *malloc(__SIZE_TYPE__);
extern void abort(void);
extern void free(void *);

typedef struct SEntry
{
  unsigned char num;
} TEntry;

typedef struct STable
{
  TEntry data[2];
} TTable;

TTable *init ()
{
  return malloc(sizeof(TTable));
}

void
expect_func (int a, unsigned char *b) __attribute__ ((noinline));

static inline void
inlined_wrong (TEntry *entry_p, int flag);

void
inlined_wrong (TEntry *entry_p, int flag)
{
  unsigned char index;
  entry_p->num = 0;

  if (flag == 0)
    abort();

  for (index = 0; index < 1; index++)
    entry_p->num++;

  if (!entry_p->num)
    {
      abort();
    }
}

void
expect_func (int a, unsigned char *b)
{
  if (abs ((a == 0)))
    abort ();
  if (abs ((b == 0)))
    abort ();
}

int
main ()
{
  unsigned char index = 0;
  TTable *table_p = init();
  TEntry work;

  inlined_wrong (&(table_p->data[1]), 1);
  expect_func (1, &index);
  inlined_wrong (&work, 1);

  free (table_p);

  return 0;
}
// source: pr42691.c
extern void abort (void);

union _D_rep
{
  unsigned short rep[4];
  double val;
};

int add(double* key, double* table)
{
  unsigned i = 0;
  double* deletedEntry = 0;
  while (1) {
    double* entry = table + i;

    if (*entry == *key)
      break;

    union _D_rep _D_inf = {{ 0, 0, 0, 0x7ff0 }};
    if (*entry != _D_inf.val)
      abort ();

    union _D_rep _D_inf2 = {{ 0, 0, 0, 0x7ff0 }};
    if (!_D_inf2.val)
      deletedEntry = entry;

    i++;
  }
  if (deletedEntry)
    *deletedEntry = 0.0;
  return 0;
}

int main ()
{
  union _D_rep infinit = {{ 0, 0, 0, 0x7ff0 }};
  double table[2] = { infinit.val, 23 };
  double key = 23;
  int ret = add (&key, table);
  return ret;
}
// source: pr42721.c
/* PR c/42721 */

extern void abort (void);

static unsigned long long
foo (unsigned long long x, unsigned long long y)
{
  return x / y;
}

static int a, b;

int
main (void)
{
  unsigned long long c = 1;
  b ^= c && (foo (a, -1ULL) != 1L);
  if (b != 1)
    abort ();
  return 0;
}
// source: pr42833.c
typedef __INT_LEAST8_TYPE__ int8_t;
typedef __UINT_LEAST32_TYPE__ uint32_t;
typedef int ssize_t;
typedef struct { int8_t v1; int8_t v2; int8_t v3; int8_t v4; } neon_s8;

uint32_t helper_neon_rshl_s8 (uint32_t arg1, uint32_t arg2);

uint32_t
helper_neon_rshl_s8 (uint32_t arg1, uint32_t arg2)
{
  uint32_t res;
  neon_s8 vsrc1;
  neon_s8 vsrc2;
  neon_s8 vdest;
  do
    {
      union
      {
	neon_s8 v;
	uint32_t i;
      } conv_u;
      conv_u.i = (arg1);
      vsrc1 = conv_u.v;
    }
  while (0);
  do
    {
      union
      {
	neon_s8 v;
	uint32_t i;
      } conv_u;
      conv_u.i = (arg2);
      vsrc2 = conv_u.v;
    }
  while (0);
  do
    {
      int8_t tmp;
      tmp = (int8_t) vsrc2.v1;
      if (tmp >= (ssize_t) sizeof (vsrc1.v1) * 8)
	{
	  vdest.v1 = 0;
	}
      else if (tmp < -(ssize_t) sizeof (vsrc1.v1) * 8)
	{
	  vdest.v1 = vsrc1.v1 >> (sizeof (vsrc1.v1) * 8 - 1);
	}
      else if (tmp == -(ssize_t) sizeof (vsrc1.v1) * 8)
	{
	  vdest.v1 = vsrc1.v1 >> (tmp - 1);
	  vdest.v1++;
	  vdest.v1 >>= 1;
	}
      else if (tmp < 0)
	{
	  vdest.v1 = (vsrc1.v1 + (1 << (-1 - tmp))) >> -tmp;
	}
      else
	{
	  vdest.v1 = vsrc1.v1 << tmp;
	}
    }
  while (0);
  do
    {
      int8_t tmp;
      tmp = (int8_t) vsrc2.v2;
      if (tmp >= (ssize_t) sizeof (vsrc1.v2) * 8)
	{
	  vdest.v2 = 0;
	}
      else if (tmp < -(ssize_t) sizeof (vsrc1.v2) * 8)
	{
	  vdest.v2 = vsrc1.v2 >> (sizeof (vsrc1.v2) * 8 - 1);
	}
      else if (tmp == -(ssize_t) sizeof (vsrc1.v2) * 8)
	{
	  vdest.v2 = vsrc1.v2 >> (tmp - 1);
	  vdest.v2++;
	  vdest.v2 >>= 1;
	}
      else if (tmp < 0)
	{
	  vdest.v2 = (vsrc1.v2 + (1 << (-1 - tmp))) >> -tmp;
	}
      else
	{
	  vdest.v2 = vsrc1.v2 << tmp;
	}
    }
  while (0);
  do
    {
      int8_t tmp;
      tmp = (int8_t) vsrc2.v3;
      if (tmp >= (ssize_t) sizeof (vsrc1.v3) * 8)
	{
	  vdest.v3 = 0;
	}
      else if (tmp < -(ssize_t) sizeof (vsrc1.v3) * 8)
	{
	  vdest.v3 = vsrc1.v3 >> (sizeof (vsrc1.v3) * 8 - 1);
	}
      else if (tmp == -(ssize_t) sizeof (vsrc1.v3) * 8)
	{
	  vdest.v3 = vsrc1.v3 >> (tmp - 1);
	  vdest.v3++;
	  vdest.v3 >>= 1;
	}
      else if (tmp < 0)
	{
	  vdest.v3 = (vsrc1.v3 + (1 << (-1 - tmp))) >> -tmp;
	}
      else
	{
	  vdest.v3 = vsrc1.v3 << tmp;
	}
    }
  while (0);
  do
    {
      int8_t tmp;
      tmp = (int8_t) vsrc2.v4;
      if (tmp >= (ssize_t) sizeof (vsrc1.v4) * 8)
	{
	  vdest.v4 = 0;
	}
      else if (tmp < -(ssize_t) sizeof (vsrc1.v4) * 8)
	{
	  vdest.v4 = vsrc1.v4 >> (sizeof (vsrc1.v4) * 8 - 1);
	}
      else if (tmp == -(ssize_t) sizeof (vsrc1.v4) * 8)
	{
	  vdest.v4 = vsrc1.v4 >> (tmp - 1);
	  vdest.v4++;
	  vdest.v4 >>= 1;
	}
      else if (tmp < 0)
	{
	  vdest.v4 = (vsrc1.v4 + (1 << (-1 - tmp))) >> -tmp;
	}
      else
	{
	  vdest.v4 = vsrc1.v4 << tmp;
	}
    }
  while (0);;
  do
    {
      union
      {
	neon_s8 v;
	uint32_t i;
      } conv_u;
      conv_u.v = (vdest);
      res = conv_u.i;
    }
  while (0);
  return res;
}

extern void abort(void);

int main()
{
  uint32_t r = helper_neon_rshl_s8 (0x05050505, 0x01010101);
  if (r != 0x0a0a0a0a)
    abort ();
  return 0;
}
// source: pr43008.c
int i;
struct X {
  int *p;
};
struct X * __attribute__((malloc))
my_alloc (void)
{
  struct X *p = __builtin_malloc (sizeof (struct X));
  p->p = &i;
  return p;
}
extern void abort (void);
int main()
{
  struct X *p, *q;
  p = my_alloc ();
  q = my_alloc ();
  *(p->p) = 1;
  *(q->p) = 0;
  if (*(p->p) != 0)
    abort ();
  return 0;
}
// source: pr43220.c
/* { dg-require-effective-target int32plus } */
/* { dg-require-effective-target alloca } */

void *volatile p;

int
main (void)
{
  int n = 0;
lab:;
    {
      int x[n % 1000 + 1];
      x[0] = 1;
      x[n % 1000] = 2;
      p = x;
      n++;
    }

    {
      int x[n % 1000 + 1];
      x[0] = 1;
      x[n % 1000] = 2;
      p = x;
      n++;
    }

  if (n < 1000000)
    goto lab;

  return 0;
}
// source: pr43236.c
/* { dg-options "-ftree-loop-distribution" } */
extern void abort(void);
extern void *memset(void *s, int c, __SIZE_TYPE__ n);
extern int memcmp(const void *s1, const void *s2, __SIZE_TYPE__ n);
/*extern int printf(const char *format, ...);*/

int main()
{
  char A[30], B[30], C[30];
  int i;

  /* prepare arrays */
  memset(A, 1, 30);
  memset(B, 1, 30);

  for (i = 20; i-- > 10;) {
    A[i] = 0;
    B[i] = 0;
  }

  /* expected result */
  memset(C, 1, 30);
  memset(C + 10, 0, 10);

  /* show result */
/*  for (i = 0; i < 30; i++)
    printf("%d %d %d\n", A[i], B[i], C[i]); */

  /* compare results */
  if (memcmp(A, C, 30) || memcmp(B, C, 30)) abort();
  return 0;
}
// source: pr43269.c
int g_21;
int g_211;
int g_261;

static void __attribute__((noinline,noclone))
func_32 (int b)
{
  if (b) {
lbl_370:
      g_21 = 1;
  }

  for (g_261 = -1; g_261 > -2; g_261--) {
      if (g_211 + 1) {
	  return;
      } else {
	  g_21 = 1;
	  goto lbl_370;
      }
  }
}

extern void abort (void);

int main(void)
{
  func_32(0);
  if (g_261 != -1)
    abort ();
  return 0;
}
// source: pr43385.c
/* PR c/43385 */

extern void abort (void);

int e;

__attribute__((noinline)) void
foo (int x, int y)
{
  if (__builtin_expect (x, 0) && y != 0)
    e++;
}

__attribute__((noinline)) int
bar (int x, int y)
{
  if (__builtin_expect (x, 0) && y != 0)
    return 1;
  else
    return 0;
}

int
main (void)
{
  int z = 0;
  asm ("" : "+r" (z));
  foo (z + 2, z + 1);
  if (e != 1)
    abort ();
  foo (z + 2, z);
  if (e != 1)
    abort ();
  foo (z + 1, z + 1);
  if (e != 2)
    abort ();
  foo (z + 1, z);
  if (e != 2)
    abort ();
  foo (z, z + 1);
  if (e != 2)
    abort ();
  foo (z, z);
  if (e != 2)
    abort ();
  if (bar (z + 2, z + 1) != 1)
    abort ();
  if (bar (z + 2, z) != 0)
    abort ();
  if (bar (z + 1, z + 1) != 1)
    abort ();
  if (bar (z + 1, z) != 0)
    abort ();
  if (bar (z, z + 1) != 0)
    abort ();
  if (bar (z, z) != 0)
    abort ();
  return 0;
}
// source: pr43438.c
extern void abort (void);

static unsigned char g_2 = 1;
static int g_9;
static int *l_8 = &g_9;

static void func_12(int p_13)
{
  int * l_17 = &g_9;
  *l_17 &= 0 < p_13;
}

int main(void)
{
  unsigned char l_11 = 254;
  *l_8 |= g_2;
  l_11 |= *l_8;
  func_12(l_11);
  if (g_9 != 1)
    abort ();
  return 0;
}
// source: pr43560.c
/* PR tree-optimization/43560 */

struct S
{
  int a, b;
  char c[10];
};

__attribute__ ((noinline)) void
test (struct S *x)
{
  while (x->b > 1 && x->c[x->b - 1] == '/')
    {
      x->b--;
      x->c[x->b] = '\0';
    }
}

const struct S s = { 0, 0, "" };

int
main ()
{
  struct S *p;
  asm ("" : "=r" (p) : "0" (&s));
  test (p);
  return 0;
}
// source: pr43629.c
int flag;
extern void abort (void);
int main()
{
  int x;
  if (flag)
    x = -1;
  else
    x &= 0xff;
  if (x & ~0xff)
    abort ();
  return 0;
}
// source: pr43783.c
/* { dg-skip-if "small alignment" { pdp11-*-* } } */

typedef __attribute__((aligned(16)))
struct {
  unsigned long long w[3];
} UINT192;

UINT192 bid_Kx192[32];

extern void abort (void);

int main()
{
  int i = 0;
  unsigned long x = 0;
  for (i = 0; i < 32; ++i)
    bid_Kx192[i].w[1] = i == 1;
  for (i = 0; i < 32; ++i)
    x += bid_Kx192[1].w[1];
  if (x != 32)
    abort ();
  return 0;
}
// source: pr43784.c
struct s {
  unsigned char a[256];
};
union u {
  struct { struct s b; int c; } d;
  struct { int c; struct s b; } e;
};

static union u v;
static struct s *p = &v.d.b;
static struct s *q = &v.e.b;

static struct s __attribute__((noinline)) rp(void)
{
  return *p;
}

static void qp(void)
{
  *q = rp();
}

int main()
{
  int i;
  for (i = 0; i < 256; i++)
    p->a[i] = i;
  qp();
  for (i = 0; i < 256; i++)
    if (q->a[i] != i)
      __builtin_abort();
  return 0;
}
// source: pr43835.c
struct PMC {
    unsigned flags;
};

typedef struct Pcc_cell
{
    struct PMC *p;
    long bla;
    long type;
} Pcc_cell;

extern void abort ();
extern void Parrot_gc_mark_PMC_alive_fun(int * interp, struct PMC *pmc)
     __attribute__((noinline));

void Parrot_gc_mark_PMC_alive_fun (int * interp, struct PMC *pmc)
{
  abort ();
}

static void mark_cell(int * interp, Pcc_cell *c)
        __attribute__((__nonnull__(1)))
        __attribute__((__nonnull__(2)))
        __attribute__((noinline));

static void
mark_cell(int * interp, Pcc_cell *c)
{
            if (c->type == 4 && c->p
		&& !(c->p->flags & (1<<18)))
	      Parrot_gc_mark_PMC_alive_fun(interp, c->p);
}

void foo(int * interp, Pcc_cell *c);

void
foo(int * interp, Pcc_cell *c)
{
  mark_cell(interp, c);
}

int main()
{
  int i;
  Pcc_cell c;
  c.p = 0;
  c.bla = 42;
  c.type = 4;
  foo (&i, &c);
  return 0;
}
// source: pr43987.c
char B[256 * sizeof(void *)];
typedef void *FILE;
typedef struct globals {
    int c;
    FILE *l;
} __attribute__((may_alias)) T;
void add_input_file(FILE *file)
{
  (*(T*)&B).l[0] = file;
}
extern void abort (void);
int main()
{
  FILE x;
  (*(T*)&B).l = &x;
  add_input_file ((void *)-1);
  if ((*(T*)&B).l[0] != (void *)-1)
    abort ();
  return 0;
}
// source: pr44164.c
struct X {
    struct Y {
	struct YY {
	    struct Z {
		int i;
	    } c;
	} bb;
    } b;
} a;
int __attribute__((noinline, noclone))
foo (struct Z *p)
{
  int i = p->i;
  a.b = (struct Y){};
  return p->i + i;
}
extern void abort (void);
int main()
{
  a.b.bb.c.i = 1;
  if (foo (&a.b.bb.c) != 1)
    abort ();
  return 0;
}
// source: pr44202-1.c
extern __attribute__ ((__noreturn__)) void exit(int);
extern __attribute__ ((__noreturn__)) void abort(void);
__attribute__ ((__noinline__))
int
add512(int a, int *b)
{
  int c = a + 512;
  if (c != 0)
    *b = a;
  return c;
}

__attribute__ ((__noinline__))
int
add513(int a, int *b)
{
  int c = a + 513;
  if (c == 0)
    *b = a;
  return c;
}

int main(void)
{
  int b0 = -1;
  int b1 = -1;
  if (add512(-512, &b0) != 0 || b0 != -1 || add513(-513, &b1) != 0 || b1 != -513)
    abort ();
  exit (0);
}
// source: pr44468.c
#include <stddef.h>

struct S {
  int i;
  int j;
};
struct R {
  int k;
  struct S a;
};
struct Q {
  float k;
  struct S a;
};
struct Q s;
int __attribute__((noinline,noclone))
test1 (void *q)
{
  struct S *b = (struct S *)((char *)q + sizeof (int));
  s.a.i = 0;
  b->i = 3;
  return s.a.i;
}
int __attribute__((noinline,noclone))
test2 (void *q)
{
  struct S *b = &((struct R *)q)->a;
  s.a.i = 0;
  b->i = 3;
  return s.a.i;
}
int __attribute__((noinline,noclone))
test3 (void *q)
{
  s.a.i = 0;
  ((struct S *)((char *)q + sizeof (int)))->i = 3;
  return s.a.i;
}
extern void abort (void);
int
main()
{
  if (sizeof (float) != sizeof (int)
      || offsetof (struct R, a) != sizeof (int)
      || offsetof (struct Q, a) != sizeof (int))
    return 0;
  s.a.i = 1;
  s.a.j = 2;
  if (test1 ((void *)&s) != 3)
    abort ();
  s.a.i = 1;
  s.a.j = 2;
  if (test2 ((void *)&s) != 3)
    abort ();
  s.a.i = 1;
  s.a.j = 2;
  if (test3 ((void *)&s) != 3)
    abort ();
  return 0;
}
// source: pr44555.c
struct a {
    char b[100];
};
int foo(struct a *a)
{
  if (&a->b)
    return 1;
  return 0;
}
extern void abort (void);
int main()
{
  if (foo((struct a *)0) != 0)
    abort ();
  return 0;
}
// source: pr44575.c
/* PR target/44575 */

#include <stdarg.h>

int fails = 0;
struct S { float a[3]; };
struct S a[5];

void
check (int z, ...)
{
  struct S arg, *p;
  va_list ap;
  int j = 0, k = 0;
  int i;
  va_start (ap, z);
  for (i = 2; i < 4; ++i)
    {
      p = 0;
      j++;
      k += 2;
      switch ((z << 4) | i)
	{
	case 0x12:
	case 0x13:
	  p = &a[2];
	  arg = va_arg (ap, struct S);
	  break;
	default:
	  ++fails;
	  break;
	}
      if (p && p->a[2] != arg.a[2])
	++fails;
      if (fails)
	break;
    }
  va_end (ap);
}

int
main ()
{
  a[2].a[2] = -49026;
  check (1, a[2], a[2]);
  if (fails)
    abort ();
  return 0;
}
// source: pr44683.c
int __attribute__((noinline,noclone))
copysign_bug (double x)
{
  if (x != 0.0 && (x * 0.5 == x))
    return 1;
  if (__builtin_copysign(1.0, x) < 0.0)
    return 2;
  else
    return 3;
}
int main(void)
{
  double x = -0.0;
  if (copysign_bug (x) != 2)
    __builtin_abort ();
  return 0;
}
// source: pr44828.c
extern void abort (void);

static signed char
foo (signed char si1, signed char si2)
{
  return si1 * si2;
}

int a = 0x105F61CA;

int
main (void)
{
  int b = 0x0332F5C8;
  if (foo (b, a) > 0)
    abort ();
  return 0;
}
// source: pr44852.c
__attribute__ ((__noinline__))
char *sf(char *s, char *s0)
{
  asm ("");
  while (*--s == '9')
    if (s == s0)
      {
	*s = '0';
	break;
      }
  ++*s++;
  return s;
}

int main()
{
  char s[] = "999999";
  char *x = sf (s+2, s);
  if (x != s+1 || __builtin_strcmp (s, "199999") != 0)
    __builtin_abort ();
  return 0;
}
// source: pr44858.c
/* PR rtl-optimization/44858 */

extern void abort (void);
int a = 3;
int b = 1;

__attribute__((noinline)) long long
foo (int x, int y)
{
  return x / y;
}

__attribute__((noinline)) int
bar (void)
{
  int c = 2;
  c &= foo (1, b) > b;
  b = (a != 0) | c;
  return c;
}

int
main (void)
{
  if (bar () != 0 || b != 1)
    abort ();
  return 0;
}
// source: pr44942.c
/* PR target/44942 */

#include <stdarg.h>

void
test1 (int a, int b, int c, int d, int e, int f, int g, long double h, ...)
{
  int i;
  va_list ap;

  va_start (ap, h);
  i = va_arg (ap, int);
  if (i != 1234)
    __builtin_abort ();
  va_end (ap);
}

void
test2 (int a, int b, int c, int d, int e, int f, int g, long double h, int i,
       long double j, int k, long double l, int m, long double n, ...)
{
  int o;
  va_list ap;

  va_start (ap, n);
  o = va_arg (ap, int);
  if (o != 1234)
    __builtin_abort ();
  va_end (ap);
}

void
test3 (double a, double b, double c, double d, double e, double f,
       double g, long double h, ...)
{
  double i;
  va_list ap;

  va_start (ap, h);
  i = va_arg (ap, double);
  if (i != 1234.0)
    __builtin_abort ();
  va_end (ap);
}

void
test4 (double a, double b, double c, double d, double e, double f, double g,
       long double h, double i, long double j, double k, long double l,
       double m, long double n, ...)
{
  double o;
  va_list ap;

  va_start (ap, n);
  o = va_arg (ap, double);
  if (o != 1234.0)
    __builtin_abort ();
  va_end (ap);
}

int
main ()
{
  test1 (0, 0, 0, 0, 0, 0, 0, 0.0L, 1234);
  test2 (0, 0, 0, 0, 0, 0, 0, 0.0L, 0, 0.0L, 0, 0.0L, 0, 0.0L, 1234);
  test3 (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0L, 1234.0);
  test4 (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0L, 0.0, 0.0L,
	 0.0, 0.0L, 0.0, 0.0L, 1234.0);
  return 0;
}
// source: pr45034.c
extern void abort (void);
static void fixnum_neg(signed char x, signed char *py, int *pv)
{
  unsigned char ux, uy;

  ux = (unsigned char)x;
  uy = -ux;
  *py = (uy <= 127) ? (signed char)uy : (-(signed char)(255 - uy) - 1);
  *pv = (x == -128) ? 1 : 0;
}

void __attribute__((noinline)) foo(int x, int y, int v)
{
  if (y < -128 || y > 127)
    abort();
}

int test_neg(void)
{
  signed char x, y;
  int v, err;

  err = 0;
  x = -128;
  for (;;) {
      fixnum_neg(x, &y, &v);
      foo((int)x, (int)y, v);
      if ((v && x != -128) || (!v && x == -128))
	++err;
      if (x == 127)
	break;
      ++x;
  }
  return err;
}

int main(void)
{
  if (sizeof (char) != 1)
    return 0;
  if (test_neg() != 0)
    abort();
  return 0;
}
// source: pr45070.c
/* PR45070 */
extern void abort(void);

struct packed_ushort {
    unsigned short ucs;
} __attribute__((packed));

struct source {
    int pos, length;
    int flag;
};

static void __attribute__((noinline)) fetch(struct source *p)
{
    p->length = 128;
}

static struct packed_ushort __attribute__((noinline)) next(struct source *p)
{
    struct packed_ushort rv;

    if (p->pos >= p->length) {
	if (p->flag) {
	    p->flag = 0;
	    fetch(p);
	    return next(p);
	}
	p->flag = 1;
	rv.ucs = 0xffff;
	return rv;
    }
    rv.ucs = 0;
    return rv;
}

int main(void)
{
    struct source s;
    int i;

    s.pos = 0;
    s.length = 0;
    s.flag = 0;

    for (i = 0; i < 16; i++) {
	struct packed_ushort rv = next(&s);
	if ((i == 0 && rv.ucs != 0xffff)
	    || (i > 0 && rv.ucs != 0))
	    abort();
    }
    return 0;
}
// source: pr45262.c
/* PR middle-end/45262 */

/* { dg-require-effective-target int32plus } */

extern void abort (void);

int
foo (unsigned int x)
{
  return ((int) x < 0) || ((int) (-x) < 0);
}

int
bar (unsigned int x)
{
  return x >> 31 || (-x) >> 31;
}

int
main (void)
{
  if (foo (1) != 1)
    abort ();
  if (foo (0) != 0)
    abort ();
  if (foo (-1) != 1)
    abort ();
  if (bar (1) != 1)
    abort ();
  if (bar (0) != 0)
    abort ();
  if (bar (-1) != 1)
    abort ();
  return 0;
}
// source: pr45695.c
/* PR rtl-optimization/45695 */

extern void abort (void);

__attribute__((noinline)) void
g (int x)
{
  asm volatile ("" : "+r" (x));
}

__attribute__((noinline)) int
f (int a, int b, int d)
{
  int r = -1;
  b += d;
  if (d == a)
    r = b - d;
  g (b);
  return r;
}

int
main (void)
{
  int l;
  asm ("" : "=r" (l) : "0" (0));
  if (f (l + 0, l + 1, l + 4) != -1)
    abort ();
  if (f (l + 4, l + 1, l + 4) != 1)
    abort ();
  return 0;
}
// source: pr46019.c
/* PR middle-end/46019 */

extern void abort (void);

int
main (void)
{
  unsigned long long l = 0x40000000000ULL;
  int n;
  for (n = 0; n < 8; n++)
    if (l / (0x200000000ULL << n) != (0x200 >> n))
      abort ();
  return 0;
}
// source: pr46309.c
/* PR tree-optimization/46309 */

extern void abort (void);

unsigned int *q;

__attribute__((noinline, noclone)) void
bar (unsigned int *p)
{
  if (*p != 2 && *p != 3)
    (!(!(*q & 263) || *p != 1)) ? abort () : 0;
}

int
main ()
{
  unsigned int x, y;
  asm volatile ("" : : : "memory");
  x = 2;
  bar (&x);
  x = 3;
  bar (&x);
  y = 1;
  x = 0;
  q = &y;
  bar (&x);
  y = 0;
  x = 1;
  bar (&x);
  return 0;
}
// source: pr46316.c
extern void abort (void);

long long __attribute__((noinline,noclone))
foo (long long t)
{
  while (t > -4)
    t -= 2;

  return t;
}

int main(void)
{
  if (foo (0) != -4)
    abort ();
  return 0;
}
// source: pr46909-1.c
/* PR tree-optimization/46909 */

extern void abort ();

int
__attribute__ ((__noinline__))
foo (unsigned int x)
{
  if (! (x == 4 || x == 6) || (x == 2 || x == 6))
    return 1;
  return -1;
}

int
main ()
{
  int i;
  for (i = -10; i < 10; i++)
    if (foo (i) != 1 - 2 * (i == 4))
      abort ();
  return 0;
}
// source: pr46909-2.c
/* PR tree-optimization/46909 */

extern void abort (void);

int
__attribute__((noinline))
foo (int x)
{
  if ((x != 0 && x != 13) || x == 5 || x == 20)
    return 1;
  return -1;
}

int
main (void)
{
  int i;
  for (i = -10; i < 30; i++)
    if (foo (i) != 1 - 2 * (i == 0) - 2 * (i == 13))
      abort ();
  return 0;
}
// source: pr47148.c
/* PR tree-optimization/47148 */

static inline unsigned
bar (unsigned x, unsigned y)
{
  if (y >= 32)
    return x;
  else
    return x >> y;
}

static unsigned a = 1, b = 1;

static inline void
foo (unsigned char x, unsigned y)
{
  if (!y)
    return;
  unsigned c = (0x7000U / (x - 2)) ^ a;
  unsigned d = bar (a, a);
  b &= ((a - d) && (a - 1)) + c;
}

int
main (void)
{
  foo (1, 1);
  foo (-1, 1);
  if (b && ((unsigned char) -1) == 255)
    __builtin_abort ();
  return 0;
}
// source: pr47155.c
/* PR tree-optimization/47155 */

unsigned int a;
static signed char b = -127;
int c = 1;

int
main (void)
{
  a = b <= (unsigned char) (-6 * c);
  if (!a)
    __builtin_abort ();
  return 0;
}
// source: pr47237.c
/* { dg-xfail-if "can cause stack underflow" { nios2-*-* } } */
/* { dg-require-effective-target untyped_assembly } */
#define INTEGER_ARG  5

extern void abort(void);

static void foo(int arg)
{
  if (arg != INTEGER_ARG)
    abort();
}

static void bar(int arg)
{
  foo(arg);
  __builtin_apply(foo, __builtin_apply_args(), 16);
}

int main(void)
{
  bar(INTEGER_ARG);

  return 0;
}
// source: pr47299.c
/* PR rtl-optimization/47299 */

extern void abort (void);

__attribute__ ((noinline, noclone)) unsigned short
foo (unsigned char x)
{
  return x * 255;
}

int
main ()
{
  if (foo (0x40) != 0x3fc0)
    abort ();
  return 0;
}
// source: pr47337.c
/* PR rtl-optimization/47337 */

static unsigned int a[256], b = 0;
static char c = 0;
static int d = 0, *f = &d;
static long long e = 0;

static short
foo (long long x, long long y)
{
  return x / y;
}

static char
bar (char x, char y)
{
  return x - y;
}

static int
baz (int x, int y)
{
  *f = (y != (short) (y * 3));
  for (c = 0; c < 2; c++)
    {
    lab:
      if (d)
	{
	  if (e)
	    e = 1;
	  else
	    return x;
	}
      else
	{
	  d = 1;
	  goto lab;
	}
      f = &d;
    }
  return x;
}

static void
fnx (unsigned long long x, int y)
{
  if (!y)
    {
      b = a[b & 1];
      b = a[b & 1];
      b = a[(b ^ (x & 1)) & 1];
      b = a[(b ^ (x & 1)) & 1];
    }
}

char *volatile w = "2";

int
main ()
{
  int h = 0;
  unsigned int k = 0;
  int l[8];
  int i, j;

  if (__builtin_strcmp (w, "1") == 0)
    h = 1;

  for (i = 0; i < 256; i++)
    {
      for (j = 8; j > 0; j--)
	k = 1;
      a[i] = k;
    }
  for (i = 0; i < 8; i++)
    l[i] = 0;

  d = bar (c, c);
  d = baz (c, 1 | foo (l[0], 10));
  fnx (d, h);
  fnx (e, h);

  if (d != 0)
    __builtin_abort ();
  return 0;
}
// source: pr47538.c
/* PR tree-optimization/47538 */

struct S
{
  double a, b, *c;
  unsigned long d;
};

__attribute__((noinline, noclone)) void
foo (struct S *x, const struct S *y)
{
  const unsigned long n = y->d + 1;
  const double m = 0.25 * (y->b - y->a);
  x->a = y->a;
  x->b = y->b;
  if (n == 1)
    {
      x->c[0] = 0.;
    }
  else if (n == 2)
    {
      x->c[1] = m * y->c[0];
      x->c[0] = 2.0 * x->c[1];
    }
  else
    {
      double o = 0.0, p = 1.0;
      unsigned long i;

      for (i = 1; i <= n - 2; i++)
	{
	  x->c[i] = m * (y->c[i - 1] - y->c[i + 1]) / (double) i;
	  o += p * x->c[i];
	  p = -p;
	}
      x->c[n - 1] = m * y->c[n - 2] / (n - 1.0);
      o += p * x->c[n - 1];
      x->c[0] = 2.0 * o;
    }
}

int
main (void)
{
  struct S x, y;
  double c[4] = { 10, 20, 30, 40 }, d[4], e[4] = { 118, 118, 118, 118 };

  y.a = 10;
  y.b = 6;
  y.c = c;
  x.c = d;
  y.d = 3;
  __builtin_memcpy (d, e, sizeof d);
  foo (&x, &y);
  if (d[0] != 0 || d[1] != 20 || d[2] != 10 || d[3] != -10)
    __builtin_abort ();
  y.d = 2;
  __builtin_memcpy (d, e, sizeof d);
  foo (&x, &y);
  if (d[0] != 60 || d[1] != 20 || d[2] != -10 || d[3] != 118)
    __builtin_abort ();
  y.d = 1;
  __builtin_memcpy (d, e, sizeof d);
  foo (&x, &y);
  if (d[0] != -20 || d[1] != -10 || d[2] != 118 || d[3] != 118)
    __builtin_abort ();
  y.d = 0;
  __builtin_memcpy (d, e, sizeof d);
  foo (&x, &y);
  if (d[0] != 0 || d[1] != 118 || d[2] != 118 || d[3] != 118)
    __builtin_abort ();
  return 0;
}
// source: pr47925.c
struct s { volatile struct s *next; };

void __attribute__((noinline))
bar (int ignored, int n)
{
  asm volatile ("");
}

int __attribute__((noinline))
foo (volatile struct s *ptr, int n)
{
  int i;

  bar (0, n);
  for (i = 0; i < n; i++)
    ptr = ptr->next;
}

int main (void)
{
  volatile struct s rec = { &rec };
  foo (&rec, 10);
  return 0;
}
// source: pr48197.c
/* PR c/48197 */

extern void abort (void);
static int y = 0x8000;

int
main ()
{
  unsigned int x = (short)y;
  if (sizeof (0LL) == sizeof (0U))
    return 0;
  if (0LL > (0U ^ (short)-0x8000))
    abort ();
  if (0LL > (0U ^ x))
    abort ();
  if (0LL > (0U ^ (short)y))
    abort ();
  if ((0U ^ (short)-0x8000) < 0LL)
    abort ();
  if ((0U ^ x) < 0LL)
    abort ();
  if ((0U ^ (short)y) < 0LL)
    abort ();
  return 0;
}
// source: pr48571-1.c
#define S (sizeof (int))

unsigned int c[624];
void __attribute__((noinline))
bar (void)
{
  unsigned int i;
  /* Obfuscated c[i] = c[i-1] * 2.  */
  for (i = 1; i < 624; ++i)
    *(unsigned int *)((void *)c + (__SIZE_TYPE__)i * S)
	= 2 * *(unsigned int *)((void *)c + ((__SIZE_TYPE__)i +
					     ((__SIZE_TYPE__)-S)/S) * S);
}
extern void abort (void);
int
main()
{
  unsigned int i, j;
  for (i = 0; i < 624; ++i)
    c[i] = 1;
  bar();
  j = 1;
  for (i = 0; i < 624; ++i)
    {
      if (c[i] != j)
	abort ();
      j = j * 2;
    }
  return 0;
}
// source: pr48717.c
/* PR tree-optimization/48717 */

extern void abort (void);

int v = 1, w;

unsigned short
foo (unsigned short x, unsigned short y)
{
  return x + y;
}

void
bar (void)
{
  v = foo (~w, w);
}

int
main ()
{
  bar ();
  if (v != (unsigned short) -1)
    abort ();
  return 0;
}
// source: pr48809.c
/* PR tree-optimization/48809 */

extern void abort (void);

int
foo (signed char x)
{
  int y = 0;
  switch (x)
    {
    case 0: y = 1; break;
    case 1: y = 7; break;
    case 2: y = 2; break;
    case 3: y = 19; break;
    case 4: y = 5; break;
    case 5: y = 17; break;
    case 6: y = 31; break;
    case 7: y = 8; break;
    case 8: y = 28; break;
    case 9: y = 16; break;
    case 10: y = 31; break;
    case 11: y = 12; break;
    case 12: y = 15; break;
    case 13: y = 111; break;
    case 14: y = 17; break;
    case 15: y = 10; break;
    case 16: y = 31; break;
    case 17: y = 7; break;
    case 18: y = 2; break;
    case 19: y = 19; break;
    case 20: y = 5; break;
    case 21: y = 107; break;
    case 22: y = 31; break;
    case 23: y = 8; break;
    case 24: y = 28; break;
    case 25: y = 106; break;
    case 26: y = 31; break;
    case 27: y = 102; break;
    case 28: y = 105; break;
    case 29: y = 111; break;
    case 30: y = 17; break;
    case 31: y = 10; break;
    case 32: y = 31; break;
    case 98: y = 18; break;
    case -62: y = 19; break;
    }
  return y;
}

int
main ()
{
  if (foo (98) != 18 || foo (97) != 0 || foo (99) != 0)
    abort ();
  if (foo (-62) != 19 || foo (-63) != 0 || foo (-61) != 0)
    abort ();
  if (foo (28) != 105 || foo (27) != 102 || foo (29) != 111)
    abort ();
  return 0;
}
// source: pr48814-1.c
extern void abort (void);

int arr[] = {1,2,3,4};
int count = 0;

int __attribute__((noinline))
incr (void)
{
  return ++count;
}

int main()
{
  arr[count++] = incr ();
  if (count != 2 || arr[count] != 3)
    abort ();
  return 0;
}
// source: pr48814-2.c
extern void abort (void);

int arr[] = {1,2,3,4};
int count = 0;

int
incr (void)
{
  return ++count;
}

int main()
{
  arr[count++] = incr ();
  if (count != 2 || arr[count] != 3)
    abort ();
  return 0;
}
// source: pr48973-1.c
/* PR middle-end/48973 */

extern void abort (void);
struct S { int f : 1; } s;
int v = -1;

void
foo (unsigned int x)
{
  if (x != -1U)
    abort ();
}

int
main ()
{
  s.f = (v & 1) > 0;
  foo (s.f);
  return 0;
}
// source: pr48973-2.c
/* PR middle-end/48973 */

extern void abort (void);
struct S { int f : 1; } s;
int v = -1;

int
main ()
{
  s.f = v < 0;
  if ((unsigned int) s.f != -1U)
    abort ();
  return 0;
}
// source: pr49039.c
/* PR tree-optimization/49039 */
extern void abort (void);
int cnt;

__attribute__((noinline, noclone)) void
foo (unsigned int x, unsigned int y)
{
  unsigned int minv, maxv;
  if (x == 1 || y == -2U)
    return;
  minv = x < y ? x : y;
  maxv = x > y ? x : y;
  if (minv == 1)
    ++cnt;
  if (maxv == -2U)
    ++cnt;
}

int
main ()
{
  foo (-2U, 1);
  if (cnt != 2)
    abort ();
  return 0;
}
// source: pr49073.c
/* PR tree-optimization/49073 */

extern void abort (void);
int a[] = { 1, 2, 3, 4, 5, 6, 7 }, c;

int
main ()
{
  int d = 1, i = 1;
  _Bool f = 0;
  do
    {
      d = a[i];
      if (f && d == 4)
	{
	  ++c;
	  break;
	}
      i++;
      f = (d == 3);
    }
  while (d < 7);
  if (c != 1)
    abort ();
  return 0;
}
// source: pr49123.c
/* PR lto/49123 */

extern void abort (void);
static struct S { int f : 1; } s;
static int v = -1;

int
main ()
{
  s.f = v < 0;
  if ((unsigned int) s.f != -1U)
    abort ();
  return 0;
}
// source: pr49161.c
/* PR tree-optimization/49161 */

extern void abort (void);

int c;

__attribute__((noinline, noclone)) void
bar (int x)
{
  if (x != c++)
    abort ();
}

__attribute__((noinline, noclone)) void
foo (int x)
{
  switch (x)
    {
    case 3: goto l1;
    case 4: goto l2;
    case 6: goto l3;
    default: return;
    }
l1:
  goto l4;
l2:
  goto l4;
l3:
  bar (-1);
l4:
  bar (0);
  if (x != 4)
    bar (1);
  if (x != 3)
    bar (-1);
  bar (2);
}

int
main ()
{
  foo (3);
  if (c != 3)
    abort ();
  return 0;
}
// source: pr49186.c
/* PR target/49186 */
extern void abort (void);

int
main ()
{
  int x;
  unsigned long long uv = 0x1000000001ULL;

  x = (uv < 0x80) ? 1 : ((uv < 0x800) ? 2 : 3);
  if (x != 3)
    abort ();

  return 0;
}
// source: pr49218.c
#ifdef __SIZEOF_INT128__
typedef __int128 L;
#else
typedef long long L;
#endif
float f;

int
main ()
{
  L i = f;
  if (i <= 10)
    do
      {
	++i;
	asm ("");
      }
    while (i != 11);
  return 0;
}
// source: pr49279.c
/* PR tree-optimization/49279 */
extern void abort (void);

struct S { int a; int *__restrict p; };

__attribute__((noinline, noclone))
struct S *bar (struct S *p)
{
  struct S *r;
  asm volatile ("" : "=r" (r) : "0" (p) : "memory");
  return r;
}

__attribute__((noinline, noclone))
int
foo (int *p, int *q)
{
  struct S s, *t;
  s.a = 1;
  s.p = p;
  t = bar (&s);
  t->p = q;
  s.p[0] = 0;
  t->p[0] = 1;
  return s.p[0];
}

int
main ()
{
  int a, b;
  if (foo (&a, &b) != 1)
    abort ();
  return 0;
}
// source: pr49281.c
/* PR target/49281 */

extern void abort (void);

__attribute__((noinline, noclone)) int
foo (int x)
{
  return (x << 2) | 4;
}

__attribute__((noinline, noclone)) int
bar (int x)
{
  return (x << 2) | 3;
}

int
main ()
{
  if (foo (43) != 172 || foo (1) != 4 || foo (2) != 12)
    abort ();
  if (bar (43) != 175 || bar (1) != 7 || bar (2) != 11)
    abort ();
  return 0;
}
// source: pr49390.c
/* PR rtl-optimization/49390 */

struct S { unsigned int s1; unsigned int s2; };
struct T { unsigned int t1; struct S t2; };
struct U { unsigned short u1; unsigned short u2; };
struct V { struct U v1; struct T v2; };
struct S a;
char *b;
union { char b[64]; struct V v; } u;
volatile int v;
extern void abort (void);

__attribute__((noinline, noclone)) void
foo (int x, void *y, unsigned int z, unsigned int w)
{
  if (x != 4 || y != (void *) &u.v.v2)
    abort ();
  v = z + w;
  v = 16384;
}

__attribute__((noinline, noclone)) void
bar (struct S x)
{
  v = x.s1;
  v = x.s2;
}

__attribute__((noinline, noclone)) int
baz (struct S *x)
{
  v = x->s1;
  v = x->s2;
  v = 0;
  return v + 1;
}

__attribute__((noinline, noclone)) void
test (struct S *c)
{
  struct T *d;
  struct S e = a;
  unsigned int f, g;
  if (c == 0)
    c = &e;
  else
    {
      if (c->s2 % 8192 <= 15 || (8192 - c->s2 % 8192) <= 31)
	foo (1, 0, c->s1, c->s2);
    }
  if (!baz (c))
    return;
  g = (((struct U *) b)->u2 & 2) ? 32 : __builtin_offsetof (struct V, v2);
  f = c->s2 % 8192;
  if (f == 0)
    {
      e.s2 += g;
      f = g;
    }
  else if (f < g)
    {
      foo (2, 0, c->s1, c->s2);
      return;
    }
  if ((((struct U *) b)->u2 & 1) && f == g)
    {
      bar (*c);
      foo (3, 0, c->s1, c->s2);
      return;
    }
  d = (struct T *) (b + c->s2 % 8192);
  if (d->t2.s1 >= c->s1 && (d->t2.s1 != c->s1 || d->t2.s2 >= c->s2))
    foo (4, d, c->s1, c->s2);
  return;
}

int
main ()
{
  struct S *c = 0;
  asm ("" : "+r" (c) : "r" (&a));
  u.v.v2.t2.s1 = 8192;
  b = u.b;
  test (c);
  if (v != 16384)
    abort ();
  return 0;
}
// source: pr49419.c
/* PR tree-optimization/49419 */

extern void abort (void);

struct S { int w, x, y; } *t;

int
foo (int n, int f, int *s, int m)
{
  int x, i, a;
  if (n == -1)
    return 0;
  for (x = n, i = 0; t[x].w == f && i < m; i++)
    x = t[x].x;
  if (i == m)
    abort ();
  a = i + 1;
  for (x = n; i > 0; i--)
    {
      s[i] = t[x].y;
      x = t[x].x;
    }
  s[0] = x;
  return a;
}

int
main (void)
{
  int s[3], i;
  struct S buf[3] = { { 1, 1, 2 }, { 0, 0, 0 }, { 0, 0, 0 } };
  t = buf;
  if (foo (0, 1, s, 3) != 2)
    abort ();
  if (s[0] != 1 || s[1] != 2)
    abort ();
  return 0;
}
// source: pr49644.c
/* PR c/49644 */

extern void abort (void);

int
main ()
{
  _Complex double a[12], *c = a, s = 3.0 + 1.0i;
  double b[12] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }, *d = b;
  int i;
  for (i = 0; i < 6; i++)
    *c++ = *d++ * s;
  if (c != a + 6 || d != b + 6)
    abort ();
  return 0;
}
// source: pr49712.c
/* PR tree-optimization/49712 */

int a[2], b, c, d, e;

void
foo (int x, int y)
{
}

int
bar (void)
{
  int i;
  for (; d <= 0; d = 1)
    for (i = 0; i < 4; i++)
      for (e = 0; e; e = 1)
	;
  return 0;
}

int
main ()
{
  for (b = 0; b < 2; b++)
    while (c)
      foo (a[b] = 0, bar ());
  return 0;
}
// source: pr49768.c
/* PR tree-optimization/49768 */

extern void abort (void);

int
main ()
{
  static struct { unsigned int : 1; unsigned int s : 1; } s = { .s = 1 };
  if (s.s != 1)
    abort ();
  return 0;
}
// source: pr49886.c
struct PMC {
    unsigned flags;
};

typedef struct Pcc_cell
{
    struct PMC *p;
    long bla;
    long type;
} Pcc_cell;

int gi;
int cond;

extern void abort ();
extern void never_ever(int interp, struct PMC *pmc)
  __attribute__((noinline,noclone));

void never_ever (int interp, struct PMC *pmc)
{
  abort ();
}

static void mark_cell(int * interp, Pcc_cell *c)
  __attribute__((__nonnull__(1)));

static void
mark_cell(int * interp, Pcc_cell *c)
{
  if (!cond)
    return;

  if (c && c->type == 4 && c->p
      && !(c->p->flags & (1<<18)))
    never_ever(gi + 1, c->p);
  if (c && c->type == 4 && c->p
      && !(c->p->flags & (1<<17)))
    never_ever(gi + 2, c->p);
  if (c && c->type == 4 && c->p
      && !(c->p->flags & (1<<16)))
    never_ever(gi + 3, c->p);
  if (c && c->type == 4 && c->p
      && !(c->p->flags & (1<<15)))
    never_ever(gi + 4, c->p);
  if (c && c->type == 4 && c->p
      && !(c->p->flags & (1<<14)))
    never_ever(gi + 5, c->p);
  if (c && c->type == 4 && c->p
      && !(c->p->flags & (1<<13)))
    never_ever(gi + 6, c->p);
  if (c && c->type == 4 && c->p
      && !(c->p->flags & (1<<12)))
    never_ever(gi + 7, c->p);
  if (c && c->type == 4 && c->p
      && !(c->p->flags & (1<<11)))
    never_ever(gi + 8, c->p);
  if (c && c->type == 4 && c->p
      && !(c->p->flags & (1<<10)))
    never_ever(gi + 9, c->p);
}

static void
foo(int * interp, Pcc_cell *c)
{
  mark_cell(interp, c);
}

static struct Pcc_cell *
__attribute__((noinline,noclone))
getnull(void)
{
  return (struct Pcc_cell *) 0;
}


int main()
{
  int i;

  cond = 1;
  for (i = 0; i < 100; i++)
    foo (&gi, getnull ());
  return 0;
}


void
bar_1 (int * interp, Pcc_cell *c)
{
  c->bla += 1;
  mark_cell(interp, c);
}

void
bar_2 (int * interp, Pcc_cell *c)
{
  c->bla += 2;
  mark_cell(interp, c);
}
// source: pr50865.c
/* PR middle-end/50865 */

#define INT64_MIN (-__LONG_LONG_MAX__ - 1)

int
main ()
{
  volatile long long l1 = 1;
  volatile long long l2 = -1;
  volatile long long l3 = -1;

  if ((INT64_MIN % 1LL) != 0)
    __builtin_abort ();
  if ((INT64_MIN % l1) != 0)
    __builtin_abort ();
  if (l2 == -1)
    {
      if ((INT64_MIN % 1LL) != 0)
	__builtin_abort ();
    }
  else if ((INT64_MIN % -l2) != 0)
    __builtin_abort ();
  if ((INT64_MIN % -l3) != 0)
    __builtin_abort ();

  return 0;
}
// source: pr51023.c
/* PR rtl-optimization/51023 */

extern void abort (void);

short int
foo (long int x)
{
  return x;
}

int
main ()
{
  long int a = 0x4272AL;
  if (foo (a) == a)
    abort ();
  return 0;
}
// source: pr51323.c
/* PR middle-end/51323 */

extern void abort (void);
struct S { int a, b, c; };
int v;

__attribute__((noinline, noclone)) void
foo (int x, int y, int z)
{
  if (x != v || y != 0 || z != 9)
    abort ();
}

static inline int
baz (const struct S *p)
{
  return p->b;
}

__attribute__((noinline, noclone)) void
bar (int x, struct S y)
{
  foo (baz (&y), 0, x);
}

int
main ()
{
  struct S s;
  v = 3; s.a = v - 1; s.b = v; s.c = v + 1;
  bar (9, s);
  v = 17; s.a = v - 1; s.b = v; s.c = v + 1;
  bar (9, s);
  return 0;
}
// source: pr51447.c
/* PR rtl-optimization/51447 */
/* { dg-require-effective-target label_values } */
/* { dg-require-effective-target indirect_jumps } */

extern void abort (void);

#ifdef __x86_64__
register void *ptr asm ("rbx");
#else
void *ptr;
#endif

int
main (void)
{
  __label__ nonlocal_lab;
  __attribute__((noinline, noclone)) void
    bar (void *func)
      {
	ptr = func;
	goto nonlocal_lab;
      }
  bar (&&nonlocal_lab);
  return 1;
nonlocal_lab:
  if (ptr != &&nonlocal_lab)
    abort ();
  return 0;
}
// source: pr51466.c
/* PR tree-optimization/51466 */

extern void abort (void);

__attribute__((noinline, noclone)) int
foo (int i)
{
  volatile int v[4];
  int *p;
  v[i] = 6;
  p = (int *) &v[i];
  return *p;
}

__attribute__((noinline, noclone)) int
bar (int i)
{
  volatile int v[4];
  int *p;
  v[i] = 6;
  p = (int *) &v[i];
  *p = 8;
  return v[i];
}

__attribute__((noinline, noclone)) int
baz (int i)
{
  volatile int v[4];
  int *p;
  v[i] = 6;
  p = (int *) &v[0];
  *p = 8;
  return v[i];
}

int
main ()
{
  if (foo (3) != 6 || bar (2) != 8 || baz (0) != 8 || baz (1) != 6)
    abort ();
  return 0;
}
// source: pr51581-1.c
/* PR tree-optimization/51581 */

/* { dg-require-effective-target int32plus } */

extern void abort (void);

#define N 4096
int a[N], c[N];
unsigned int b[N], d[N];

__attribute__((noinline, noclone)) void
f1 (void)
{
  int i;
  for (i = 0; i < N; i++)
    c[i] = a[i] / 3;
}

__attribute__((noinline, noclone)) void
f2 (void)
{
  int i;
  for (i = 0; i < N; i++)
    d[i] = b[i] / 3;
}

__attribute__((noinline, noclone)) void
f3 (void)
{
  int i;
  for (i = 0; i < N; i++)
    c[i] = a[i] / 18;
}

__attribute__((noinline, noclone)) void
f4 (void)
{
  int i;
  for (i = 0; i < N; i++)
    d[i] = b[i] / 18;
}

__attribute__((noinline, noclone)) void
f5 (void)
{
  int i;
  for (i = 0; i < N; i++)
    c[i] = a[i] / 19;
}

__attribute__((noinline, noclone)) void
f6 (void)
{
  int i;
  for (i = 0; i < N; i++)
    d[i] = b[i] / 19;
}

#if __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8
__attribute__((noinline, noclone)) void
f7 (void)
{
  int i;
  for (i = 0; i < N; i++)
    c[i] = (int) ((unsigned long long) (a[i] * 0x55555556LL) >> 32) - (a[i] >> 31);
}

__attribute__((noinline, noclone)) void
f8 (void)
{
  int i;
  for (i = 0; i < N; i++)
    d[i] = ((unsigned int) ((b[i] * 0xaaaaaaabULL) >> 32) >> 1);
}

__attribute__((noinline, noclone)) void
f9 (void)
{
  int i;
  for (i = 0; i < N; i++)
    c[i] = (((int) ((unsigned long long) (a[i] * 0x38e38e39LL) >> 32)) >> 2) - (a[i] >> 31);
}

__attribute__((noinline, noclone)) void
f10 (void)
{
  int i;
  for (i = 0; i < N; i++)
    d[i] = (unsigned int) ((b[i] * 0x38e38e39ULL) >> 32) >> 2;
}

__attribute__((noinline, noclone)) void
f11 (void)
{
  int i;
  for (i = 0; i < N; i++)
    c[i] = (((int) ((unsigned long long) (a[i] * 0x6bca1af3LL) >> 32)) >> 3) - (a[i] >> 31);
}

__attribute__((noinline, noclone)) void
f12 (void)
{
  int i;
  for (i = 0; i < N; i++)
    {
      unsigned int tmp = (b[i] * 0xaf286bcbULL) >> 32;
      d[i] = (((b[i] - tmp) >> 1) + tmp) >> 4;
    }
}
#endif

int
main ()
{
  int i;
  for (i = 0; i < N; i++)
    {
      asm ("");
      a[i] = i - N / 2;
      b[i] = i;
    }
  a[0] = -__INT_MAX__ - 1;
  a[1] = -__INT_MAX__;
  a[N - 1] = __INT_MAX__;
  b[N - 1] = ~0;
  f1 ();
  f2 ();
  for (i = 0; i < N; i++)
    if (c[i] != a[i] / 3 || d[i] != b[i] / 3)
      abort ();
  f3 ();
  f4 ();
  for (i = 0; i < N; i++)
    if (c[i] != a[i] / 18 || d[i] != b[i] / 18)
      abort ();
  f5 ();
  f6 ();
  for (i = 0; i < N; i++)
    if (c[i] != a[i] / 19 || d[i] != b[i] / 19)
      abort ();
#if __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8
  f7 ();
  f8 ();
  for (i = 0; i < N; i++)
    if (c[i] != a[i] / 3 || d[i] != b[i] / 3)
      abort ();
  f9 ();
  f10 ();
  for (i = 0; i < N; i++)
    if (c[i] != a[i] / 18 || d[i] != b[i] / 18)
      abort ();
  f11 ();
  f12 ();
  for (i = 0; i < N; i++)
    if (c[i] != a[i] / 19 || d[i] != b[i] / 19)
      abort ();
#endif
  return 0;
}
// source: pr51581-2.c
/* PR tree-optimization/51581 */
/* { dg-require-effective-target int32plus } */

extern void abort (void);

#define N 4096
int a[N], c[N];
unsigned int b[N], d[N];

__attribute__((noinline, noclone)) void
f1 (void)
{
  int i;
  for (i = 0; i < N; i++)
    c[i] = a[i] % 3;
}

__attribute__((noinline, noclone)) void
f2 (void)
{
  int i;
  for (i = 0; i < N; i++)
    d[i] = b[i] % 3;
}

__attribute__((noinline, noclone)) void
f3 (void)
{
  int i;
  for (i = 0; i < N; i++)
    c[i] = a[i] % 18;
}

__attribute__((noinline, noclone)) void
f4 (void)
{
  int i;
  for (i = 0; i < N; i++)
    d[i] = b[i] % 18;
}

__attribute__((noinline, noclone)) void
f5 (void)
{
  int i;
  for (i = 0; i < N; i++)
    c[i] = a[i] % 19;
}

__attribute__((noinline, noclone)) void
f6 (void)
{
  int i;
  for (i = 0; i < N; i++)
    d[i] = b[i] % 19;
}

#if __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8
__attribute__((noinline, noclone)) void
f7 (void)
{
  int i;
  for (i = 0; i < N; i++)
    {
      int x = (int) ((unsigned long long) (a[i] * 0x55555556LL) >> 32) - (a[i] >> 31);
      c[i] = a[i] - x * 3;
    }
}

__attribute__((noinline, noclone)) void
f8 (void)
{
  int i;
  for (i = 0; i < N; i++)
    {
      unsigned int x = ((unsigned int) ((b[i] * 0xaaaaaaabULL) >> 32) >> 1);
      d[i] = b[i] - x * 3;
    }
}

__attribute__((noinline, noclone)) void
f9 (void)
{
  int i;
  for (i = 0; i < N; i++)
    {
      int x = (((int) ((unsigned long long) (a[i] * 0x38e38e39LL) >> 32)) >> 2) - (a[i] >> 31);
      c[i] = a[i] - x * 18;
    }
}

__attribute__((noinline, noclone)) void
f10 (void)
{
  int i;
  for (i = 0; i < N; i++)
    {
      unsigned int x = (unsigned int) ((b[i] * 0x38e38e39ULL) >> 32) >> 2;
      d[i] = b[i] - x * 18;
    }
}

__attribute__((noinline, noclone)) void
f11 (void)
{
  int i;
  for (i = 0; i < N; i++)
    {
      int x = (((int) ((unsigned long long) (a[i] * 0x6bca1af3LL) >> 32)) >> 3) - (a[i] >> 31);
      c[i] = a[i] - x * 19;
    }
}

__attribute__((noinline, noclone)) void
f12 (void)
{
  int i;
  for (i = 0; i < N; i++)
    {
      unsigned int tmp = (b[i] * 0xaf286bcbULL) >> 32;
      unsigned int x = (((b[i] - tmp) >> 1) + tmp) >> 4;
      d[i] = b[i] - x * 19;
    }
}
#endif

int
main ()
{
  int i;
  for (i = 0; i < N; i++)
    {
      asm ("");
      a[i] = i - N / 2;
      b[i] = i;
    }
  a[0] = -__INT_MAX__ - 1;
  a[1] = -__INT_MAX__;
  a[N - 1] = __INT_MAX__;
  b[N - 1] = ~0;
  f1 ();
  f2 ();
  for (i = 0; i < N; i++)
    if (c[i] != a[i] % 3 || d[i] != b[i] % 3)
      abort ();
  f3 ();
  f4 ();
  for (i = 0; i < N; i++)
    if (c[i] != a[i] % 18 || d[i] != b[i] % 18)
      abort ();
  f5 ();
  f6 ();
  for (i = 0; i < N; i++)
    if (c[i] != a[i] % 19 || d[i] != b[i] % 19)
      abort ();
#if __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8
  f7 ();
  f8 ();
  for (i = 0; i < N; i++)
    if (c[i] != a[i] % 3 || d[i] != b[i] % 3)
      abort ();
  f9 ();
  f10 ();
  for (i = 0; i < N; i++)
    if (c[i] != a[i] % 18 || d[i] != b[i] % 18)
      abort ();
  f11 ();
  f12 ();
  for (i = 0; i < N; i++)
    if (c[i] != a[i] % 19 || d[i] != b[i] % 19)
      abort ();
#endif
  return 0;
}
// source: pr51877.c
/* PR tree-optimization/51877 */

extern void abort (void);
struct A { int a; char b[32]; } a, b;

__attribute__((noinline, noclone))
struct A
bar (int x)
{
  struct A r;
  static int n;
  r.a = ++n;
  __builtin_memset (r.b, 0, sizeof (r.b));
  r.b[0] = x;
  return r;
}

__attribute__((noinline, noclone))
void
baz (void)
{
  asm volatile ("" : : : "memory");
}

__attribute__((noinline, noclone))
void
foo (struct A *x, int y)
{
  if (y == 6)
    a = bar (7);
  else
    *x = bar (7);
  baz ();
}

int
main ()
{
  a = bar (3);
  b = bar (4);
  if (a.a != 1 || a.b[0] != 3 || b.a != 2 || b.b[0] != 4)
    abort ();
  foo (&b, 0);
  if (a.a != 1 || a.b[0] != 3 || b.a != 3 || b.b[0] != 7)
    abort ();
  foo (&b, 6);
  if (a.a != 4 || a.b[0] != 7 || b.a != 3 || b.b[0] != 7)
    abort ();
  return 0;
}
// source: pr51933.c
/* PR rtl-optimization/51933 */

static signed char v1;
static unsigned char v2[256], v3[256];

__attribute__((noclone, noinline)) void
foo (void)
{
#if defined(__s390__) && !defined(__zarch__)
  /* S/390 31 bit cannot deal with more than one literal pool
     reference per insn.  */
  asm volatile ("" : : "g" (&v1) : "memory");
  asm volatile ("" : : "g" (&v2[0]));
  asm volatile ("" : : "g" (&v3[0]));
#else
  asm volatile ("" : : "g" (&v1), "g" (&v2[0]), "g" (&v3[0]) : "memory");
#endif
}

__attribute__((noclone, noinline)) int
bar (const int x, const unsigned short *y, char *z)
{
  int i;
  unsigned short u;
  if (!v1)
    foo ();
  for (i = 0; i < x; i++)
    {
      u = y[i];
      z[i] = u < 0x0100 ? v2[u] : v3[u & 0xff];
    }
  z[x] = '\0';
  return x;
}

int
main (void)
{
  char buf[18];
  unsigned short s[18];
  unsigned char c[18] = "abcdefghijklmnopq";
  int i;
  for (i = 0; i < 256; i++)
    {
      v2[i] = i;
      v3[i] = i + 1;
    }
  for (i = 0; i < 18; i++)
    s[i] = c[i];
  s[5] |= 0x600;
  s[6] |= 0x500;
  s[11] |= 0x2000;
  s[15] |= 0x500;
  foo ();
  if (bar (17, s, buf) != 17
      || __builtin_memcmp (buf, "abcdeghhijkmmnoqq", 18) != 0)
    __builtin_abort ();
  return 0;
}
// source: pr52129.c
/* PR target/52129 */
/* { dg-xfail-if "ptxas crashes" { nvptx-*-* } { "-O1" } { "" } } */

extern void abort (void);
struct S { void *p; unsigned int q; };
struct T { char a[64]; char b[64]; } t;

__attribute__((noinline, noclone)) int
foo (void *x, struct S s, void *y, void *z)
{
  if (x != &t.a[2] || s.p != &t.b[5] || s.q != 27 || y != &t.a[17] || z != &t.b[17])
    abort ();
  return 29;
}

__attribute__((noinline, noclone)) int
bar (void *x, void *y, void *z, struct S s, int t, struct T *u)
{
  return foo (x, s, &u->a[t], &u->b[t]);
}

int
main ()
{
  struct S s = { &t.b[5], 27 };
  if (bar (&t.a[2], (void *) 0, (void *) 0, s, 17, &t) != 29)
    abort ();
  return 0;
}
// source: pr52209.c
/* PR middle-end/52209 */

extern void abort (void);
struct S0 { int f2 : 1; } c;
int b;

int
main ()
{
  b = -1 ^ c.f2;
  if (b != -1)
    abort ();
  return 0;
}
// source: pr52286.c
/* PR tree-optimization/52286 */

extern void abort (void);

int
main ()
{
#if __SIZEOF_INT__ > 2
  int a, b;
  asm ("" : "=r" (a) : "0" (0));
  b = (~a | 1) & -2038094497;
#else
  long a, b;
  asm ("" : "=r" (a) : "0" (0));
  b = (~a | 1) & -2038094497L;
#endif
  if (b >= 0)
    abort ();
  return 0;
}
// source: pr52760.c
/* PR tree-optimization/52760 */

struct T { unsigned short a, b, c, d; };

__attribute__((noinline, noclone)) void
foo (int x, struct T *y)
{
  int i;

  for (i = 0; i < x; i++)
    {
      y[i].a = ((0x00ff & y[i].a >> 8) | (0xff00 & y[i].a << 8));
      y[i].b = ((0x00ff & y[i].b >> 8) | (0xff00 & y[i].b << 8));
      y[i].c = ((0x00ff & y[i].c >> 8) | (0xff00 & y[i].c << 8));
      y[i].d = ((0x00ff & y[i].d >> 8) | (0xff00 & y[i].d << 8));
    }
}

int
main ()
{
  struct T t = { 0x0001, 0x0203, 0x0405, 0x0607 };
  foo (1, &t);
  if (t.a != 0x0100 || t.b != 0x0302 || t.c != 0x0504 || t.d != 0x0706)
    __builtin_abort ();
  return 0;
}
// source: pr52979-1.c
/* PR middle-end/52979 */

/* { dg-require-effective-target int32plus } */

extern void abort (void);
int c, d, e;

void
foo (void)
{
}

struct __attribute__((packed)) S { int g : 31; int h : 6; };
struct S a = { 1 };
static struct S b = { 1 };

void
bar (void)
{
  a.h = 1;
  struct S f = { };
  b = f;
  e = 0;
  if (d)
    c = a.g;
}

void
baz (void)
{
  bar ();
  a = b;
}

int
main ()
{
  baz ();
  if (a.g)
    abort ();
  return 0;
}
// source: pr52979-2.c
/* PR middle-end/52979 */
/* { dg-require-effective-target int32plus } */

extern void abort (void);
int c, d, e;

void
foo (void)
{
}

struct __attribute__((packed)) S { int g : 31; int h : 6; };
static struct S b = { 1 };
struct S a = { 1 };

void
bar (void)
{
  a.h = 1;
  struct S f = { };
  b = f;
  e = 0;
  if (d)
    c = a.g;
}

void
baz (void)
{
  bar ();
  a = b;
}

int
main ()
{
  baz ();
  if (a.g)
    abort ();
  return 0;
}
// source: pr53084.c
/* PR middle-end/53084 */

extern void abort (void);

__attribute__((noinline, noclone)) void
bar (const char *p)
{
  if (p[0] != 'o' || p[1] != 'o' || p[2])
    abort ();
}

int
main ()
{
  static const char *const foo[] = {"foo" + 1};
  bar (foo[0]);
  return 0;
}
// source: pr53160.c
/* PR rtl-optimization/53160 */

extern void abort (void);

int a, c = 1, d, e, g;
volatile int b;
volatile char f;
long h;
short i;

void
foo (void)
{
  for (e = 0; e; ++e)
    ;
}

int
main ()
{
  if (g)
    (void) b;
  foo ();
  for (d = 0; d >= 0; d--)
    {
      short j = f;
      int k = 0;
      i = j ? j : j << k;
    }
  h = c == 0 ? 0 : i;
  a = h;
  if (a != 0)
    abort ();
  return 0;
}
// source: pr53465.c
/* PR tree-optimization/53465 */

extern void abort ();

static const int a[] = { 1, 2 };

void
foo (const int *x, int y)
{
  int i;
  int b = 0;
  int c;
  for (i = 0; i < y; i++)
    {
      int d = x[i];
      if (d == 0)
	break;
      if (b && d <= c)
	abort ();
      c = d;
      b = 1;
    }
}

int
main ()
{
  foo (a, 2);
  return 0;
}
// source: pr53645-2.c
/* PR tree-optimization/53645 */
/* { dg-options "-std=gnu89" } */

typedef unsigned short int UV __attribute__((vector_size (16)));
typedef short int SV __attribute__((vector_size (16)));
extern void abort (void);

#define TEST(a, b, c, d, e, f, g, h) \
__attribute__((noinline)) void			\
uq##a##b##c##d##e##f##g##h (UV *x, UV *y) 	\
{						\
  *x = *y / ((UV) { a, b, c, d, e, f, g, h });	\
}						\
						\
__attribute__((noinline)) void			\
ur##a##b##c##d##e##f##g##h (UV *x, UV *y) 	\
{						\
  *x = *y % ((UV) { a, b, c, d, e, f, g, h });	\
}						\
						\
__attribute__((noinline)) void			\
sq##a##b##c##d##e##f##g##h (SV *x, SV *y) 	\
{						\
  *x = *y / ((SV) { a, b, c, d, e, f, g, h });	\
}						\
						\
__attribute__((noinline)) void			\
sr##a##b##c##d##e##f##g##h (SV *x, SV *y) 	\
{						\
  *x = *y % ((SV) { a, b, c, d, e, f, g, h });	\
}

#define TESTS \
TEST (4, 4, 4, 4, 4, 4, 4, 4)		\
TEST (1, 4, 2, 8, 16, 64, 32, 128)	\
TEST (3, 3, 3, 3, 3, 3, 3, 3)		\
TEST (6, 5, 6, 5, 6, 5, 6, 5)		\
TEST (14, 14, 14, 6, 14, 6, 14, 14)	\
TEST (7, 7, 7, 7, 7, 7, 7, 7)		\

TESTS

UV u[] =
  { ((UV) { 73U, 65531U, 0U, 174U, 921U, 65535U, 17U, 178U }),
    ((UV) { 1U, 8173U, 65535U, 65472U, 12U, 29612U, 128U, 8912U }) };
SV s[] =
  { ((SV) { 73, -9123, 32761, 8191, 16371, 1201, 12701, 9999 }),
    ((SV) { 9903, -1, -7323, 0, -7, -323, 9124, -9199 }) };

int
main ()
{
  UV ur, ur2;
  SV sr, sr2;
  int i;
#undef TEST
#define TEST(a, b, c, d, e, f, g, h)			\
    uq##a##b##c##d##e##f##g##h (&ur, u + i);		\
    if (ur[0] != u[i][0] / a || ur[3] != u[i][3] / d)	\
     abort ();						\
    asm volatile ("" : : "r" (&ur) : "memory");		\
    if (ur[2] != u[i][2] / c || ur[1] != u[i][1] / b)	\
     abort ();						\
    asm volatile ("" : : "r" (&ur) : "memory");		\
    if (ur[4] != u[i][4] / e || ur[7] != u[i][7] / h)	\
     abort ();						\
    asm volatile ("" : : "r" (&ur) : "memory");		\
    if (ur[6] != u[i][6] / g || ur[5] != u[i][5] / f)	\
     abort ();						\
    asm volatile ("" : : "r" (&ur) : "memory");		\
    ur##a##b##c##d##e##f##g##h (&ur, u + i);		\
    if (ur[0] != u[i][0] % a || ur[3] != u[i][3] % d)	\
     abort ();						\
    asm volatile ("" : : "r" (&ur) : "memory");		\
    if (ur[2] != u[i][2] % c || ur[1] != u[i][1] % b)	\
     abort ();						\
    asm volatile ("" : : "r" (&ur) : "memory");		\
    if (ur[4] != u[i][4] % e || ur[7] != u[i][7] % h)	\
     abort ();						\
    asm volatile ("" : : "r" (&ur) : "memory");		\
    if (ur[6] != u[i][6] % g || ur[5] != u[i][5] % f)	\
     abort ();						\
    asm volatile ("" : : "r" (&ur) : "memory");
  for (i = 0; i < sizeof (u) / sizeof (u[0]); i++)
    {
      TESTS
    }
#undef TEST
#define TEST(a, b, c, d, e, f, g, h)			\
    sq##a##b##c##d##e##f##g##h (&sr, s + i);		\
    if (sr[0] != s[i][0] / a || sr[3] != s[i][3] / d)	\
     abort ();						\
    asm volatile ("" : : "r" (&sr) : "memory");		\
    if (sr[2] != s[i][2] / c || sr[1] != s[i][1] / b)	\
     abort ();						\
    asm volatile ("" : : "r" (&sr) : "memory");		\
    if (sr[4] != s[i][4] / e || sr[7] != s[i][7] / h)	\
     abort ();						\
    asm volatile ("" : : "r" (&sr) : "memory");		\
    if (sr[6] != s[i][6] / g || sr[5] != s[i][5] / f)	\
     abort ();						\
    asm volatile ("" : : "r" (&sr) : "memory");		\
    sr##a##b##c##d##e##f##g##h (&sr, s + i);		\
    if (sr[0] != s[i][0] % a || sr[3] != s[i][3] % d)	\
     abort ();						\
    asm volatile ("" : : "r" (&sr) : "memory");		\
    if (sr[2] != s[i][2] % c || sr[1] != s[i][1] % b)	\
     abort ();						\
    asm volatile ("" : : "r" (&sr) : "memory");		\
    if (sr[4] != s[i][4] % e || sr[7] != s[i][7] % h)	\
     abort ();						\
    asm volatile ("" : : "r" (&sr) : "memory");		\
    if (sr[6] != s[i][6] % g || sr[5] != s[i][5] % f)	\
     abort ();						\
    asm volatile ("" : : "r" (&sr) : "memory");
  for (i = 0; i < sizeof (s) / sizeof (s[0]); i++)
    {
      TESTS
    }
  return 0;
}
// source: pr53645.c
/* PR tree-optimization/53645 */
/* { dg-options "-std=gnu89" } */

typedef unsigned int UV __attribute__((vector_size (16)));
typedef int SV __attribute__((vector_size (16)));
extern void abort (void);

#define TEST(a, b, c, d) \
__attribute__((noinline)) void		\
uq##a##b##c##d (UV *x, UV *y) 		\
{					\
  *x = *y / ((UV) { a, b, c, d });	\
}					\
					\
__attribute__((noinline)) void		\
ur##a##b##c##d (UV *x, UV *y) 		\
{					\
  *x = *y % ((UV) { a, b, c, d });	\
}					\
					\
__attribute__((noinline)) void		\
sq##a##b##c##d (SV *x, SV *y) 		\
{					\
  *x = *y / ((SV) { a, b, c, d });	\
}					\
					\
__attribute__((noinline)) void		\
sr##a##b##c##d (SV *x, SV *y) 		\
{					\
  *x = *y % ((SV) { a, b, c, d });	\
}

#define TESTS \
TEST (4, 4, 4, 4)			\
TEST (1, 4, 2, 8)			\
TEST (3, 3, 3, 3)			\
TEST (6, 5, 6, 5)			\
TEST (14, 14, 14, 6)			\
TEST (7, 7, 7, 7)			\

TESTS

UV u[] =
  { ((UV) { 73U, 65531U, 0U, 174U }),
    ((UV) { 1U, 8173U, ~0U, ~0U - 63 }) };
SV s[] =
  { ((SV) { 73, -9123, 32761, 8191 }),
    ((SV) { 9903, -1, -7323, 0 }) };

int
main ()
{
  UV ur, ur2;
  SV sr, sr2;
  int i;
#undef TEST
#define TEST(a, b, c, d)				\
    uq##a##b##c##d (&ur, u + i);			\
    if (ur[0] != u[i][0] / a || ur[3] != u[i][3] / d)	\
     abort ();						\
    asm volatile ("" : : "r" (&ur) : "memory");		\
    if (ur[2] != u[i][2] / c || ur[1] != u[i][1] / b)	\
     abort ();						\
    asm volatile ("" : : "r" (&ur) : "memory");		\
    ur##a##b##c##d (&ur, u + i);			\
    if (ur[0] != u[i][0] % a || ur[3] != u[i][3] % d)	\
     abort ();						\
    asm volatile ("" : : "r" (&ur) : "memory");		\
    if (ur[2] != u[i][2] % c || ur[1] != u[i][1] % b)	\
     abort ();						\
    asm volatile ("" : : "r" (&ur) : "memory");
  for (i = 0; i < sizeof (u) / sizeof (u[0]); i++)
    {
      TESTS
    }
#undef TEST
#define TEST(a, b, c, d)				\
    sq##a##b##c##d (&sr, s + i);			\
    if (sr[0] != s[i][0] / a || sr[3] != s[i][3] / d)	\
     abort ();						\
    asm volatile ("" : : "r" (&sr) : "memory");		\
    if (sr[2] != s[i][2] / c || sr[1] != s[i][1] / b)	\
     abort ();						\
    asm volatile ("" : : "r" (&sr) : "memory");		\
    sr##a##b##c##d (&sr, s + i);			\
    if (sr[0] != s[i][0] % a || sr[3] != s[i][3] % d)	\
     abort ();						\
    asm volatile ("" : : "r" (&sr) : "memory");		\
    if (sr[2] != s[i][2] % c || sr[1] != s[i][1] % b)	\
     abort ();						\
    asm volatile ("" : : "r" (&sr) : "memory");
  for (i = 0; i < sizeof (s) / sizeof (s[0]); i++)
    {
      TESTS
    }
  return 0;
}
// source: pr53688.c
char headline[256];
struct hdr {
  char part1[9];
  char part2[8];
} p;

void __attribute__((noinline,noclone))
init()
{
  __builtin_memcpy (p.part1, "FOOBARFOO", sizeof (p.part1));
  __builtin_memcpy (p.part2, "SPEC CPU", sizeof (p.part2));
}

int main()
{
  char *x;
  int c;
  init();
  __builtin_memcpy (&headline[0], p.part1, 9);
  c = 9;
  x = &headline[0];
  x = x + c;
  __builtin_memset (x, ' ', 245);
  __builtin_memcpy (&headline[10], p.part2, 8);
  c = 18;
  x = &headline[0];
  x = x + c;
  __builtin_memset (x, ' ', 238);
  if (headline[10] != 'S')
    __builtin_abort ();
  return 0;
}
// source: pr54471.c
/* PR tree-optimization/54471 */

#ifdef __SIZEOF_INT128__
#define T __int128
#else
#define T long long
#endif

extern void abort (void);

__attribute__ ((noinline))
unsigned T
foo (T ixi, unsigned ctr)
{
  unsigned T irslt = 1;
  T ix = ixi;

  for (; ctr; ctr--)
    {
      irslt *= ix;
      ix *= ix;
    }

  if (irslt != 14348907)
    abort ();
  return irslt;
}

int
main ()
{
  unsigned T res;

  res = foo (3, 4);
  return 0;
}
// source: pr54937.c

void exit (int);
void abort (void);
int a[1];
void (*terminate_me)(int);

__attribute__((noinline,noclone))
t(int c)
{ int i;
  for (i=0;i<c;i++)
    {
      if (i)
       terminate_me(0);
      a[i]=0;
    }
}
main()
{
  terminate_me = exit;
  t(100);
  abort();
}
// source: pr54985.c

typedef struct st {
    int a;
} ST;

int __attribute__((noinline,noclone))
foo(ST *s, int c)
{
  int first = 1;
  int count = c;
  ST *item = s;
  int a = s->a;
  int x;

  while (count--)
    {
      x = item->a;
      if (first)
        first = 0;
      else if (x >= a)
        return 1;
      a = x;
      item++;
    }
  return 0;
}

extern void abort (void);

int main ()
{
  ST _1[2] = {{2}, {1}};
  if (foo(_1, 2) != 0)
    abort ();
  return 0;
}
// source: pr55137.c
/* PR c++/55137 */

extern void abort (void);

int
foo (unsigned int x)
{
  return ((int) (x + 1U) + 1) < (int) x;
}

int
bar (unsigned int x)
{
  return (int) (x + 1U) + 1;
}

int
baz (unsigned int x)
{
  return x + 1U;
}

int
main ()
{
  if (foo (__INT_MAX__) != (bar (__INT_MAX__) < __INT_MAX__)
      || foo (__INT_MAX__) != ((int) baz (__INT_MAX__) + 1 < __INT_MAX__))
    abort ();
  return 0;
}
// source: pr55750.c
/* PR middle-end/55750 */

extern void abort (void);

struct S
{
  int m : 1;
  int n : 7;
} arr[2];

__attribute__((noinline, noclone)) void
foo (unsigned i)
{
  arr[i].n++;
}

int
main ()
{
  arr[0].m = -1;
  arr[0].n = (1 << 6) - 1;
  arr[1].m = 0;
  arr[1].n = -1;
  foo (0);
  foo (1);
  if (arr[0].m != -1 || arr[0].n != -(1 << 6) || arr[1].m != 0 || arr[1].n != 0)
    abort ();
  return 0;
}
// source: pr55875.c
int a[251];
__attribute__ ((noinline))
t(int i)
{
  if (i==0)
    exit(0);
  if (i>255)
    abort ();
}
main()
{
  unsigned int i;
  for (i=0;;i++)
    {
      a[i]=t((unsigned char)(i+5));
    }
}
// source: pr56051.c
/* PR tree-optimization/56051 */

extern void abort (void);

int
main ()
{
  unsigned char x1[1] = { 0 };
  unsigned int s1 = __CHAR_BIT__;
  int a1 = x1[0] < (unsigned char) (1 << s1);
  unsigned char y1 = (unsigned char) (1 << s1);
  int b1 = x1[0] < y1;
  if (a1 != b1)
    abort ();
#if __SIZEOF_LONG_LONG__ > __SIZEOF_INT__
  unsigned long long x2[1] = { 2ULL << (sizeof (int) * __CHAR_BIT__) };
  unsigned int s2 = sizeof (int) * __CHAR_BIT__ - 1;
  int a2 = x2[0] >= (unsigned long long) (1 << s2);
  unsigned long long y2 = 1 << s2;
  int b2 = x2[0] >= y2;
  if (a2 != b2)
    abort ();
  unsigned long long x3[1] = { 2ULL << (sizeof (int) * __CHAR_BIT__) };
  unsigned int s3 = sizeof (int) * __CHAR_BIT__ - 1;
  int a3 = x3[0] >= (unsigned long long) (1U << s3);
  unsigned long long y3 = 1U << s3;
  int b3 = x3[0] >= y3;
  if (a3 != b3)
    abort ();
#endif
  return 0;
}
// source: pr56205.c
/* PR tree-optimization/56205 */

#include <stdarg.h>

int a, b;
char c[128];

__attribute__((noinline, noclone)) static void
f1 (const char *fmt, ...)
{
  va_list ap;
  asm volatile ("" : : : "memory");
  if (__builtin_strcmp (fmt, "%s %d %s") != 0)
    __builtin_abort ();
  va_start (ap, fmt);
  if (__builtin_strcmp (va_arg (ap, const char *), "foo") != 0
      || va_arg (ap, int) != 1
      || __builtin_strcmp (va_arg (ap, const char *), "bar") != 0)
    __builtin_abort ();
  va_end (ap);
}

__attribute__((noinline, noclone)) static void
f2 (const char *fmt, va_list ap)
{
  asm volatile ("" : : : "memory");
  if (__builtin_strcmp (fmt, "baz") != 0
      || __builtin_strcmp (va_arg (ap, const char *), "foo") != 0
      || va_arg (ap, double) != 12.0
      || va_arg (ap, int) != 26)
    __builtin_abort ();
}

static void
f3 (int x, char const *y, va_list z)
{
  f1 ("%s %d %s", x ? "" : "foo", ++a, (y && *y) ? "bar" : "");
  if (y && *y)
    f2 (y, z);
}

__attribute__((noinline, noclone)) void
f4 (int x, char const *y, ...)
{
  va_list z;
  va_start (z, y);
  if (!x && *c == '\0')
    ++b;
  f3 (x, y, z);
  va_end (z);
}

int
main ()
{
  asm volatile ("" : : : "memory");
  f4 (0, "baz", "foo", 12.0, 26);
  if (a != 1 || b != 1)
    __builtin_abort ();
  return 0;
}
// source: pr56250.c
/* PR tree-optimization/56250 */

extern void abort (void);

int
main ()
{
  unsigned int x = 2;
  unsigned int y = (0U - x / 2) / 2;
  if (-1U / x != y)
    abort ();
  return 0;
}
// source: pr56799.c
/* { dg-require-effective-target int32plus } */

#include <stdio.h>
typedef struct { int x; int y;} S;
extern int foo(S*);
int hi = 0, lo = 0;

int main()
{
  S a;
  int r;
  a.x = (int) 0x00010000;
  a.y = 1;
  r = foo (&a);
  if (r == 2 && lo==0 && hi==1)
    {
      exit (0);
    }
  abort ();
}

typedef unsigned short u16;

__attribute__ ((noinline)) int foo (S* ptr)
{
  int a = ptr->x;
  int c = 0;
  u16 b = (u16) a;
  if (b != 0)
  {
    lo = 1;
    c += ptr->y;
  }
  b = a >> 16;
  if (b != 0)
  {
    hi = 1;
    c+= ptr->y;
  }
  c += ptr->y;
  return c;
}
// source: pr56837.c
extern void abort (void);
_Complex int a[1024];

__attribute__((noinline, noclone)) void
foo (void)
{
  int i;
  for (i = 0; i < 1024; i++)
    a[i] = -1;
}

int
main ()
{
  int i;
  foo ();
  for (i = 0; i < 1024; i++)
    if (a[i] != -1)
      abort ();
  return 0;
}
// source: pr56866.c
/* PR target/56866 */

int
main ()
{
#if __CHAR_BIT__ == 8 && __SIZEOF_LONG_LONG__ == 8 && __SIZEOF_INT__ == 4 && __SIZEOF_SHORT__ == 2
  unsigned long long wq[256], rq[256];
  unsigned int wi[256], ri[256];
  unsigned short ws[256], rs[256];
  unsigned char wc[256], rc[256];
  int t;

  __builtin_memset (wq, 0, sizeof wq);
  __builtin_memset (wi, 0, sizeof wi);
  __builtin_memset (ws, 0, sizeof ws);
  __builtin_memset (wc, 0, sizeof wc);
  wq[0] = 0x0123456789abcdefULL;
  wi[0] = 0x01234567;
  ws[0] = 0x4567;
  wc[0] = 0x73;

  asm volatile ("" : : "g" (wq), "g" (wi), "g" (ws), "g" (wc) : "memory");

  for (t = 0; t < 256; ++t)
    rq[t] = (wq[t] >> 8) | (wq[t] << (sizeof (wq[0]) * __CHAR_BIT__ - 8));
  for (t = 0; t < 256; ++t)
    ri[t] = (wi[t] >> 8) | (wi[t] << (sizeof (wi[0]) * __CHAR_BIT__ - 8));
  for (t = 0; t < 256; ++t)
    rs[t] = (ws[t] >> 9) | (ws[t] << (sizeof (ws[0]) * __CHAR_BIT__ - 9));
  for (t = 0; t < 256; ++t)
    rc[t] = (wc[t] >> 5) | (wc[t] << (sizeof (wc[0]) * __CHAR_BIT__ - 5));

  asm volatile ("" : : "g" (rq), "g" (ri), "g" (rs), "g" (rc) : "memory");

  if (rq[0] != 0xef0123456789abcdULL || rq[1])
    __builtin_abort ();
  if (ri[0] != 0x67012345 || ri[1])
    __builtin_abort ();
  if (rs[0] != 0xb3a2 || rs[1])
    __builtin_abort ();
  if (rc[0] != 0x9b || rc[1])
    __builtin_abort ();
#endif
  return 0;
}
// source: pr56899.c
/* PR tree-optimization/56899 */

#if __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
__attribute__((noinline, noclone)) void
f1 (int v)
{
  int x = -214748365 * (v - 1);
  if (x != -1932735285)
    __builtin_abort ();
}

__attribute__((noinline, noclone)) void
f2 (int v)
{
  int x = 214748365 * (v + 1);
  if (x != -1932735285)
    __builtin_abort ();
}

__attribute__((noinline, noclone)) void
f3 (unsigned int v)
{
  unsigned int x = -214748365U * (v - 1);
  if (x != -1932735285U)
    __builtin_abort ();
}

__attribute__((noinline, noclone)) void
f4 (unsigned int v)
{
  unsigned int x = 214748365U * (v + 1);
  if (x != -1932735285U)
    __builtin_abort ();
}
#endif

int
main ()
{
#if __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
  f1 (10);
  f2 (-10);
  f3 (10);
  f4 (-10U);
#endif
  return 0;
}
// source: pr56962.c
/* PR tree-optimization/56962 */

extern void abort (void);
long long v[144];

__attribute__((noinline, noclone)) void
bar (long long *x)
{
  if (x != &v[29])
    abort ();
}

__attribute__((noinline, noclone)) void
foo (long long *x, long y, long z)
{
  long long a, b, c;
  a = x[z * 4 + y * 3];
  b = x[z * 5 + y * 3];
  c = x[z * 5 + y * 4];
  x[y * 4] = a;
  bar (&x[z * 5 + y]);
  x[z * 5 + y * 5] = b + c;
}

int
main ()
{
  foo (v, 24, 1);
  return 0;
}
// source: pr56982.c
/* { dg-require-effective-target indirect_jumps } */
#include <setjmp.h>

extern void abort (void);
extern void exit (int);

static jmp_buf env;

void baz (void)
{
  __asm__ volatile ("" : : : "memory");
}

static inline int g(int x)
{
    if (x)
    {
        baz();
        return 0;
    }
    else
    {
        baz();
        return 1;
    }
}

int f(int *e)
{
    if (*e)
      return 1;

    int x = setjmp(env);
    int n = g(x);
    if (n == 0)
      exit(0);
    if (x)
      abort();
    longjmp(env, 42);
}

int main(int argc, char** argv)
{
    int v = 0;
    return f(&v);
}
// source: pr57124.c
/* { dg-require-effective-target int32plus } */
/* { dg-options "-fno-strict-overflow" } */

extern void abort (void);
extern void exit (int);

__attribute__ ((noinline)) void
foo(short unsigned int *p1, short unsigned int *p2)
{
  short unsigned int x1, x4;
  int x2, x3, x5, x6;
  unsigned int x7;

  x1 = *p1;
  x2 = (int) x1;
  x3 = x2 * 65536;
  x4 = *p2;
  x5 = (int) x4;
  x6 = x3 + x4;
  x7 = (unsigned int) x6;
  if (x7 <= 268435455U)
    abort ();
  exit (0);
}

int
main()
{
  short unsigned int x, y;
  x = -5;
  y = -10;
  foo (&x, &y);
}
// source: pr57130.c
/* PR rtl-optimization/57130 */

struct S { int a, b, c, d; } s[2] = { { 6, 8, -8, -5 }, { 0, 2, -1, 2 } };

__attribute__((noinline, noclone)) void
foo (struct S r)
{
  static int cnt;
  if (__builtin_memcmp (&r, &s[cnt++], sizeof r) != 0)
    __builtin_abort ();
}

int
main ()
{
  struct S r = { 6, 8, -8, -5 };
  foo (r);
  r = (struct S) { 0, 2, -1, 2 };
  foo (r);
  return 0;
}
// source: pr57131.c
/* PR rtl-optimization/57131 */

extern void abort (void);

int
main ()
{
  volatile int x1 = 0;
  volatile long long x2 = 0;
  volatile int x3 = 0;
  volatile int x4 = 1;
  volatile int x5 = 1;
  volatile long long x6 = 1;
  long long t = ((x1 * (x2 << x3)) / (x4 * x5)) + x6;

  if (t != 1)
    abort ();
  return 0;
}
// source: pr57144.c
extern void abort (void);
extern void exit (int);

void __attribute__ ((noinline))
foo(int a)
{
  int z = a > 0 ? a : -a;
  long long x = z;
  if (x > 0x100000000LL)
    abort ();
  else
    exit (0);
}

int
main()
{
  foo (1);
}
// source: pr57281.c
/* PR rtl-optimization/57281 */

int a = 1, b, d, *e = &d;
long long c, *g = &c;
volatile long long f;

int
foo (int h)
{
  int j = *g = b;
  return h == 0 ? j : 0;
}

int
main ()
{
  int h = a;
  for (; b != -20; b--)
    {
      (int) f;
      *e = 0;
      *e = foo (h);
    }
  return 0;
}
// source: pr57321.c
/* PR tree-optimization/57321 */

int a = 1, *b, **c;

static int
foo (int *p)
{
  if (*p == a)
    {
      int *i[7][5] = { { 0 } };
      int **j[1][1];
      j[0][0] = &i[0][0];
      *b = &p != c;
    }
  return 0;
}

int
main ()
{
  int i = 0;
  foo (&i);
  return 0;
}
// source: pr57344-1.c
/* PR middle-end/57344 */

struct __attribute__((packed)) S
{
  int a : 11;
#if __SIZEOF_INT__ * __CHAR_BIT__ >= 32
  int b : 22;
#else
  int b : 13;
#endif
  char c;
  int : 0;
} s[2];
int i;

__attribute__((noinline, noclone)) void
foo (int x)
{
  if (x != -3161)
    __builtin_abort ();
  asm volatile ("" : : : "memory");
}

int
main ()
{
  struct S t = { 0, -3161L };
  s[1] = t;
  for (; i < 1; i++)
    foo (s[1].b);
  return 0;
}
// source: pr57344-2.c
/* PR middle-end/57344 */
/* { dg-require-effective-target int32plus } */

struct __attribute__((packed)) S
{
  int a : 27;
#if __SIZEOF_INT__ * __CHAR_BIT__ >= 32
  int b : 22;
#else
  int b : 13;
#endif
  char c;
  int : 0;
} s[2];
int i;

__attribute__((noinline, noclone)) void
foo (int x)
{
  if (x != -3161)
    __builtin_abort ();
  asm volatile ("" : : : "memory");
}

int
main ()
{
  struct S t = { 0, -3161L };
  s[1] = t;
  for (; i < 1; i++)
    foo (s[1].b);
  return 0;
}
// source: pr57344-3.c
/* PR middle-end/57344 */

struct __attribute__((packed)) S
{
  long long int a : 43;
  long long int b : 22;
  char c;
  long long int : 0;
} s[2];
int i;

__attribute__((noinline, noclone)) void
foo (long long int x)
{
  if (x != -3161LL)
    __builtin_abort ();
  asm volatile ("" : : : "memory");
}

int
main ()
{
  struct S t = { 0, -3161LL };
  s[1] = t;
  for (; i < 1; i++)
    foo (s[1].b);
  return 0;
}
// source: pr57344-4.c
/* PR middle-end/57344 */

struct __attribute__((packed)) S
{
  long long int a : 59;
  long long int b : 54;
  char c;
  long long int : 0;
} s[2];
int i;

__attribute__((noinline, noclone)) void
foo (long long int x)
{
  if (x != -1220975898975746LL)
    __builtin_abort ();
  asm volatile ("" : : : "memory");
}

int
main ()
{
  struct S t = { 0, -1220975898975746LL };
  s[1] = t;
  for (; i < 1; i++)
    foo (s[1].b);
  return 0;
}
// source: pr57568.c
/* PR target/57568 */

extern void abort (void);
int a[6][9] = { }, b = 1, *c = &a[3][5];

int
main ()
{
  if (b && (*c = *c + *c))
    abort ();
  return 0;
}
// source: pr57829.c
/* PR rtl-optimization/57829 */

__attribute__((noinline, noclone))
int
f1 (int k)
{
  return 2 | ((k - 1) >> ((int) sizeof (int) * __CHAR_BIT__ - 1));
}

__attribute__((noinline, noclone))
long int
f2 (long int k)
{
  return 2L | ((k - 1L) >> ((int) sizeof (long int) * __CHAR_BIT__ - 1));
}

__attribute__((noinline, noclone))
int
f3 (int k)
{
  k &= 63;
  return 4 | ((k + 2) >> 5);
}

int
main ()
{
  if (f1 (1) != 2 || f2 (1L) != 2L || f3 (63) != 6 || f3 (1) != 4)
    __builtin_abort ();
  return 0;
}
// source: pr57860.c
/* PR rtl-optimization/57860 */

extern void abort (void);
int a, *b = &a, c, d, e, *f = &e, g, *h = &d, k[1] = { 1 };

int
foo (int p)
{
  for (;; g++)
    {
      for (; c; c--);
      *f = *h = p > ((0x1FFFFFFFFLL ^ a) & *b);
      if (k[g])
	return 0;
    }
}

int
main ()
{
  foo (1);
  if (d != 1)
    abort ();
  return 0;
}
// source: pr57861.c
/* PR rtl-optimization/57861 */

extern void abort (void);
short a = 1, f;
int b, c, d, *g = &b, h, i, j;
unsigned int e;

static int
foo (char p)
{
  int k;
  for (c = 0; c < 2; c++)
    {
      i = (j = 0) || p;
      k = i * p;
      if (e < k)
	{
	  short *l = &f;
	  a = d && h;
	  *l = 0;
	}
    }
  return 0;
}

int
main ()
{
  *g = foo (a);
  if (a != 0)
    abort ();
  return 0;
}
// source: pr57875.c
/* PR rtl-optimization/57875 */

extern void abort (void);
int a[1], b, c, d, f, i;
char e[1];

int
main ()
{
  for (; i < 1; i++)
    if (!d)
      {
	if (!c)
	  f = 2;
	e[0] &= f ^= 0;
      }
  b = a[e[0] >> 1 & 1];
  if (b != 0)
    abort ();
  return 0;
}
// source: pr57876.c
/* PR rtl-optimization/57876 */

extern void abort (void);
int a, b = 1, c, *d = &c, f, *g, h, j;
static int e;

int
main ()
{
  int i;
  for (i = 0; i < 2; i++)
    {
      long long k = b;
      int l;
      for (f = 0; f < 8; f++)
	{
	  int *m = &e;
	  j = *d;
	  h = a * j - 1;
	  *m = (h == 0) < k;
	  g = &l;
	}
    }
  if (e != 1)
    abort ();
  return 0;
}
// source: pr57877.c
/* PR rtl-optimization/57877 */

extern void abort (void);
int a, b, *c = &b, e, f = 6, g, h;
short d;

static unsigned char
foo (unsigned long long p1, int *p2)
{
  for (; g <= 0; g++)
    {
      short *i = &d;
      int *j = &e;
      h = *c;
      *i = h;
      *j = (*i == *p2) < p1;
    }
  return 0;
}

int
main ()
{
  foo (f, &a);
  if (e != 1)
    abort ();
  return 0;
}
// source: pr58209.c
/* PR tree-optimization/58209 */

extern void abort (void);
typedef __INTPTR_TYPE__ T;
T buf[1024];

T *
foo (T n)
{
  if (n == 0)
    return (T *) buf;
  T s = (T) foo (n - 1);
  return (T *) (s + sizeof (T));
}

T *
bar (T n)
{
  if (n == 0)
    return buf;
  return foo (n - 1) + 1;
}

int
main ()
{
  int i;
  for (i = 0; i < 27; i++)
    if (foo (i) != buf + i || bar (i) != buf + i)
      abort ();
  return 0;
}
// source: pr58277-1.c
/* PR tree-optimization/58277 */

extern void abort (void);
static int a[2];
int b, c, d, *e, f, g, h, **i = &e, k, l = 1, n, o, p;
static int **volatile j = &e;
const int m;
char u;

int
bar ()
{
  u = 0;
  return m;
}

__attribute__((noinline, noclone)) void
baz ()
{
  asm ("");
}

static int
foo ()
{
  int t1;
  g = bar ();
  if (l)
    ;
  else
    for (;; h++)
      {
	*i = 0;
	o = *e = 0;
	if (p)
	  {
	    f = 0;
	    return 0;
	  }
	for (;; k++)
	  {
	    int *t2 = 0;
	    int *const *t3[] = {
	      0, 0, 0, 0, 0, 0, 0, 0, 0, &t2, 0, 0, &t2, &t2, &t2,
	      &t2, &t2, 0, 0, 0, 0, 0, 0, 0, &t2, 0, 0, 0, 0, 0, 0,
	      0, 0, 0, 0, &t2, 0, 0, 0, 0, 0, 0, 0, &t2, &t2,
	      &t2, &t2, &t2, 0, 0, 0, 0, 0, 0, 0, &t2, 0, 0, 0,
	      &t2, 0, 0, 0, &t2, 0, &t2, 0, 0, &t2, 0, 0, 0, 0,
	      0, &t2, 0, 0, 0, 0, &t2, &t2, 0, 0, 0, 0, &t2, 0,
	      0, 0, 0, 0, 0, 0, &t2, 0, 0, 0, 0, 0, &t2, 0, 0, 0,
	      &t2, &t2
	    };
	    int *const **t4[] = {&t3[0]};
	    **i = 0;
	    if (**j)
	      break;
	    u = 0;
	  }
	*i = *j;
	t1 = 0;
	for (; t1 < 5; t1++)
	  *i = *j;
      }
  *j = 0;
  return 1;
}

int
main ()
{
  int t5;
  a[0] = 1;
  {
    int *t6[6] = {&d, &d};
    for (n = 1; n; n--)
      if (foo())
	{
	  int *t7[] = {0};
	  d = 0;
	  for (; u < 1; u++)
	    *i = *j;
	  *i = 0;
	  *i = 0;
	  int t8[5] = {0};
	  *i = &t8[0];
	  int *const *t9 = &t6[0];
	  int *const **t10 = &t9;
	  *t10 = &t7[0];
	}
  }
  u = 0;
  for (; b; b++)
    for (t5 = 0; t5 < 10; t5++)
      c = a[a[a[a[a[a[a[a[c]]]]]]]];

  baz ();

  if (!a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[u]]]]]]]]]]]]]]])
    abort ();

  return 0;
}
// source: pr58277-2.c
/* PR tree-optimization/58277 */

extern void abort (void);
static int a[1], b, c, e, i, j, k, m, q[] = { 1, 1 }, t;
int volatile d;
int **r;
static int ***volatile s = &r;
int f, g, o, x;
static int *volatile h = &f, *p;
char n;

static void
fn1 ()
{
  b = a[a[a[a[a[a[a[a[b]]]]]]]];
  b = a[a[a[a[a[a[a[a[b]]]]]]]];
  b = a[a[b]];
  b = a[a[a[a[a[a[a[a[b]]]]]]]];
  b = a[a[a[a[a[a[a[a[b]]]]]]]];
}

static int
fn2 ()
{
  n = 0;
  for (; g; t++)
    {
      for (;; m++)
	{
	  d;
	  int *u;
	  int **v[] = {
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	    0, 0, 0, 0, 0, &u, 0, 0, 0, 0, &u, &u, &u, &u, &u, &u, &u, 0,
	    &u, 0, &u, &u, &u, 0, &u, &u, 0, &u, &u, &u, &u, 0, &u, &u, &u,
	    &u, &u, 0, &u, &u, 0, &u, 0, &u, &u, 0, &u, &u, &u, &u, &u, 0,
	    &u, 0, 0, 0, &u, &u, &u, 0, 0, &u, &u, &u, 0, &u, 0, &u, &u
	  };
	  int ***w[] = { &v[0] };
	  if (*p)
	    break;
	  return 0;
	}
      *h = 0;
    }
  return 1;
}

static void
fn3 ()
{
  int *y[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
  for (; i; i++)
    x = 0;
  if (fn2 ())
    {
      int *z[6] = { };
      for (; n < 1; n++)
	*h = 0;
      int t1[7];
      for (; c; c++)
	o = t1[0];
      for (; e; e--)
	{
	  int **t2 = &y[0];
	  int ***t3 = &t2;
	  *t3 = &z[0];
	}
    }
  *s = 0;
  for (n = 0;; n = 0)
    {
      int t4 = 0;
      if (q[n])
	break;
      *r = &t4;
    }
}

int
main ()
{
  for (; j; j--)
    a[0] = 0;
  fn3 ();
  for (; k; k++)
    fn1 ();
  fn1 ();

  if (n)
    abort ();

  return 0;
}
// source: pr58364.c
/* PR tree-optimization/58364 */

int a = 1, b, c;

int
foo (int x)
{
  return x < 0 ? 1 : x;
}

int
main ()
{
  if (foo (a > c == (b = 0)))
    __builtin_abort ();
  return 0;
}
// source: pr58365.c
/* PR rtl-optimization/58365 */

extern void abort (void);

struct S
{
  volatile int a;
  int b, c, d, e;
} f;
static struct S g, h;
int i = 1;

char
foo (void)
{
  return i;
}

static struct S
bar (void)
{
  if (foo ())
    return f;
  return g;
}

int
main ()
{
  h = bar ();
  f.b = 1;
  if (h.b != 0)
    abort ();
  return 0;
}
// source: pr58385.c
/* PR tree-optimization/58385 */

extern void abort (void);

int a, b = 1;

int
foo ()
{
  b = 0;
  return 0;
}

int
main ()
{
  ((0 || a) & foo () >= 0) <= 1 && 1;
  if (b)
    abort ();
  return 0;
}
// source: pr58387.c
extern void abort(void);

int a = -1;

int main ()
{
  int b = a == 0 ? 0 : -a;
  if (b < 1)
    abort ();
  return 0;
}
// source: pr58419.c
__attribute__((__noinline__))
void
dummy ()
{
  asm volatile("");
}

int a, g, i, k, *p;
signed char b;
char e;
short c, h;
static short *d = &c;

char
foo (int p1, int p2)
{
  return p1 - p2;
}

int
bar ()
{
  short *q = &c;
  *q = 1;
  *p = 0;
  return 0;
}

int
main ()
{
  for (b = -22; b >= -29; b--)
    {
      short *l = &h;
      char *m = &e;
      *l = a;
      g = foo (*m = k && *d, 1 > i) || bar ();
    }
  dummy();
  return 0;
}
// source: pr58431.c
char a, h;
int b, d, e, g, j, k;
volatile int c;
short i;

int
main ()
{
  int m;

  m = i ^= 1;
  for (b = 0; b < 1; b++)
    {
      char o = m;
      g = k;
      j = j || c;
      if (a != o)
	for (; d < 1; d++)
	  ;
      else
	{
	  char *p = &h;
	  *p = 1;
	  for (; e; e++)
	    ;
	}
    }

  if (h != 0)
    __builtin_abort();

  return 0;
}
// source: pr58564.c
/* PR middle-end/58564 */

extern void abort (void);
int a, b;
short *c, **d = &c;

int
main ()
{
  b = (0, 0 > ((&c == d) & (1 && (a ^ 1)))) | 0U;
  if (b != 0)
    abort ();
  return 0;
}
// source: pr58570.c
/* { dg-require-effective-target int32plus } */
#pragma pack(1)
struct S
{
  int f0:15;
  int f1:29;
};

int e = 1, i;
static struct S d[6];

int
main (void)
{
  if (e)
    {
      d[i].f0 = 1;
      d[i].f1 = 1;
    }
  if (d[0].f1 != 1)
    __builtin_abort ();
  return 0;
}
// source: pr58574.c
/* PR target/58574 */

__attribute__((noinline, noclone)) double
foo (double x)
{
  double t;
  switch ((int) x)
    {
    case 0:
      t = 2 * x - 1;
      return 0.70878e-3 + (0.71234e-3 + (0.35779e-5 + (0.17403e-7 + (0.81710e-10 + (0.36885e-12 + 0.15917e-14 * t) * t) * t) * t) * t) * t;
    case 1:
      t = 2 * x - 3;
      return 0.21479e-2 + (0.72686e-3 + (0.36843e-5 + (0.18071e-7 + (0.85496e-10 + (0.38852e-12 + 0.16868e-14 * t) * t) * t) * t) * t) * t;
    case 2:
      t = 2 * x - 5;
      return 0.36165e-2 + (0.74182e-3 + (0.37948e-5 + (0.18771e-7 + (0.89484e-10 + (0.40935e-12 + 0.17872e-14 * t) * t) * t) * t) * t) * t;
    case 3:
      t = 2 * x - 7;
      return 0.51154e-2 + (0.75722e-3 + (0.39096e-5 + (0.19504e-7 + (0.93687e-10 + (0.43143e-12 + 0.18939e-14 * t) * t) * t) * t) * t) * t;
    case 4:
      t = 2 * x - 9;
      return 0.66457e-2 + (0.77310e-3 + (0.40289e-5 + (0.20271e-7 + (0.98117e-10 + (0.45484e-12 + 0.20076e-14 * t) * t) * t) * t) * t) * t;
    case 5:
      t = 2 * x - 11;
      return 0.82082e-2 + (0.78946e-3 + (0.41529e-5 + (0.21074e-7 + (0.10278e-9 + (0.47965e-12 + 0.21285e-14 * t) * t) * t) * t) * t) * t;
    case 6:
      t = 2 * x - 13;
      return 0.98039e-2 + (0.80633e-3 + (0.42819e-5 + (0.21916e-7 + (0.10771e-9 + (0.50595e-12 + 0.22573e-14 * t) * t) * t) * t) * t) * t;
    case 7:
      t = 2 * x - 15;
      return 0.11433e-1 + (0.82372e-3 + (0.44160e-5 + (0.22798e-7 + (0.11291e-9 + (0.53386e-12 + 0.23944e-14 * t) * t) * t) * t) * t) * t;
    case 8:
      t = 2 * x - 17;
      return 0.13099e-1 + (0.84167e-3 + (0.45555e-5 + (0.23723e-7 + (0.11839e-9 + (0.56346e-12 + 0.25403e-14 * t) * t) * t) * t) * t) * t;
    case 9:
      t = 2 * x - 19;
      return 0.14800e-1 + (0.86018e-3 + (0.47008e-5 + (0.24694e-7 + (0.12418e-9 + (0.59486e-12 + 0.26957e-14 * t) * t) * t) * t) * t) * t;
    case 10:
      t = 2 * x - 21;
      return 0.16540e-1 + (0.87928e-3 + (0.48520e-5 + (0.25711e-7 + (0.13030e-9 + (0.62820e-12 + 0.28612e-14 * t) * t) * t) * t) * t) * t;
    case 11:
      t = 2 * x - 23;
      return 0.18318e-1 + (0.89900e-3 + (0.50094e-5 + (0.26779e-7 + (0.13675e-9 + (0.66358e-12 + 0.30375e-14 * t) * t) * t) * t) * t) * t;
    case 12:
      t = 2 * x - 25;
      return 0.20136e-1 + (0.91936e-3 + (0.51734e-5 + (0.27900e-7 + (0.14357e-9 + (0.70114e-12 + 0.32252e-14 * t) * t) * t) * t) * t) * t;
    case 13:
      t = 2 * x - 27;
      return 0.21996e-1 + (0.94040e-3 + (0.53443e-5 + (0.29078e-7 + (0.15078e-9 + (0.74103e-12 + 0.34251e-14 * t) * t) * t) * t) * t) * t;
    case 14:
      t = 2 * x - 29;
      return 0.23898e-1 + (0.96213e-3 + (0.55225e-5 + (0.30314e-7 + (0.15840e-9 + (0.78340e-12 + 0.36381e-14 * t) * t) * t) * t) * t) * t;
    case 15:
      t = 2 * x - 31;
      return 0.25845e-1 + (0.98459e-3 + (0.57082e-5 + (0.31613e-7 + (0.16646e-9 + (0.82840e-12 + 0.38649e-14 * t) * t) * t) * t) * t) * t;
    case 16:
      t = 2 * x - 33;
      return 0.27837e-1 + (0.10078e-2 + (0.59020e-5 + (0.32979e-7 + (0.17498e-9 + (0.87622e-12 + 0.41066e-14 * t) * t) * t) * t) * t) * t;
    case 17:
      t = 2 * x - 35;
      return 0.29877e-1 + (0.10318e-2 + (0.61041e-5 + (0.34414e-7 + (0.18399e-9 + (0.92703e-12 + 0.43639e-14 * t) * t) * t) * t) * t) * t;
    case 18:
      t = 2 * x - 37;
      return 0.31965e-1 + (0.10566e-2 + (0.63151e-5 + (0.35924e-7 + (0.19353e-9 + (0.98102e-12 + 0.46381e-14 * t) * t) * t) * t) * t) * t;
    case 19:
      t = 2 * x - 39;
      return 0.34104e-1 + (0.10823e-2 + (0.65354e-5 + (0.37512e-7 + (0.20362e-9 + (0.10384e-11 + 0.49300e-14 * t) * t) * t) * t) * t) * t;
    case 20:
      t = 2 * x - 41;
      return 0.36295e-1 + (0.11089e-2 + (0.67654e-5 + (0.39184e-7 + (0.21431e-9 + (0.10994e-11 + 0.52409e-14 * t) * t) * t) * t) * t) * t;
    case 21:
      t = 2 * x - 43;
      return 0.38540e-1 + (0.11364e-2 + (0.70058e-5 + (0.40943e-7 + (0.22563e-9 + (0.11642e-11 + 0.55721e-14 * t) * t) * t) * t) * t) * t;
    case 22:
      t = 2 * x - 45;
      return 0.40842e-1 + (0.11650e-2 + (0.72569e-5 + (0.42796e-7 + (0.23761e-9 + (0.12332e-11 + 0.59246e-14 * t) * t) * t) * t) * t) * t;
    case 23:
      t = 2 * x - 47;
      return 0.43201e-1 + (0.11945e-2 + (0.75195e-5 + (0.44747e-7 + (0.25030e-9 + (0.13065e-11 + 0.63000e-14 * t) * t) * t) * t) * t) * t;
    case 24:
      t = 2 * x - 49;
      return 0.45621e-1 + (0.12251e-2 + (0.77941e-5 + (0.46803e-7 + (0.26375e-9 + (0.13845e-11 + 0.66996e-14 * t) * t) * t) * t) * t) * t;
    case 25:
      t = 2 * x - 51;
      return 0.48103e-1 + (0.12569e-2 + (0.80814e-5 + (0.48969e-7 + (0.27801e-9 + (0.14674e-11 + 0.71249e-14 * t) * t) * t) * t) * t) * t;
    case 26:
      t = 2 * x - 59;
      return 0.58702e-1 + (0.13962e-2 + (0.93714e-5 + (0.58882e-7 + (0.34414e-9 + (0.18552e-11 + 0.91160e-14 * t) * t) * t) * t) * t) * t;
    case 30:
      t = 2 * x - 79;
      return 0.90908e-1 + (0.18544e-2 + (0.13903e-4 + (0.95549e-7 + (0.59752e-9 + (0.33656e-11 + 0.16815e-13 * t) * t) * t) * t) * t) * t;
    case 40:
      t = 2 * x - 99;
      return 0.13443e0 + (0.25474e-2 + (0.21385e-4 + (0.15996e-6 + (0.10585e-8 + (0.61258e-11 + 0.30412e-13 * t) * t) * t) * t) * t) * t;
    case 50:
      t = 2 * x - 119;
      return 0.19540e0 + (0.36342e-2 + (0.34096e-4 + (0.27479e-6 + (0.18934e-8 + (0.11021e-10 + 0.52931e-13 * t) * t) * t) * t) * t) * t;
    case 60:
      t = 2 * x - 121;
      return 0.20281e0 + (0.37739e-2 + (0.35791e-4 + (0.29038e-6 + (0.20068e-8 + (0.11673e-10 + 0.55790e-13 * t) * t) * t) * t) * t) * t;
    case 61:
      t = 2 * x - 123;
      return 0.21050e0 + (0.39206e-2 + (0.37582e-4 + (0.30691e-6 + (0.21270e-8 + (0.12361e-10 + 0.58770e-13 * t) * t) * t) * t) * t) * t;
    case 62:
      t = 2 * x - 125;
      return 0.21849e0 + (0.40747e-2 + (0.39476e-4 + (0.32443e-6 + (0.22542e-8 + (0.13084e-10 + 0.61873e-13 * t) * t) * t) * t) * t) * t;
    case 63:
      t = 2 * x - 127;
      return 0.22680e0 + (0.42366e-2 + (0.41477e-4 + (0.34300e-6 + (0.23888e-8 + (0.13846e-10 + 0.65100e-13 * t) * t) * t) * t) * t) * t;
    case 64:
      t = 2 * x - 129;
      return 0.23545e0 + (0.44067e-2 + (0.43594e-4 + (0.36268e-6 + (0.25312e-8 + (0.14647e-10 + 0.68453e-13 * t) * t) * t) * t) * t) * t;
    case 65:
      t = 2 * x - 131;
      return 0.24444e0 + (0.45855e-2 + (0.45832e-4 + (0.38352e-6 + (0.26819e-8 + (0.15489e-10 + 0.71933e-13 * t) * t) * t) * t) * t) * t;
    case 66:
      t = 2 * x - 133;
      return 0.25379e0 + (0.47735e-2 + (0.48199e-4 + (0.40561e-6 + (0.28411e-8 + (0.16374e-10 + 0.75541e-13 * t) * t) * t) * t) * t) * t;
    case 67:
      t = 2 * x - 135;
      return 0.26354e0 + (0.49713e-2 + (0.50702e-4 + (0.42901e-6 + (0.30095e-8 + (0.17303e-10 + 0.79278e-13 * t) * t) * t) * t) * t) * t;
    case 68:
      t = 2 * x - 137;
      return 0.27369e0 + (0.51793e-2 + (0.53350e-4 + (0.45379e-6 + (0.31874e-8 + (0.18277e-10 + 0.83144e-13 * t) * t) * t) * t) * t) * t;
    case 69:
      t = 2 * x - 139;
      return 0.28426e0 + (0.53983e-2 + (0.56150e-4 + (0.48003e-6 + (0.33752e-8 + (0.19299e-10 + 0.87139e-13 * t) * t) * t) * t) * t) * t;
    case 70:
      t = 2 * x - 141;
      return 0.29529e0 + (0.56288e-2 + (0.59113e-4 + (0.50782e-6 + (0.35735e-8 + (0.20369e-10 + 0.91262e-13 * t) * t) * t) * t) * t) * t;
    case 71:
      t = 2 * x - 143;
      return 0.30679e0 + (0.58714e-2 + (0.62248e-4 + (0.53724e-6 + (0.37827e-8 + (0.21490e-10 + 0.95513e-13 * t) * t) * t) * t) * t) * t;
    case 72:
      t = 2 * x - 145;
      return 0.31878e0 + (0.61270e-2 + (0.65564e-4 + (0.56837e-6 + (0.40035e-8 + (0.22662e-10 + 0.99891e-13 * t) * t) * t) * t) * t) * t;
    case 73:
      t = 2 * x - 147;
      return 0.33130e0 + (0.63962e-2 + (0.69072e-4 + (0.60133e-6 + (0.42362e-8 + (0.23888e-10 + 0.10439e-12 * t) * t) * t) * t) * t) * t;
    case 74:
      t = 2 * x - 149;
      return 0.34438e0 + (0.66798e-2 + (0.72783e-4 + (0.63619e-6 + (0.44814e-8 + (0.25168e-10 + 0.10901e-12 * t) * t) * t) * t) * t) * t;
    case 75:
      t = 2 * x - 151;
      return 0.35803e0 + (0.69787e-2 + (0.76710e-4 + (0.67306e-6 + (0.47397e-8 + (0.26505e-10 + 0.11376e-12 * t) * t) * t) * t) * t) * t;
    case 76:
      t = 2 * x - 153;
      return 0.37230e0 + (0.72938e-2 + (0.80864e-4 + (0.71206e-6 + (0.50117e-8 + (0.27899e-10 + 0.11862e-12 * t) * t) * t) * t) * t) * t;
    case 77:
      t = 2 * x - 155;
      return 0.38722e0 + (0.76260e-2 + (0.85259e-4 + (0.75329e-6 + (0.52979e-8 + (0.29352e-10 + 0.12360e-12 * t) * t) * t) * t) * t) * t;
    case 78:
      t = 2 * x - 157;
      return 0.40282e0 + (0.79762e-2 + (0.89909e-4 + (0.79687e-6 + (0.55989e-8 + (0.30866e-10 + 0.12868e-12 * t) * t) * t) * t) * t) * t;
    case 79:
      t = 2 * x - 159;
      return 0.41914e0 + (0.83456e-2 + (0.94827e-4 + (0.84291e-6 + (0.59154e-8 + (0.32441e-10 + 0.13387e-12 * t) * t) * t) * t) * t) * t;
    case 80:
      t = 2 * x - 161;
      return 0.43621e0 + (0.87352e-2 + (0.10002e-3 + (0.89156e-6 + (0.62480e-8 + (0.34079e-10 + 0.13917e-12 * t) * t) * t) * t) * t) * t;
    case 81:
      t = 2 * x - 163;
      return 0.45409e0 + (0.91463e-2 + (0.10553e-3 + (0.94293e-6 + (0.65972e-8 + (0.35782e-10 + 0.14455e-12 * t) * t) * t) * t) * t) * t;
    case 82:
      t = 2 * x - 165;
      return 0.47282e0 + (0.95799e-2 + (0.11135e-3 + (0.99716e-6 + (0.69638e-8 + (0.37549e-10 + 0.15003e-12 * t) * t) * t) * t) * t) * t;
    case 83:
      t = 2 * x - 167;
      return 0.49243e0 + (0.10037e-1 + (0.11750e-3 + (0.10544e-5 + (0.73484e-8 + (0.39383e-10 + 0.15559e-12 * t) * t) * t) * t) * t) * t;
    case 84:
      t = 2 * x - 169;
      return 0.51298e0 + (0.10520e-1 + (0.12400e-3 + (0.11147e-5 + (0.77517e-8 + (0.41283e-10 + 0.16122e-12 * t) * t) * t) * t) * t) * t;
    case 85:
      t = 2 * x - 171;
      return 0.53453e0 + (0.11030e-1 + (0.13088e-3 + (0.11784e-5 + (0.81743e-8 + (0.43252e-10 + 0.16692e-12 * t) * t) * t) * t) * t) * t;
    case 86:
      t = 2 * x - 173;
      return 0.55712e0 + (0.11568e-1 + (0.13815e-3 + (0.12456e-5 + (0.86169e-8 + (0.45290e-10 + 0.17268e-12 * t) * t) * t) * t) * t) * t;
    case 87:
      t = 2 * x - 175;
      return 0.58082e0 + (0.12135e-1 + (0.14584e-3 + (0.13164e-5 + (0.90803e-8 + (0.47397e-10 + 0.17850e-12 * t) * t) * t) * t) * t) * t;
    case 88:
      t = 2 * x - 177;
      return 0.60569e0 + (0.12735e-1 + (0.15396e-3 + (0.13909e-5 + (0.95651e-8 + (0.49574e-10 + 0.18435e-12 * t) * t) * t) * t) * t) * t;
    case 89:
      t = 2 * x - 179;
      return 0.63178e0 + (0.13368e-1 + (0.16254e-3 + (0.14695e-5 + (0.10072e-7 + (0.51822e-10 + 0.19025e-12 * t) * t) * t) * t) * t) * t;
    case 90:
      t = 2 * x - 181;
      return 0.65918e0 + (0.14036e-1 + (0.17160e-3 + (0.15521e-5 + (0.10601e-7 + (0.54140e-10 + 0.19616e-12 * t) * t) * t) * t) * t) * t;
    case 91:
      t = 2 * x - 183;
      return 0.68795e0 + (0.14741e-1 + (0.18117e-3 + (0.16392e-5 + (0.11155e-7 + (0.56530e-10 + 0.20209e-12 * t) * t) * t) * t) * t) * t;
    case 92:
      t = 2 * x - 185;
      return 0.71818e0 + (0.15486e-1 + (0.19128e-3 + (0.17307e-5 + (0.11732e-7 + (0.58991e-10 + 0.20803e-12 * t) * t) * t) * t) * t) * t;
    case 93:
      t = 2 * x - 187;
      return 0.74993e0 + (0.16272e-1 + (0.20195e-3 + (0.18269e-5 + (0.12335e-7 + (0.61523e-10 + 0.21395e-12 * t) * t) * t) * t) * t) * t;
    }
  return 1.0;
}

int
main ()
{
#ifdef __s390x__
  {
    register unsigned long r5 __asm ("r5");
    r5 = 0xdeadbeefUL;
    asm volatile ("":"+r" (r5));
  }
#endif
  double d = foo (78.4);
  if (d < 0.38 || d > 0.42)
    __builtin_abort ();
  return 0;
}
// source: pr58640-2.c
extern void abort (void);

int a[20], b, c;

int
fn1 ()
{
  int d, e, f, g = 0;

  a[12] = 1;
  for (e = 0; e < 3; e++)
    for (d = 0; d < 2; d++)
      {
	for (f = 0; f < 2; f++)
	  {
	    g ^= a[12] > 1;
	    if (g)
	      return 0;
	    if (b)
	      break;
	  }
	for (c = 0; c < 1; c++)
	  a[d] = a[e * 3 + 9];
      }
  return 0;
}

int
main ()
{
  fn1 ();
  if (a[0] != 0)
    abort ();
  return 0;
}
// source: pr58640.c
int a, b, c, d = 1, e;

static signed char
foo ()
{
  int f, g = a;

  for (f = 1; f < 3; f++)
    for (; b < 1; b++)
      {
        if (d)
          for (c = 0; c < 4; c++)
            for (f = 0; f < 3; f++)
              {
                for (e = 0; e < 1; e++)
                  a = g;
                if (f)
                  break;
              }
        else if (f)
          continue;
        return 0;
      }
  return 0;
}

int
main ()
{
  foo ();
  exit (0);
}
// source: pr58662.c
extern void abort (void);

int a, c, d;
volatile int b;

static int
foo (int p1, short p2)
{
  return p1 / p2;
}

int
main ()
{
  char e;
  d = foo (a == 0, (0, 35536));
  e = d % 14;
  b = e && c;
  if (b != 0)
    abort ();
  return 0;
}
// source: pr58726.c
/* PR rtl-optimization/58726 */

int a, c;
union { int f1; int f2 : 1; } b;

short
foo (short p)
{
  return p < 0 ? p : a;
}

int
main ()
{
  if (sizeof (short) * __CHAR_BIT__ != 16
      || sizeof (int) * __CHAR_BIT__ != 32)
    return 0;
  b.f1 = 56374;
  unsigned short d;
  int e = b.f2;
  d = e == 0 ? b.f1 : 0;
  c = foo (d);
  if (c != (short) 56374)
    __builtin_abort ();
  return 0;
}
// source: pr58831.c
#include <assert.h>

int a, *b, c, d, f, **i, p, q, *r;
short o, j;

static int __attribute__((noinline, noclone))
fn1 (int *p1, int **p2)
{
  int **e = &b;
  for (; p; p++)
    *p1 = 1;
  *e = *p2 = &d;

  assert (r);

  return c;
}

static int ** __attribute__((noinline, noclone))
fn2 (void)
{
  for (f = 0; f != 42; f++)
    {
      int *g[3] = {0, 0, 0};
      for (o = 0; o; o--)
        for (; a > 1;)
          {
            int **h[1] = { &g[2] };
          }
    }
  return &r;
}

int
main (void)
{
  i = fn2 ();
  fn1 (b, i);
  return 0;
}
// source: pr58943.c
/* PR c/58943 */

unsigned int x[1] = { 2 };

unsigned int
foo (void)
{
  x[0] |= 128;
  return 1;
}

int
main ()
{
  x[0] |= foo ();
  if (x[0] != 131)
    __builtin_abort ();
  return 0;
}
// source: pr58984.c
/* PR tree-optimization/58984 */

struct S { int f0 : 8; int : 6; int f1 : 5; };
struct T { char f0; int : 6; int f1 : 5; };

int a, *c = &a, e, n, b, m;

static int
foo (struct S p)
{
  const unsigned short *f[36];
  for (; e < 2; e++)
    {
      const unsigned short **i = &f[0];
      *c ^= 1;
      if (p.f1)
	{
	  *i = 0;
	  return b;
	}
    }
  return 0;
}

static int
bar (struct T p)
{
  const unsigned short *f[36];
  for (; e < 2; e++)
    {
      const unsigned short **i = &f[0];
      *c ^= 1;
      if (p.f1)
	{
	  *i = 0;
	  return b;
	}
    }
  return 0;
}

int
main ()
{
  struct S o = { 1, 1 };
  foo (o);
  m = n || o.f0;
  if (a != 1)
    __builtin_abort ();
  e = 0;
  struct T p = { 1, 1 };
  bar (p);
  m |= n || p.f0;
  if (a != 0)
    __builtin_abort ();
  return 0;
}
// source: pr59014-2.c
/* PR tree-optimization/59014 */

__attribute__((noinline, noclone)) long long int
foo (long long int x, long long int y)
{
  if (((int) x | (int) y) != 0)
    return 6;
  return x + y;
}

int
main ()
{
  if (sizeof (long long) == sizeof (int))
    return 0;
  int shift_half = sizeof (int) * __CHAR_BIT__ / 2;
  long long int x = (3LL << shift_half) << shift_half;
  long long int y = (5LL << shift_half) << shift_half;
  long long int z = foo (x, y);
  if (z != ((8LL << shift_half) << shift_half))
    __builtin_abort ();
  return 0;
}
// source: pr59014.c
/* PR tree-optimization/59014 */

int a = 2, b, c, d;

int
foo ()
{
  for (;; c++)
    if ((b > 0) | (a & 1))
      ;
    else
      {
	d = a;
	return 0;
      }
}

int
main ()
{
  foo ();
  if (d != 2)
    __builtin_abort ();
  return 0;
}
// source: pr59101.c
/* PR target/59101 */

__attribute__((noinline, noclone)) int
foo (int a)
{
  return (~a & 4102790424LL) > 0 | 6;
}

int
main ()
{
  if (foo (0) != 7)
    __builtin_abort ();
  return 0;
}
// source: pr59221.c
/* { dg-xfail-if "ptxas crashes" { nvptx-*-* } { "*" } { "-O0" "-Os" } } */


int a = 1, b, d;
short e;

int
main ()
{
  for (; b; b++)
    ;
  short f = a;
  int g = 15;
  e = f ? f : 1 << g;
  int h = e;
  d = h == 83647 ? 0 : h;
  if (d != 1)
    __builtin_abort ();
  return 0;
}
// source: pr59229.c
int i;

__attribute__((noinline, noclone)) void
bar (char *p)
{
  if (i < 1 || i > 6)
    __builtin_abort ();
  if (__builtin_memcmp (p, "abcdefg", i + 1) != 0)
    __builtin_abort ();
  __builtin_memset (p, ' ', 7);
}

__attribute__((noinline, noclone)) void
foo (char *p, unsigned long l)
{
  if (l < 1 || l > 6)
    return;
  char buf[7];
  __builtin_memcpy (buf, p, l + 1);
  bar (buf);
}

int
main ()
{
  for (i = 0; i < 16; i++)
    foo ("abcdefghijklmnop", i);
  return 0;
}
// source: pr59358.c
/* PR tree-optimization/59358 */

__attribute__((noinline, noclone)) int
foo (int *x, int y)
{
  int z = *x;
  if (y > z && y <= 16)
    while (y > z)
      z *= 2;
  return z;
}

int
main ()
{
  int i;
  for (i = 1; i < 17; i++)
    {
      int j = foo (&i, 16);
      int k;
      if (i >= 8 && i <= 15)
	k = 16 + (i - 8) * 2;
      else if (i >= 4 && i <= 7)
	k = 16 + (i - 4) * 4;
      else if (i == 3)
	k = 24;
      else
	k = 16;
      if (j != k)
	__builtin_abort ();
      j = foo (&i, 7);
      if (i >= 7)
	k = i;
      else if (i >= 4)
	k = 8 + (i - 4) * 2;
      else if (i == 3)
	k = 12;
      else
	k = 8;
      if (j != k)
	__builtin_abort ();
    }
  return 0;
}
// source: pr59387.c
/* PR tree-optimization/59387 */

int a, *d, **e = &d, f;
char c;
struct S { int f1; } b;

int
main ()
{
  for (a = -19; a; a++)
    {
      for (b.f1 = 0; b.f1 < 24; b.f1++)
	c--;
      *e = &f;
      if (!d)
	return 0;
    }
  return 0;
}
// source: pr59388.c
/* PR tree-optimization/59388 */

int a;
struct S { unsigned int f:1; } b;

int
main ()
{
  a = (0 < b.f) | b.f;
  return a;
}
// source: pr59413.c
/* PR tree-optimization/59413 */

typedef unsigned int uint32_t;

uint32_t a;
int b;

int
main ()
{
  uint32_t c;
  for (a = 7; a <= 1; a++)
    {
      char d = a;
      c = d;
      b = a == c;
    }
  if (a != 7)
    __builtin_abort ();
  return 0;
}
// source: pr59643.c
/* PR tree-optimization/59643 */

#define N 32

__attribute__((noinline, noclone)) void
foo (double *a, double *b, double *c, double d, double e, int n)
{
  int i;
  for (i = 1; i < n - 1; i++)
    a[i] = d * (b[i] + c[i] + a[i - 1] + a[i + 1]) + e * a[i];
}

double expected[] = {
  0.0, 10.0, 44.0, 110.0, 232.0, 490.0, 1020.0, 2078.0, 4152.0, 8314.0,
  16652.0, 33326.0, 66664.0, 133354.0, 266748.0, 533534.0, 1067064.0,
  2134138.0, 4268300.0, 8536622.0, 17073256.0, 34146538.0, 68293116.0,
  136586270.0, 273172536.0, 546345082.0, 1092690188.0, 2185380398.0,
  4370760808.0, 8741521642.0, 17483043324.0, 6.0
};

int
main ()
{
  int i;
  double a[N], b[N], c[N];
  if (__DBL_MANT_DIG__ <= 35)
    return 0;
  for (i = 0; i < N; i++)
    {
      a[i] = (i & 3) * 2.0;
      b[i] = (i & 7) - 4;
      c[i] = i & 7;
    }
  foo (a, b, c, 2.0, 3.0, N);
  for (i = 0; i < N; i++)
    if (a[i] != expected[i])
      __builtin_abort ();
  return 0;
}
// source: pr59747.c
extern void abort (void);
extern void exit (int);

int a[6], c = 1, d;
short e;

int __attribute__ ((noinline))
fn1 (int p)
{
  return a[p];
}

int
main ()
{
  if (sizeof (long long) != 8)
    exit (0);

  a[0] = 1;
  if (c)
    e--;
  d = e;
  long long f = e;
  if (fn1 ((f >> 56) & 1) != 0)
    abort ();
  exit (0);
}
// source: pr60003.c
/* PR tree-optimization/60003 */
/* { dg-require-effective-target indirect_jumps } */

extern void abort (void);

unsigned long long jmp_buf[5];

__attribute__((noinline, noclone)) void
baz (void)
{
  __builtin_longjmp (&jmp_buf, 1);
}

void
bar (void)
{
  baz ();
}

__attribute__((noinline, noclone)) int
foo (int x)
{
  int a = 0;

  if (__builtin_setjmp (&jmp_buf) == 0)
    {
      while (1)
	{
	  a = 1;
	  bar ();  /* OK if baz () instead */
	}
    }
  else
    {
      if (a == 0)
	return 0;
      else
	return x;
    }
}

int
main ()
{
  if (foo (1) == 0)
    abort ();

  return 0;
}
// source: pr60017.c
/* PR target/60017 */

extern void abort (void);

struct S0
{
  short m0;
  short m1;
};

struct S1
{
  unsigned m0:1;
  char m1[2][2];
  struct S0 m2[2];
};

struct S1 x = { 1, {{2, 3}, {4, 5}}, {{6, 7}, {8, 9}} };

struct S1 func (void)
{
  return x;
}

int main (void)
{
  struct S1 ret = func ();

  if (ret.m2[1].m1 != 9)
    abort ();

  return 0;
}
// source: pr60062.c
/* PR target/60062 */

int a;

static void
foo (const char *p1, int p2)
{
  if (__builtin_strcmp (p1, "hello") != 0)
    __builtin_abort ();
}

static void
bar (const char *p1)
{
  if (__builtin_strcmp (p1, "hello") != 0)
    __builtin_abort ();
}

__attribute__((optimize (0))) int
main ()
{
  foo ("hello", a);
  bar ("hello");
  return 0;
}
// source: pr60072.c
/* PR target/60072 */

int c = 1;

__attribute__ ((optimize (1)))
static int *foo (int *p)
{
  return p;
}

int
main ()
{
  *foo (&c) = 2;
  return c - 2;
}
// source: pr60454.c
#ifdef __UINT32_TYPE__
typedef __UINT32_TYPE__ uint32_t;
#else
typedef unsigned uint32_t;
#endif

#define __fake_const_swab32(x) ((uint32_t)(			      \
        (((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |            \
        (((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |            \
        (((uint32_t)(x) & (uint32_t)0x000000ffUL) <<  8) |            \
        (((uint32_t)(x) & (uint32_t)0x0000ff00UL)      ) |            \
        (((uint32_t)(x) & (uint32_t)0xff000000UL) >> 24)))

/* Previous version of bswap optimization would detect byte swap when none
   happen. This test aims at catching such wrong detection to avoid
   regressions.  */

__attribute__ ((noinline, noclone)) uint32_t
fake_swap32 (uint32_t in)
{
  return __fake_const_swab32 (in);
}

int main(void)
{
  if (sizeof (uint32_t) * __CHAR_BIT__ != 32)
    return 0;
  if (fake_swap32 (0x12345678UL) != 0x78567E12UL)
    __builtin_abort ();
  return 0;
}
// source: pr60822.c
/* { dg-require-effective-target int32plus } */
struct X {
    char fill0[800000];
    int a;
    char fill1[900000];
    int b;
};

int __attribute__((noinline,noclone))
Avg(struct X *p, int s)
{
    return (s * (long long)(p->a + p->b)) >> 17;
}

struct X x;

int main()
{
    x.a = 1 << 17;
    x.b = 2 << 17;
    if (Avg(&x, 1) != 3)
	__builtin_abort();
    return 0;
}
// source: pr60960.c
/* PR tree-optimization/60960 */

typedef unsigned char v4qi __attribute__ ((vector_size (4)));

__attribute__((noinline, noclone)) v4qi
f1 (v4qi v)
{
  return v / 2;
}

__attribute__((noinline, noclone)) v4qi
f2 (v4qi v)
{
  return v / (v4qi) { 2, 2, 2, 2 };
}

__attribute__((noinline, noclone)) v4qi
f3 (v4qi x, v4qi y)
{
  return x / y;
}

int
main ()
{
  v4qi x = { 5, 5, 5, 5 };
  v4qi y = { 2, 2, 2, 2 };
  v4qi z = f1 (x);
  if (__builtin_memcmp (&y, &z, sizeof (y)) != 0)
    __builtin_abort ();
  z = f2 (x);
  if (__builtin_memcmp (&y, &z, sizeof (y)) != 0)
    __builtin_abort ();
  z = f3 (x, y);
  if (__builtin_memcmp (&y, &z, sizeof (y)) != 0)
    __builtin_abort ();
  return 0;
}
// source: pr61306-1.c
#ifdef __INT32_TYPE__
typedef __INT32_TYPE__ int32_t;
#else
typedef int int32_t;
#endif

#ifdef __UINT32_TYPE__
typedef __UINT32_TYPE__ uint32_t;
#else
typedef unsigned uint32_t;
#endif

#define __fake_const_swab32(x) ((uint32_t)(		      \
	(((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |    \
	(((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |    \
	(((uint32_t)(x) & (uint32_t)0x00ff0000UL) >>  8) |    \
	(( (int32_t)(x) &  (int32_t)0xff000000UL) >> 24)))

/* Previous version of bswap optimization failed to consider sign extension
   and as a result would replace an expression *not* doing a bswap by a
   bswap.  */

__attribute__ ((noinline, noclone)) uint32_t
fake_bswap32 (uint32_t in)
{
  return __fake_const_swab32 (in);
}

int
main(void)
{
  if (sizeof (int32_t) * __CHAR_BIT__ != 32)
    return 0;
  if (sizeof (uint32_t) * __CHAR_BIT__ != 32)
    return 0;
  if (fake_bswap32 (0x87654321) != 0xffffff87)
    __builtin_abort ();
  return 0;
}
// source: pr61306-2.c
#ifdef __INT16_TYPE__
typedef __INT16_TYPE__ int16_t;
#else
typedef short int16_t;
#endif

#ifdef __UINT32_TYPE__
typedef __UINT32_TYPE__ uint32_t;
#else
typedef unsigned uint32_t;
#endif

#define __fake_const_swab32(x) ((uint32_t)(			      \
	(((uint32_t)         (x) & (uint32_t)0x000000ffUL) << 24) |   \
	(((uint32_t)(int16_t)(x) & (uint32_t)0x00ffff00UL) <<  8) |   \
	(((uint32_t)         (x) & (uint32_t)0x00ff0000UL) >>  8) |   \
	(((uint32_t)         (x) & (uint32_t)0xff000000UL) >> 24)))


/* Previous version of bswap optimization failed to consider sign extension
   and as a result would replace an expression *not* doing a bswap by a
   bswap.  */

__attribute__ ((noinline, noclone)) uint32_t
fake_bswap32 (uint32_t in)
{
  return __fake_const_swab32 (in);
}

int
main(void)
{
  if (sizeof (uint32_t) * __CHAR_BIT__ != 32)
    return 0;
  if (sizeof (int16_t) * __CHAR_BIT__ != 16)
    return 0;
  if (fake_bswap32 (0x81828384) != 0xff838281)
    __builtin_abort ();
  return 0;
}
// source: pr61306-3.c
short a = -1;
int b;
char c;

int
main ()
{
  c = a;
  b = a | c;
  if (b != -1)
    __builtin_abort ();
  return 0;
}
// source: pr61375.c
#ifdef __UINT64_TYPE__
typedef __UINT64_TYPE__ uint64_t;
#else
typedef unsigned long long uint64_t;
#endif

#ifndef __SIZEOF_INT128__
#define __int128 long long
#endif

/* Some version of bswap optimization would ICE when analyzing a mask constant
   too big for an uint64_t variable (PR210931).  */

__attribute__ ((noinline, noclone)) uint64_t
uint128_central_bitsi_ior (unsigned __int128 in1, uint64_t in2)
{
  __int128 mask = (__int128)0xffff << 56;
  return ((in1 & mask) >> 56) | in2;
}

int
main(int argc, char **argv)
{
  __int128 in = 1;
#ifdef __SIZEOF_INT128__
  in <<= 64;
#endif
  if (sizeof (uint64_t) * __CHAR_BIT__ != 64)
    return 0;
  if (sizeof (unsigned __int128) * __CHAR_BIT__ != 128)
    return 0;
  if (uint128_central_bitsi_ior (in, 2) != 0x102)
    __builtin_abort ();
  return 0;
}
// source: pr61517.c
int a, b, *c = &a;
unsigned short d;

int
main ()
{
  unsigned int e = a;
  *c = 1;
  if (!b)
    {
      d = e;
      *c = d | e;
    }

  if (a != 0)
    __builtin_abort ();

  return 0;
}
// source: pr61673.c
/* PR rtl-optimization/61673 */

char e;

__attribute__((noinline, noclone)) void
bar (char x)
{
  if (x != 0x54 && x != (char) 0x87)
    __builtin_abort ();
}

__attribute__((noinline, noclone)) void
foo (const char *x)
{
  char d = x[0];
  int c = d;
  if ((c >= 0 && c <= 0x7f) == 0)
    e = d;
  bar (d);
}

__attribute__((noinline, noclone)) void
baz (const char *x)
{
  char d = x[0];
  int c = d;
  if ((c >= 0 && c <= 0x7f) == 0)
    e = d;
}

int
main ()
{
  const char c[] = { 0x54, 0x87 };
  e = 0x21;
  foo (c);
  if (e != 0x21)
    __builtin_abort ();
  foo (c + 1);
  if (e != (char) 0x87)
    __builtin_abort ();
  e = 0x21;
  baz (c);
  if (e != 0x21)
    __builtin_abort ();
  baz (c + 1);
  if (e != (char) 0x87)
    __builtin_abort ();
  return 0;
}
// source: pr61682.c
/* PR tree-optimization/61682 */

int a, b;
static int *c = &b;

int
main ()
{
  int *d = &a;
  for (a = 0; a < 12; a++)
    *c |= *d / 9;

  if (b != 1)
    __builtin_abort ();

  return 0;
}
// source: pr61725.c
/* PR tree-optimization/61725 */

int
main ()
{
  int x;
  for (x = -128; x <= 128; x++)
    {
      int a = __builtin_ffs (x);
      if (x == 0 && a != 0)
        __builtin_abort ();
    }
  return 0;
}
// source: pr62151.c
/* PR rtl-optimization/62151 */

int a, c, d, e, f, g, h, i;
short b;

int
fn1 ()
{
  b = 0;
  for (;;)
    {
      int j[2];
      j[f] = 0;
      if (h)
	d = 0;
      else
	{
	  for (; f; f++)
	    ;
	  for (a = 0; a < 1; a++)
	    for (;;)
	      {
		i = b & ((b ^ 1) & 83647) ? b : b - 1;
		g = 1 ? i : 0;
		e = j[0];
		if (c)
		  break;
		return 0;
	      }
	}
    }
}

int
main ()
{
  fn1 ();
  if (g != -1)
    __builtin_abort ();
  return 0;
}
// source: pr63209.c
static int Sub(int a, int b) {
  return  b -a;
}

static unsigned Select(unsigned a, unsigned b, unsigned c) {
  const int pa_minus_pb =
      Sub((a >>  8) & 0xff, (b >>  8) & 0xff) +
      Sub((a >>  0) & 0xff, (b >>  0) & 0xff);
  return (pa_minus_pb <= 0) ? a : b;
}

__attribute__((noinline)) unsigned Predictor(unsigned left, const unsigned* const top) {
  const unsigned pred = Select(top[1], left, top[0]);
  return pred;
}

int main(void) {
  const unsigned top[2] = {0xff7a7a7a, 0xff7a7a7a};
  const unsigned left = 0xff7b7b7b;
  const unsigned pred = Predictor(left, top /*+ 1*/);
  if (pred == left)
    return 0;
  return 1;
}
// source: pr63302.c
/* PR tree-optimization/63302 */

#ifdef __SIZEOF_INT128__
#if __SIZEOF_INT128__ * __CHAR_BIT__ == 128
#define USE_INT128
#endif
#endif
#if __SIZEOF_LONG_LONG__ * __CHAR_BIT__ == 64
#define USE_LLONG
#endif

#ifdef USE_INT128
__attribute__((noinline, noclone)) int
foo (__int128 x)
{
  __int128 v = x & (((__int128) -1 << 63) | 0x7ff);

  return v == 0 || v == ((__int128) -1 << 63);
}
#endif

#ifdef USE_LLONG
__attribute__((noinline, noclone)) int
bar (long long x)
{
  long long v = x & (((long long) -1 << 31) | 0x7ff);

  return v == 0 || v == ((long long) -1 << 31);
}
#endif

int
main ()
{
#ifdef USE_INT128
  if (foo (0) != 1
      || foo (1) != 0
      || foo (0x800) != 1
      || foo (0x801) != 0
      || foo ((__int128) 1 << 63) != 0
      || foo ((__int128) -1 << 63) != 1
      || foo (((__int128) -1 << 63) | 1) != 0
      || foo (((__int128) -1 << 63) | 0x800) != 1
      || foo (((__int128) -1 << 63) | 0x801) != 0)
    __builtin_abort ();
#endif
#ifdef USE_LLONG
  if (bar (0) != 1
      || bar (1) != 0
      || bar (0x800) != 1
      || bar (0x801) != 0
      || bar (1LL << 31) != 0
      || bar (-1LL << 31) != 1
      || bar ((-1LL << 31) | 1) != 0
      || bar ((-1LL << 31) | 0x800) != 1
      || bar ((-1LL << 31) | 0x801) != 0)
    __builtin_abort ();
#endif
  return 0;
}
// source: pr63641.c
/* PR tree-optimization/63641 */

__attribute__ ((noinline, noclone)) int
foo (unsigned char b)
{
  if (0x0 <= b && b <= 0x8)
    goto lab;
  if (b == 0x0b)
    goto lab;
  if (0x0e <= b && b <= 0x1a)
    goto lab;
  if (0x1c <= b && b <= 0x1f)
    goto lab;
  return 0;
lab:
  return 1;
}

__attribute__ ((noinline, noclone)) int
bar (unsigned char b)
{
  if (0x0 <= b && b <= 0x8)
    goto lab;
  if (b == 0x0b)
    goto lab;
  if (0x0e <= b && b <= 0x1a)
    goto lab;
  if (0x3c <= b && b <= 0x3f)
    goto lab;
  return 0;
lab:
  return 1;
}

char tab1[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1 };
char tab2[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1 };

int
main ()
{
  int i;
  asm volatile ("" : : : "memory");
  for (i = 0; i < 256; i++)
    if (foo (i) != (i < 32 ? tab1[i] : 0))
      __builtin_abort ();
  for (i = 0; i < 256; i++)
    if (bar (i) != (i < 64 ? tab2[i] : 0))
      __builtin_abort ();
  return 0;
}
// source: pr63659.c
/* PR rtl-optimization/63659 */

int a, b, c, *d = &b, g, h, i;
unsigned char e;
char f;

int
main ()
{
  while (a)
    {
      for (a = 0; a; a++)
	for (; c; c++)
	  ;
      if (i)
	break;
    }

  char j = c, k = -1, l;
  l = g = j >> h;
  f = l == 0 ? k : k % l;
  e = 0 ? 0 : f;
  *d = e;

  if (b != 255)
    __builtin_abort ();

  return 0;
}
// source: pr63843.c
/* PR rtl-optimization/63843 */

static inline __attribute__ ((always_inline))
unsigned short foo (unsigned short v)
{
  return (v << 8) | (v >> 8);
}

unsigned short __attribute__ ((noinline, noclone, hot))
bar (unsigned char *x)
{
  unsigned int a;
  unsigned short b;
  __builtin_memcpy (&a, &x[0], sizeof (a));
  a ^= 0x80808080U;
  __builtin_memcpy (&x[0], &a, sizeof (a));
  __builtin_memcpy (&b, &x[2], sizeof (b));
  return foo (b);
}

int
main ()
{
  unsigned char x[8] = { 0x01, 0x01, 0x01, 0x01 };
  if (__CHAR_BIT__ == 8
      && sizeof (short) == 2
      && sizeof (int) == 4
      && bar (x) != 0x8181U)
    __builtin_abort ();
  return 0;
}
// source: pr64006.c
/* PR tree-optimization/64006 */

int v;

long __attribute__ ((noinline, noclone))
test (long *x, int y)
{
  int i;
  long s = 1;
  for (i = 0; i < y; i++)
    if (__builtin_mul_overflow (s, x[i], &s))
      v++;
  return s;
}

int
main ()
{
  long d[7] = { 975, 975, 975, 975, 975, 975, 975 };
  long r = test (d, 7);
  if (sizeof (long) * __CHAR_BIT__ == 64 && v != 1)
    __builtin_abort ();
  else if (sizeof (long) * __CHAR_BIT__ == 32 && v != 4)
    __builtin_abort ();
  return 0;
}
// source: pr64242.c
/* { dg-require-effective-target indirect_jumps } */

extern void abort (void);

__attribute ((noinline)) void
broken_longjmp (void *p)
{
  void *buf[32];
  __builtin_memcpy (buf, p, 5 * sizeof (void*));
  __builtin_memset (p, 0, 5 * sizeof (void*));
  /* Corrupts stack pointer...  */
  __builtin_longjmp (buf, 1);
}

volatile int x = 0;
char *volatile p;
char *volatile q;

int
main ()
{
  void *buf[5];
  p = __builtin_alloca (x);
  q = __builtin_alloca (x);
  if (!__builtin_setjmp (buf))
    broken_longjmp (buf);

  /* Compute expected next alloca offset - some targets don't align properly
     and allocate too much.  */
  p = q + (q - p);

  /* Fails if stack pointer corrupted.  */
  if (p != __builtin_alloca (x))
    abort ();

  return 0;
}
// source: pr64255.c
/* PR rtl-optimization/64255 */

__attribute__((noinline, noclone)) void
bar (long i, unsigned long j)
{
  if (i != 1 || j != 1)
    __builtin_abort ();
}

__attribute__((noinline, noclone)) void
foo (long i)
{
  unsigned long j;

  if (!i)
    return;
  j = i >= 0 ? (unsigned long) i : - (unsigned long) i;
  if ((i >= 0 ? (unsigned long) i : - (unsigned long) i) != j)
    __builtin_abort ();
  bar (i, j);
}

int
main ()
{
  foo (1);
  return 0;
}
// source: pr64260.c
/* PR rtl-optimization/64260 */

int a = 1, b;

void
foo (char p)
{
  int t = 0;
  for (; b < 1; b++)
    {
      int *s = &a;
      if (--t)
	*s &= p;
      *s &= 1;
    }
}

int
main ()
{
  foo (0);
  if (a != 0)
    __builtin_abort ();
  return 0;
}
// source: pr64682.c
/* PR rtl-optimization/64682 */

int a, b = 1;

__attribute__((noinline, noclone)) void
foo (int x)
{
  if (x != 5)
    __builtin_abort ();
}

int
main ()
{
  int i;
  for (i = 0; i < 56; i++)
    for (; a; a--)
      ;
  int *c = &b;
  if (*c)
    *c = 1 % (unsigned int) *c | 5;

  foo (b);

  return 0;
}
// source: pr64718.c
static int __attribute__ ((noinline, noclone))
swap (int x)
{
  return (unsigned short) ((unsigned short) x << 8 | (unsigned short) x >> 8);
}

static int a = 0x1234;

int
main (void)
{
  int b = 0x1234;
  if (swap (a) != 0x3412)
    __builtin_abort ();
  if (swap (b) != 0x3412)
    __builtin_abort ();
  return 0;
}
// source: pr64756.c
/* PR rtl-optimization/64756 */

int a, *tmp, **c = &tmp;
volatile int d;
static int *volatile *e = &tmp;
unsigned int f;

static void
fn1 (int *p)
{
  int g;
  for (; f < 1; f++)
    for (g = 1; g >= 0; g--)
      {
	d || d;
	*c = p;

	if (tmp != &a)
	  __builtin_abort ();

	*e = 0;
      }
}

int
main ()
{
  fn1 (&a);
  return 0;
}
// source: pr64957.c
/* PR rtl-optimization/64957 */

__attribute__((noinline, noclone)) int
foo (int b)
{
  return (((b ^ 5) | 1) ^ 5) | 1;
}

__attribute__((noinline, noclone)) int
bar (int b)
{
  return (((b ^ ~5) & ~1) ^ ~5) & ~1;
}

int
main ()
{
  int i;
  for (i = 0; i < 16; i++)
    if (foo (i) != (i | 1) || bar (i) != (i & ~1))
      __builtin_abort ();
  return 0;
}
// source: pr64979.c
/* PR target/64979 */

#include <stdarg.h>

void __attribute__((noinline, noclone))
bar (int x, va_list *ap)
{
  if (ap)
    {
      int i;
      for (i = 0; i < 10; i++)
	if (i != va_arg (*ap, int))
	  __builtin_abort ();
      if (va_arg (*ap, double) != 0.5)
	__builtin_abort ();
    }
}

void __attribute__((noinline, noclone))
foo (int x, ...)
{
  va_list ap;
  int n;

  va_start (ap, x);
  n = va_arg (ap, int);
  bar (x, (va_list *) ((n == 0) ? ((void *) 0) : &ap));
  va_end (ap);
}

int
main ()
{
  foo (100, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0.5);
  return 0;
}
// source: pr65053-1.c
/* PR tree-optimization/65053 */

int i;

__attribute__ ((noinline, noclone))
unsigned int foo (void)
{
  return 0;
}

int
main ()
{
  unsigned int u = -1;
  if (u == -1)
    {
      unsigned int n = foo ();
      if (n > 0)
	u = n - 1;
    }

  while (u != -1)
    {
      asm ("" : "+g" (u));
      u = -1;
      i = 1;
    }

  if (i)
    __builtin_abort ();
  return 0;
}
// source: pr65053-2.c
/* PR tree-optimization/65053 */

int i;
unsigned int x;

int
main ()
{
  asm volatile ("" : "+g" (x));
  unsigned int n = x;
  unsigned int u = 32;
  if (n >= 32)
    __builtin_abort ();
  if (n != 0)
    u = n + 32;

  while (u != 32)
    {
      asm ("" : : "g" (u));
      u = 32;
      i = 1;
    }

  if (i)
    __builtin_abort ();
  return 0;
}
// source: pr65170.c
/* PR tree-optimization/65170 */

#ifdef __SIZEOF_INT128__
typedef unsigned __int128 V;
typedef unsigned long long int H;
#else
typedef unsigned long long int V;
typedef unsigned int H;
#endif

__attribute__((noinline, noclone)) void
foo (V b, V c)
{
  V a;
  b &= (H) -1;
  c &= (H) -1;
  a = b * c;
  if (a != 1)
    __builtin_abort ();
}

int
main ()
{
  foo (1, 1);
  return 0;
}
// source: pr65215-1.c
/* PR tree-optimization/65215 */

static inline unsigned int
foo (unsigned int x)
{
  return (x >> 24) | ((x >> 8) & 0xff00) | ((x << 8) & 0xff0000) | (x << 24);
}

__attribute__((noinline, noclone)) unsigned int
bar (unsigned long long *x)
{
  return foo (*x);
}

int
main ()
{
  if (__CHAR_BIT__ != 8 || sizeof (unsigned int) != 4 || sizeof (unsigned long long) != 8)
    return 0;
  unsigned long long l = foo (0xdeadbeefU) | 0xfeedbea800000000ULL;
  if (bar (&l) != 0xdeadbeefU)
    __builtin_abort ();
  return 0;
}
// source: pr65215-2.c
/* PR tree-optimization/65215 */

static inline unsigned int
foo (unsigned int x)
{
  return (x >> 24) | ((x >> 8) & 0xff00) | ((x << 8) & 0xff0000) | (x << 24);
}

__attribute__((noinline, noclone)) unsigned long long
bar (unsigned long long *x)
{
  return ((unsigned long long) foo (*x) << 32) | foo (*x >> 32);
}

int
main ()
{
  if (__CHAR_BIT__ != 8 || sizeof (unsigned int) != 4 || sizeof (unsigned long long) != 8)
    return 0;
  unsigned long long l = foo (0xfeedbea8U) | ((unsigned long long) foo (0xdeadbeefU) << 32);
  if (bar (&l) != 0xfeedbea8deadbeefULL)
    __builtin_abort ();
  return 0;
}
// source: pr65215-3.c
/* PR tree-optimization/65215 */

struct S { unsigned long long l1 : 24, l2 : 8, l3 : 32; };

static inline unsigned int
foo (unsigned int x)
{
  return (x >> 24) | ((x >> 8) & 0xff00) | ((x << 8) & 0xff0000) | (x << 24);
}

__attribute__((noinline, noclone)) unsigned long long
bar (struct S *x)
{
  unsigned long long x1 = foo (((unsigned int) x->l1 << 8) | x->l2);
  unsigned long long x2 = foo (x->l3);
  return (x2 << 32) | x1;
}

int
main ()
{
  if (__CHAR_BIT__ != 8 || sizeof (unsigned int) != 4 || sizeof (unsigned long long) != 8)
    return 0;
  struct S s = { 0xdeadbeU, 0xefU, 0xfeedbea8U };
  unsigned long long l = bar (&s);
  if (foo (l >> 32) != s.l3
      || (foo (l) >> 8) != s.l1
      || (foo (l) & 0xff) != s.l2)
    __builtin_abort ();
  return 0;
}
// source: pr65215-4.c
/* PR tree-optimization/65215 */

struct S { unsigned long long l1 : 48; };

static inline unsigned int
foo (unsigned int x)
{
  return (x >> 24) | ((x >> 8) & 0xff00) | ((x << 8) & 0xff0000) | (x << 24);
}

__attribute__((noinline, noclone)) unsigned int
bar (struct S *x)
{
  return foo (x->l1);
}

int
main ()
{
  if (__CHAR_BIT__ != 8 || sizeof (unsigned int) != 4 || sizeof (unsigned long long) != 8)
    return 0;
  struct S s;
  s.l1 = foo (0xdeadbeefU) | (0xfeedULL << 32);
  if (bar (&s) != 0xdeadbeefU)
    __builtin_abort ();
  return 0;
}
// source: pr65215-5.c
/* PR tree-optimization/65215 */

__attribute__((noinline, noclone)) unsigned int
foo (unsigned char *p)
{
  return ((unsigned int) p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
}

__attribute__((noinline, noclone)) unsigned int
bar (unsigned char *p)
{
  return ((unsigned int) p[3] << 24) | (p[2] << 16) | (p[1] << 8) | p[0];
}

struct S { unsigned int a; unsigned char b[5]; };

int
main ()
{
  struct S s = { 1, { 2, 3, 4, 5, 6 } };
  if (__CHAR_BIT__ != 8 || sizeof (unsigned int) != 4)
    return 0;
  if (foo (&s.b[1]) != 0x03040506U
      || bar (&s.b[1]) != 0x06050403U)
    __builtin_abort ();
  return 0;
}
// source: pr65216.c
/* PR tree-optimization/65216 */

int a, b = 62, e;
volatile int c, d;

int
main ()
{
  int f = 0;
  for (a = 0; a < 2; a++)
    {
      b &= (8 ^ f) & 1;
      for (e = 0; e < 6; e++)
	if (c)
	  f = d;
    }
  if (b != 0)
    __builtin_abort ();
  return 0;
}
// source: pr65369.c
/* PR tree-optimization/65369 */
#include <stdint.h>

static const char data[] =
  "12345678901234567890123456789012345678901234567890"
  "123456789012345678901234567890";

__attribute__ ((noinline))
static void foo (const unsigned int *buf)
{
  if (__builtin_memcmp (buf, data, 64))
    __builtin_abort ();
}

__attribute__ ((noinline))
static void bar (const unsigned char *block)
{
  uint32_t buf[16];
  __builtin_memcpy (buf +  0, block +  0, 4);
  __builtin_memcpy (buf +  1, block +  4, 4);
  __builtin_memcpy (buf +  2, block +  8, 4);
  __builtin_memcpy (buf +  3, block + 12, 4);
  __builtin_memcpy (buf +  4, block + 16, 4);
  __builtin_memcpy (buf +  5, block + 20, 4);
  __builtin_memcpy (buf +  6, block + 24, 4);
  __builtin_memcpy (buf +  7, block + 28, 4);
  __builtin_memcpy (buf +  8, block + 32, 4);
  __builtin_memcpy (buf +  9, block + 36, 4);
  __builtin_memcpy (buf + 10, block + 40, 4);
  __builtin_memcpy (buf + 11, block + 44, 4);
  __builtin_memcpy (buf + 12, block + 48, 4);
  __builtin_memcpy (buf + 13, block + 52, 4);
  __builtin_memcpy (buf + 14, block + 56, 4);
  __builtin_memcpy (buf + 15, block + 60, 4);
  foo (buf);
}

int
main ()
{
  unsigned char input[sizeof data + 16] __attribute__((aligned (16)));
  __builtin_memset (input, 0, sizeof input);
  __builtin_memcpy (input + 1, data, sizeof data);
  bar (input + 1);
  return 0;
}
// source: pr65401.c
/* PR rtl-optimization/65401 */

struct S { unsigned short s[64]; };

__attribute__((noinline, noclone)) void
foo (struct S *x)
{
  unsigned int i;
  unsigned char *s;

  s = (unsigned char *) x->s;
  for (i = 0; i < 64; i++)
    x->s[i] = s[i * 2] | (s[i * 2 + 1] << 8);
}

__attribute__((noinline, noclone)) void
bar (struct S *x)
{
  unsigned int i;
  unsigned char *s;

  s = (unsigned char *) x->s;
  for (i = 0; i < 64; i++)
    x->s[i] = (s[i * 2] << 8) | s[i * 2 + 1];
}

int
main ()
{
  unsigned int i;
  struct S s;
  if (sizeof (unsigned short) != 2)
    return 0;
  for (i = 0; i < 64; i++)
    s.s[i] = i + ((64 - i) << 8);
  foo (&s);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
  for (i = 0; i < 64; i++)
    if (s.s[i] != (64 - i) + (i << 8))
      __builtin_abort ();
#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  for (i = 0; i < 64; i++)
    if (s.s[i] != i + ((64 - i) << 8))
      __builtin_abort ();
#endif
  for (i = 0; i < 64; i++)
    s.s[i] = i + ((64 - i) << 8);
  bar (&s);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  for (i = 0; i < 64; i++)
    if (s.s[i] != (64 - i) + (i << 8))
      __builtin_abort ();
#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
  for (i = 0; i < 64; i++)
    if (s.s[i] != i + ((64 - i) << 8))
      __builtin_abort ();
#endif
  return 0;
}
// source: pr65418-1.c
/* PR tree-optimization/65418 */

__attribute__((noinline, noclone)) int
foo (int x)
{
  if (x == -216 || x == -132 || x == -218 || x == -146)
     return 1;
  return 0;
}

int
main ()
{
  volatile int i;
  for (i = -230; i < -120; i++)
    if (foo (i) != (i == -216 || i == -132 || i == -218 || i == -146))
      __builtin_abort ();
  return 0;
}
// source: pr65418-2.c
/* PR tree-optimization/65418 */

__attribute__((noinline, noclone)) int
foo (int x)
{
  if (x == -216 || x == -211 || x == -218 || x == -205 || x == -223)
     return 1;
  return 0;
}

int
main ()
{
  volatile int i;
  for (i = -230; i < -200; i++)
    if (foo (i) != (i == -216 || i == -211 || i == -218 || i == -205 || i == -223))
      __builtin_abort ();
  return 0;
}
// source: pr65427.c
/* PR tree-optimization/65427 */

typedef int V __attribute__ ((vector_size (8 * sizeof (int))));
V a, b, c, d, e, f;

__attribute__((noinline, noclone)) void
foo (int x, int y)
{
  do
    {
      if (x)
	d = a ^ c;
      else
	d = a ^ b;
    }
  while (y);
}

int
main ()
{
  a = (V) { 1, 2, 3, 4, 5, 6, 7, 8 };
  b = (V) { 0x40, 0x80, 0x40, 0x80, 0x40, 0x80, 0x40, 0x80 };
  e = (V) { 0x41, 0x82, 0x43, 0x84, 0x45, 0x86, 0x47, 0x88 };
  foo (0, 0);
  if (__builtin_memcmp (&d, &e, sizeof (V)) != 0)
    __builtin_abort ();
  c = (V) { 0x80, 0x40, 0x80, 0x40, 0x80, 0x40, 0x80, 0x40 };
  f = (V) { 0x81, 0x42, 0x83, 0x44, 0x85, 0x46, 0x87, 0x48 };
  foo (1, 0);
  if (__builtin_memcmp (&d, &f, sizeof (V)) != 0)
    __builtin_abort ();
  return 0;
}
// source: pr65648.c
/* PR target/65648 */

int a = 0, *b = 0, c = 0;
static int d = 0;
short e = 1;
static long long f = 0;
long long *i = &f;
unsigned char j = 0;

__attribute__((noinline, noclone)) void
foo (int x, int *y)
{
  asm volatile ("" : : "r" (x), "r" (y) : "memory");
}

__attribute__((noinline, noclone)) void
bar (const char *x, long long y)
{
  asm volatile ("" : : "r" (x), "r" (&y) : "memory");
  if (y != 0)
    __builtin_abort ();
}

int
main ()
{
  int k = 0;
  b = &k;
  j = (!a) - (c <= e);
  *i = j;
  foo (a, &k);
  bar ("", f);
  return 0;
}
// source: pr65956.c
/* PR target/65956 */

struct A { char *a; int b; long long c; };
char v[3];

__attribute__((noinline, noclone)) void
fn1 (char *x, char *y)
{
  if (x != &v[1] || y != &v[2])
    __builtin_abort ();
  v[1]++;
}

__attribute__((noinline, noclone)) int
fn2 (char *x)
{
  asm volatile ("" : "+g" (x) : : "memory");
  return x == &v[0];
}

__attribute__((noinline, noclone)) void
fn3 (const char *x)
{
  if (x[0] != 0)
    __builtin_abort ();
}

static struct A
foo (const char *x, struct A y, struct A z)
{
  struct A r = { 0, 0, 0 };
  if (y.b && z.b)
    {
      if (fn2 (y.a) && fn2 (z.a))
	switch (x[0])
	  {
	  case '|':
	    break;
	  default:
	    fn3 (x);
	  }
      fn1 (y.a, z.a);
    }
  return r;
}

__attribute__((noinline, noclone)) int
bar (int x, struct A *y)
{
  switch (x)
    {
    case 219:
      foo ("+", y[-2], y[0]);
    case 220:
      foo ("-", y[-2], y[0]);
    }
}

int
main ()
{
  struct A a[3] = { { &v[1], 1, 1LL }, { &v[0], 0, 0LL }, { &v[2], 2, 2LL } };
  bar (220, a + 2);
  if (v[1] != 1)
    __builtin_abort ();
  return 0;
}
// source: pr66187.c
/* PR tree-optimization/66187 */

int a = 1, e = -1;
short b, f;

int
main ()
{
  f = e;
  int g = b < 0 ? 0 : f + b;
  if ((g & -4) < 0)
    a = 0;
  if (a)
    __builtin_abort ();
  return 0;
}
// source: pr66233.c
/* PR tree-optimization/66233 */

unsigned int v[8];

__attribute__((noinline, noclone)) void
foo (void)
{
  int i;
  for (i = 0; i < 8; i++)
    v[i] = (float) i;
}

int
main ()
{
  unsigned int i;
  foo ();
  for (i = 0; i < 8; i++)
    if (v[i] != i)
      __builtin_abort ();
  return 0;
}
// source: pr66556.c
/* { dg-do run } */
/* { dg-require-effective-target int32plus } */

extern void abort (void);

struct {
  unsigned f2;
  unsigned f3 : 15;
  unsigned f5 : 3;
  short f6;
} b = {0x7f8000, 6, 5, 0}, g = {8, 0, 5, 0};

short d, l;
int a, c, h = 8;
volatile char e[237] = {4};
short *f = &d;
short i[5] = {3};
char j;
int *k = &c;

int
fn1 (unsigned p1) { return -p1; }

void
fn2 (char p1)
{
  a = p1;
  e[0];
}

short
fn3 ()
{
  *k = 4;
  return *f;
}

int
main ()
{

  unsigned m;
  short *n = &i[4];

  m = fn1 ((h && j) <= b.f5);
  l = m > g.f3;
  *n = 3;
  fn2 (b.f2 >> 15);
  if ((a & 0xff) != 0xff)
    abort ();

  return 0;
}
// source: pr66757.c
/* PR tree-optimization/66757 */
/* Testcase by Zhendong Su <su@cs.ucdavis.edu> */

int a, b;

int
main (void)
{
  unsigned int t = (unsigned char) (~b);

  if ((t ^ 1) / 255)
    __builtin_abort ();

  return 0;
}
// source: pr66940.c
long long __attribute__ ((noinline, noclone))
foo (long long ival)
{
 if (ival <= 0)
    return -0x7fffffffffffffffL - 1;

 return 0x7fffffffffffffffL;
}

int
main (void)
{
  if (foo (-1) != (-0x7fffffffffffffffL - 1))
    __builtin_abort ();

  if (foo (1) != 0x7fffffffffffffffL)
    __builtin_abort ();

  return 0;
}
// source: pr67037.c
long (*extfunc)();

static inline void lstrcpynW( short *d, const short *s, int n )
{
    unsigned int count = n;

    while ((count > 1) && *s)
    {
        count--;
        *d++ = *s++;
    }
    if (count) *d = 0;
}

int __attribute__((noinline,noclone))
badfunc(int u0, int u1, int u2, int u3,
  short *fsname, unsigned int fsname_len)
{
    static const short ntfsW[] = {'N','T','F','S',0};
    char superblock[2048+3300];
    int ret = 0;
    short *p;

    if (extfunc())
        return 0;
    p = (void *)extfunc();
    if (p != 0)
        goto done;

    extfunc(superblock);

    lstrcpynW(fsname, ntfsW, fsname_len);

    ret = 1;
done:
    return ret;
}

static long f()
{
    return 0;
}

int main()
{
    short buf[6];
    extfunc = f;
    return !badfunc(0, 0, 0, 0, buf, 6);
}
// source: pr67226.c
struct assembly_operand
{
  int type, value, symtype, symflags, marker;
};

struct assembly_operand to_input, from_input;

void __attribute__ ((__noinline__, __noclone__))
assemblez_1 (int internal_number, struct assembly_operand o1)
{
  if (o1.type != from_input.type)
    __builtin_abort ();
}

void __attribute__ ((__noinline__, __noclone__))
t0 (struct assembly_operand to, struct assembly_operand from)
{
  if (to.value == 0)
    assemblez_1 (32, from);
  else
    __builtin_abort ();
}

int
main (void)
{
  to_input.value = 0;
  to_input.type = 1;
  to_input.symtype = 2;
  to_input.symflags = 3;
  to_input.marker = 4;

  from_input.value = 5;
  from_input.type = 6;
  from_input.symtype = 7;
  from_input.symflags = 8;
  from_input.marker = 9;

  t0 (to_input, from_input);

  return 0;
}
// source: pr67714.c
unsigned int b;
int c;

signed char
fn1 ()
{
  signed char d;
  for (int i = 0; i < 1; i++)
    d = -15;
  return d;
}

int
main (void)
{
  for (c = 0; c < 1; c++)
    b = 0;
  char e = fn1 ();
  signed char f = e ^ b;
  volatile int g = (int) f;

  if (g != -15)
    __builtin_abort ();

  return 0;
}
// source: pr67781.c
/* { dg-require-effective-target int32plus } */
#ifdef __UINT32_TYPE__
typedef __UINT32_TYPE__ uint32_t;
#else
typedef unsigned uint32_t;
#endif

#ifdef __UINT8_TYPE__
typedef __UINT8_TYPE__ uint8_t;
#else
typedef unsigned char uint8_t;
#endif

struct
{
  uint32_t a;
  uint8_t b;
} s = { 0x123456, 0x78 };

int pr67781()
{
  uint32_t c = (s.a << 8) | s.b;
  return c;
}

int
main ()
{
  if (sizeof (uint32_t) * __CHAR_BIT__ != 32)
    return 0;

  if (pr67781 () != 0x12345678)
    __builtin_abort ();
  return 0;
}
// source: pr67929_1.c
int __attribute__ ((noinline, noclone))
foo (float a)
{
  return a * 4.9f;
}


int
main (void)
{
  if (foo (10.0f) != 49)
    __builtin_abort ();

  return 0;
}
// source: pr68143_1.c
#define NULL 0

struct stuff
{
    int a;
    int b;
    int c;
    int d;
    int e;
    char *f;
    int g;
};

void __attribute__ ((noinline))
bar (struct stuff *x)
{
  if (x->g != 2)
    __builtin_abort ();
}

int
main (int argc, char** argv)
{
  struct stuff x = {0, 0, 0, 0, 0, NULL, 0};
  x.a = 100;
  x.d = 100;
  x.g = 2;
  /* Struct should now look like {100, 0, 0, 100, 0, 0, 0, 2}.  */
  bar (&x);
  return 0;
}
// source: pr68185.c
/* { dg-skip-if "ptxas crashes or executes incorrectly" { nvptx-*-* } { "-O0" "-Os" } { "" } } Reported 2015-11-20  */

int a, b, d = 1, e, f, o, u, w = 1, z;
short c, q, t;

int
main ()
{
  char g;
  for (; d; d--)
    {
      while (o)
	for (; e;)
	  {
	    c = b;
	    int h = o = z;
	    for (; u;)
	      for (; a;)
		;
	  }
      if (t < 1)
	g = w;
      f = g;
      g && (q = 1);
    }

  if (q != 1)
    __builtin_abort ();

  return 0;
}
// source: pr68249.c
/* PR rtl-optimization/68249 */

int a, b, c, g, k, l, m, n;
char h;

void
fn1 ()
{
  for (; k; k++)
    {
      m = b || c < 0 || c > 1 ? : c;
      g = l = n || m < 0 || (m > 1) > 1 >> m ? : 1 << m;
    }
  l = b + 1;
  for (; b < 1; b++)
    h = a + 1;
}

int
main ()
{
  char j;
  for (; a < 1; a++)
    {
      fn1 ();
      if (h)
	j = h;
      if (j > c)
	g = 0;
    }

  if (h != 1)
    __builtin_abort ();

  return 0;
}
// source: pr68250.c
/* PR rtl-optimization/68250 */

signed char a, b, h, k, l, m, o;
short c, d, n;
int e, f, g, j, q;

void
fn1 (void)
{
  int p = b || a;
  n = o > 0 || d > 1 >> o ? d : d << o;
  for (; j; j++)
    m = c < 0 || m || c << p;
  l = f + 1;
  for (; f < 1; f = 1)
    k = h + 1;
}

__attribute__((noinline, noclone)) void
fn2 (int k)
{
  if (k != 1)
    __builtin_abort ();
}

int
main ()
{
  signed char i;
  for (; e < 1; e++)
    {
      fn1 ();
      if (k)
	i = k;
      if (i > q)
	g = 0;
    }
  fn2 (k);
  return 0;
}
// source: pr68321.c
/* PR rtl-optimization/68321 */

int e = 1, u = 5, t2, t5, i, k;
int a[1], b, m;
char n, t;

int
fn1 (int p1)
{
  int g[1];
  for (;;)
    {
      if (p1 / 3)
	for (; t5;)
	  u || n;
      t2 = p1 & 4;
      if (b + 1)
	return 0;
      u = g[0];
    }
}

int
main ()
{
  for (; e >= 0; e--)
    {
      char c;
      if (!m)
	c = t;
      fn1 (c);
    }

  if (a[t2] != 0)
    __builtin_abort ();

  return 0;
}
// source: pr68328.c
int a, b, c = 1, d = 1, e;

__attribute__ ((noinline, noclone))
     int foo (void)
{
  asm volatile ("":::"memory");
  return 4195552;
}

__attribute__ ((noinline, noclone))
     void bar (int x, int y)
{
  asm volatile (""::"g" (x), "g" (y):"memory");
  if (y == 0)
    __builtin_abort ();
}

int
baz (int x)
{
  char g, h;
  int i, j;

  foo ();
  for (;;)
    {
      if (c)
	h = d;
      g = h < x ? h : 0;
      i = (signed char) ((unsigned char) (g - 120) ^ 1);
      j = i > 97;
      if (a - j)
	bar (0x123456, 0);
      if (!b)
	return e;
    }
}

int
main ()
{
  baz (2);
  return 0;
}
// source: pr68376-1.c
/* PR rtl-optimization/68376 */

int a, b, c = 1;
signed char d;

int
main ()
{
  for (; a < 1; a++)
    for (; b < 1; b++)
      {
	signed char e = ~d;
	if (d < 1)
	  e = d;
	d = e;
	if (!c)
	  __builtin_abort ();
      }

  if (d != 0)
    __builtin_abort ();

  return 0;
}
// source: pr68376-2.c
/* PR rtl-optimization/68376 */

extern void abort (void);

__attribute__((noinline, noclone)) int
f1 (int x)
{
  return x < 0 ? ~x : x;
}

__attribute__((noinline, noclone)) int
f2 (int x)
{
  return x < 0 ? x : ~x;
}

__attribute__((noinline, noclone)) int
f3 (int x)
{
  return x <= 0 ? ~x : x;
}

__attribute__((noinline, noclone)) int
f4 (int x)
{
  return x <= 0 ? x : ~x;
}

__attribute__((noinline, noclone)) int
f5 (int x)
{
  return x >= 0 ? ~x : x;
}

__attribute__((noinline, noclone)) int
f6 (int x)
{
  return x >= 0 ? x : ~x;
}

__attribute__((noinline, noclone)) int
f7 (int x)
{
  return x > 0 ? ~x : x;
}

__attribute__((noinline, noclone)) int
f8 (int x)
{
  return x > 0 ? x : ~x;
}

int
main ()
{
  if (f1 (5) != 5 || f1 (-5) != 4 || f1 (0) != 0)
    abort ();
  if (f2 (5) != -6 || f2 (-5) != -5 || f2 (0) != -1)
    abort ();
  if (f3 (5) != 5 || f3 (-5) != 4 || f3 (0) != -1)
    abort ();
  if (f4 (5) != -6 || f4 (-5) != -5 || f4 (0) != 0)
    abort ();
  if (f5 (5) != -6 || f5 (-5) != -5 || f5 (0) != -1)
    abort ();
  if (f6 (5) != 5 || f6 (-5) != 4 || f6 (0) != 0)
    abort ();
  if (f7 (5) != -6 || f7 (-5) != -5 || f7 (0) != 0)
    abort ();
  if (f8 (5) != 5 || f8 (-5) != 4 || f8 (0) != -1)
    abort ();
  return 0;
}
// source: pr68381.c
/* { dg-options "-O -fexpensive-optimizations -fno-tree-bit-ccp" } */

__attribute__ ((noinline, noclone))
int
foo (unsigned short x, unsigned short y)
{
  int r;
  if (__builtin_mul_overflow (x, y, &r))
    __builtin_abort ();
  return r;
}

int
main (void)
{
  int x = 1;
  int y = 2;
  if (foo (x, y) != x * y)
    __builtin_abort ();
  return 0;
}
// source: pr68390.c
/* { dg-do run }  */
/* { dg-options "-O2" } */

__attribute__ ((noinline))
double direct(int x, ...)
{
  return x*x;
}

__attribute__ ((noinline))
double broken(double (*indirect)(int x, ...), int v)
{
  return indirect(v);
}

int main ()
{
  double d1, d2;
  int i = 2;
  d1 = broken (direct, i);
  if (d1 != i*i)
    {
      __builtin_abort ();
    }
  return 0;
}
// source: pr68506.c
/* { dg-options "-fno-builtin-abort" } */

int a, b, m, n, o, p, s, u, i;
char c, q, y;
short d;
unsigned char e;
static int f, h;
static short g, r, v;
unsigned t;

extern void abort ();

int
fn1 (int p1)
{
  return a ? p1 : p1 + a;
}

unsigned char
fn2 (unsigned char p1, int p2)
{
  return p2 >= 2 ? p1 : p1 >> p2;
}

static short
fn3 ()
{
  int w, x = 0;
  for (; p < 31; p++)
    {
      s = fn1 (c | ((1 && c) == c));
      t = fn2 (s, x);
      c = (unsigned) c > -(unsigned) ((o = (m = d = t) == p) <= 4UL) && n;
      v = -c;
      y = 1;
      for (; y; y++)
	e = v == 1;
      d = 0;
      for (; h != 2;)
	{
	  for (;;)
	    {
	      if (!m)
		abort ();
	      r = 7 - f;
	      x = e = i | r;
	      q = u * g;
	      w = b == q;
	      if (w)
		break;
	    }
	  break;
	}
    }
  return x;
}

int
main ()
{
  fn3 ();
  return 0;
}
// source: pr68532.c
/* { dg-options "-O2 -ftree-vectorize -fno-vect-cost-model" } */
/* { dg-additional-options "-fno-common" { target hppa*-*-hpux* } } */

#define SIZE 128
unsigned short _Alignas (16) in[SIZE];

__attribute__ ((noinline)) int
test (unsigned short sum, unsigned short *in, int x)
{
  for (int j = 0; j < SIZE; j += 8)
    sum += in[j] * x;
  return sum;
}

int
main ()
{
  for (int i = 0; i < SIZE; i++)
    in[i] = i;
  if (test (0, in, 1) != 960)
    __builtin_abort ();
  return 0;
}
// source: pr68624.c
int b, c, d, e = 1, f, g, h, j;

static int
fn1 ()
{
  int a = c;
  if (h)
    return 9;
  g = (c || b) % e;
  if ((g || f) && b)
    return 9;
  e = d;
  for (c = 0; c > -4; c--)
    ;
  if (d)
    c--;
  j = c;
  return d;
}

int
main ()
{
  fn1 ();

  if (c != -4)
    __builtin_abort ();

  return 0;
}
// source: pr68648.c
/* { dg-require-effective-target int32plus } */
int __attribute__ ((noinline))
foo (void)
{
  return 123;
}

int __attribute__ ((noinline))
bar (void)
{
  int c = 1;
  c |= 4294967295 ^ (foo () | 4073709551608);
  return c;
}

int
main ()
{
  if (bar () != 0x83fd4005)
    __builtin_abort ();
}
// source: pr68841.c
static inline int
foo (int *x, int y)
{
  int z = *x;
  while (y > z)
    z *= 2;
  return z;
}

int
main ()
{
  int i;
  for (i = 1; i < 17; i++)
    {
      int j;
      int k;
      j = foo (&i, 7);
      if (i >= 7)
	k = i;
      else if (i >= 4)
	k = 8 + (i - 4) * 2;
      else if (i == 3)
	k = 12;
      else
	k = 8;
      if (j != k)
	__builtin_abort ();
    }
  return 0;
}
// source: pr68911.c
extern void abort (void);

char a;
int b, c;
short d;

int main ()
{
  unsigned e = 2;
  unsigned timeout = 0;

  for (; c < 2; c++)
    {
      int f = ~e / 7;
      if (f)
	a = e = ~(b && d);
      while (e < 94)
	{
	  e++;
	  if (++timeout > 100)
	    goto die;
	}
    }
  return 0;
die:
  abort ();
}
// source: pr69097-1.c
/* PR tree-optimization/69097 */

int a, b;
unsigned int c;

int
main ()
{
  int d = b;
  b = ~(~a + (~d | b));
  a = ~(~c >> b);
  c = a % b;
  return 0;
}
// source: pr69097-2.c
/* PR tree-optimization/69097 */

__attribute__((noinline, noclone)) int
f1 (int x, int y)
{
  return x % y;
}

__attribute__((noinline, noclone)) int
f2 (int x, int y)
{
  return x % -y;
}

__attribute__((noinline, noclone)) int
f3 (int x, int y)
{
  int z = -y;
  return x % z;
}

int
main ()
{
  if (f1 (-__INT_MAX__ - 1, 1) != 0
      || f2 (-__INT_MAX__ - 1, -1) != 0
      || f3 (-__INT_MAX__ - 1, -1) != 0)
    __builtin_abort ();
  return 0;
}
// source: pr69320-1.c
#include <stdlib.h>
int a, b, d, f;
char c;
static int *e = &d;
int main() {
  int g = -1L;
  *e = g;
  c = 4;
  for (; c >= 14; c++)
    *e = 1;
  f = a == 0;
  *e ^= f;
  int h = ~d;
  if (d)
    b = h;
  if (h)
    exit (0);
  abort ();
}
// source: pr69320-2.c

#include <stdlib.h>

int a, *c, d, e, g, f;
short b;

int
fn1 ()
{
  int h = d != 10;
  if (h > g)
     asm volatile ("" : : : "memory");
  if (h == 10)
    {
      int *i = 0;
      a = 0;
      for (; a < 7; a++)
	for (; *i;)
	  ;
    }
  else
    {
      b = e / h;
      return f;
    }
  c = &h;
  abort ();
}

int
main ()
{
  fn1 ();
  exit (0);
}
// source: pr69320-3.c
#include <stdlib.h>

static int a[40] = {7, 5, 3, 3, 0, 0, 3};
short b;
int c = 5;
int main() {
  b = 0;
  for (; b <= 3; b++)
    if (a[b + 6] ^ (0 || c))
      ;
    else
      break;
  if (b != 4)
    abort ();
  exit (0);
}
// source: pr69320-4.c
#include <stdlib.h>

int a;
char b, d;
short c;
short fn1(int p1, int p2) { return p2 >= 2 ? p1 : p1 > p2; }

int main() {
  int *e = &a, *f = &a;
  b = 1;
  for (; b <= 9; b++) {
    c = *e != 5 || d;
    *f = fn1(c || b, a);
  }
  if ((long long) a != 1)
    abort ();
  exit (0);
}
// source: pr69403.c
/* PR target/69403.  */

int a, b, c;

__attribute__ ((__noinline__)) int
fn1 ()
{
  if ((b | (a != (a & c))) == 1)
    __builtin_abort ();
  return 0;
}

int
main (void)
{
  a = 5;
  c = 1;
  b = 6;
  return fn1 ();
}
// source: pr69447.c
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;

u64 __attribute__((noinline, noclone))
foo(u8 u8_0, u16 u16_0, u64 u64_0, u8 u8_1, u16 u16_1, u64 u64_1, u64 u64_2, u8 u8_3, u64 u64_3)
{
	u64_1 *= 0x7730;
	u64_3 *= u64_3;
	u16_1 |= u64_3;
	u64_3 -= 2;
	u8_3 /= u64_2;
	u8_0 |= 3;
	u64_3 %= u8_0;
	u8_0 -= 1;
	return u8_0 + u16_0 + u64_0 + u8_1 + u16_1 + u64_1 + u8_3 + u64_3;
}

int main()
{
	unsigned x = foo(1, 1, 1, 1, 1, 1, 1, 1, 1);
	if (x != 0x7737)
		__builtin_abort();
	return 0;
}
// source: pr69691.c
/* PR rtl-optimization/69691 */

char u[] = { 46, 97, 99, 104, 52, 0 };
char *v[] = { u, 0 };
struct S { char a[10]; struct S *b[31]; };
struct S r[7], *r2 = r;
static struct S *w = 0;

__attribute__((noinline, noclone)) int
fn (int x)
{
  if (__builtin_strchr (u, x) || x == 96)
    return x;
  __builtin_abort ();
}

__attribute__((noinline, noclone)) int
foo (char x)
{
  if (x == 0)
    __builtin_abort ();
  if (fn (x) >= 96 && fn (x) <= 122)
    return (fn (x) - 96);
  else if (x == 46)
    return 0;
  else
    {
      __builtin_printf ("foo %d\n", x);
      return -1;
    }
}

__attribute__((noinline, noclone)) void
bar (char **x)
{
  char **b, c, *d, e[500], *f, g[10];
  int z, l, h, i;
  struct S *s;

  w = r2++;
  for (b = x; *b; b++)
    {
      __builtin_strcpy (e, *b);
      f = e;
      do
	{
	  d = __builtin_strchr (f, 32);
	  if (d)
	    *d = 0;
	  l = __builtin_strlen (f);
	  h = 0;
	  s = w;
	  __builtin_memset (g, 0, sizeof (g));
	  for (z = 0; z < l; z++)
	    {
	      c = f[z];
	      if (c >= 48 && c <= 57)
		g[h] = c - 48;
	      else
		{
		  i = foo (c);
		  if (!s->b[i])
		    {
		      s->b[i] = r2++;
		      if (r2 == &r[7])
			__builtin_abort ();
		    }
		  s = s->b[i];
		  h++;
		}
	    }
	  __builtin_memcpy (s->a, g, 10);
	  if (d)
	    f = d + 1;
	}
      while (d);
    }
}

__attribute__((noinline, noclone)) void
baz (char *x)
{
  char a[300], b[300];
  int z, y, t, l;
  struct S *s;

  l = __builtin_strlen (x);
  *a = 96;
  for (z = 0; z < l; z++)
    {
      a[z + 1] = fn ((unsigned int) x[z]);
      if (foo (a[z + 1]) <= 0)
	return;
    }
  a[l + 1] = 96;
  l += 2;
  __builtin_memset (b, 0, l + 2);

  if (!w)
    return;

  for (z = 0; z < l; z++)
    {
      s = w;
      for (y = z; y < l; y++)
	{
	  s = s->b[foo (a[y])];
	  if (!s)
	    break;
	  for (t = 0; t <= y - z + 2; t++)
	    if (s->a[t] > b[z + t])
	      b[z + t] = s->a[t];
	}
    }
  for (z = 3; z < l - 2; z++)
    if ((b[z] & 1) == 1)
     asm ("");
}

int
main ()
{
  bar (v);
  char c[] = { 97, 97, 97, 97, 97, 0 };
  baz (c);
  return 0;
}
// source: pr70005.c

unsigned char a = 6;
int b, c;

static void
fn1 ()
{
  int i = a > 1 ? 1 : a, j = 6 & (c = a && (b = a));
  int d = 0, e = a, f = ~c, g = b || a;
  unsigned char h = ~a;
  if (a)
    f = j;
  if (h && g)
    d = a;
  i = -~(f * d * h) + c && (e || i) ^ f;
  if (i != 1)
    __builtin_abort ();
}

int
main ()
{
  fn1 ();
  return 0;
}
// source: pr70127.c
/* PR tree-optimization/70127 */

struct S { int f; signed int g : 2; } a[1], c = {5, 1}, d;
short b;

__attribute__((noinline, noclone)) void
foo (int x)
{
  if (x != 1)
    __builtin_abort ();
}

int
main ()
{
  while (b++ <= 0)
    {
      struct S e = {1, 1};
      d = e = a[0] = c;
    }
  foo (a[0].g);
  return 0;
}
// source: pr70222-1.c
/* PR rtl-optimization/70222 */

int a = 1;
unsigned int b = 2;
int c = 0;
int d = 0;

void
foo ()
{
  int e = ((-(c >= c)) < b) > ((int) (-1ULL >> ((a / a) * 15)));
  d = -e;
}

__attribute__((noinline, noclone)) void
bar (int x)
{
  if (x != -1)
    __builtin_abort ();
}

int
main ()
{
#if __CHAR_BIT__ == 8 && __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8
  foo ();
  bar (d);
#endif
  return 0;
}
// source: pr70222-2.c
/* PR rtl-optimization/70222 */

#if __CHAR_BIT__ == 8 && __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8
__attribute__((noinline, noclone)) unsigned int
foo (int x)
{
  unsigned long long y = -1ULL >> x;
  return (unsigned int) y >> 31;
}
#endif

int
main ()
{
#if __CHAR_BIT__ == 8 && __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8
  if (foo (15) != 1 || foo (32) != 1 || foo (33) != 0)
    __builtin_abort ();
#endif
  return 0;
}
// source: pr70429.c
/* PR rtl-optimization/70429 */

__attribute__((noinline, noclone)) int
foo (int a)
{
  return (int) (0x14ff6e2207db5d1fLL >> a) >> 4;
}

int
main ()
{
  if (sizeof (int) != 4 || sizeof (long long) != 8 || __CHAR_BIT__ != 8)
    return 0;
  if (foo (1) != 0x3edae8 || foo (2) != -132158092)
    __builtin_abort ();
  return 0;
}
// source: pr70460.c
/* { dg-require-effective-target indirect_jumps } */
/* { dg-require-effective-target label_values } */
/* { dg-skip-if "label differences not supported" { avr-*-* } } */

/* PR rtl-optimization/70460 */

int c;

__attribute__((noinline, noclone)) void
foo (int x)
{
  static int b[] = { &&lab1 - &&lab0, &&lab2 - &&lab0 };
  void *a = &&lab0 + b[x];
  goto *a;
lab1:
  c += 2;
lab2:
  c++;
lab0:
  ;
}

int
main ()
{
  foo (0);
  if (c != 3)
    __builtin_abort ();
  foo (1);
  if (c != 4)
    __builtin_abort ();
  return 0;
}
// source: pr70566.c
/* PR target/70566.  */

#define NULL 0

struct mystruct
{
  unsigned int f1 : 1;
  unsigned int f2 : 1;
  unsigned int f3 : 1;
};

__attribute__ ((noinline)) void
myfunc (int a, void *b)
{
}
__attribute__ ((noinline)) int
myfunc2 (void *a)
{
  return 0;
}

static void
set_f2 (struct mystruct *user, int f2)
{
  if (user->f2 != f2)
    myfunc (myfunc2 (NULL), NULL);
  else
    __builtin_abort ();
}

__attribute__ ((noinline)) void
foo (void *data)
{
  struct mystruct *user = data;
  if (!user->f2)
    set_f2 (user, 1);
}

int
main (void)
{
  struct mystruct a;
  a.f1 = 1;
  a.f2 = 0;
  foo (&a);
  return 0;
}
// source: pr70586.c
/* PR tree-optimization/70586 */

int a, e, f;
short b, c, d;

int
foo (int x, int y)
{
  return (y == 0 || (x && y == 1)) ? x : x % y;
}

static short
bar (void)
{
  int i = foo (c, f);
  f = foo (d, 2);
  int g = foo (b, c);
  int h = foo (g > 0, c);
  c = (3 >= h ^ 7) <= foo (i, c);
  if (foo (e, 1))
    return a;
  return 0;
}

int
main ()
{
  bar ();
  return 0;
}
// source: pr70602.c
/* PR tree-optimization/70602 */
/* { dg-require-effective-target int32plus } */

struct __attribute__((packed)) S
{
  int s : 1;
  int t : 20;
};

int a, b, c;

int
main ()
{
  for (; a < 1; a++)
    {
      struct S e[] = { {0, 9}, {0, 9}, {0, 9}, {0, 0}, {0, 9}, {0, 9}, {0, 9},
		       {0, 0}, {0, 9}, {0, 9}, {0, 9}, {0, 0}, {0, 9}, {0, 9},
		       {0, 9}, {0, 0}, {0, 9}, {0, 9}, {0, 9}, {0, 0}, {0, 9} };
      b = b || e[0].s;
      c = e[0].t;
    }
  return 0;
}
// source: pr70903.c
typedef unsigned char V8 __attribute__ ((vector_size (32)));
typedef unsigned int V32 __attribute__ ((vector_size (32)));
typedef unsigned long long V64 __attribute__ ((vector_size (32)));

static V32 __attribute__ ((noinline, noclone))
foo (V64 x)
{
  V64 y = (V64)(V8){((V8)(V64){65535, x[0]})[1]};
  return (V32){y[0], 255};
}

int main ()
{
  V32 x = foo ((V64){});
//  __builtin_printf ("%08x %08x %08x %08x %08x %08x %08x %08x\n", x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7]);
  if (x[1] != 255)
    __builtin_abort();
  return 0;
}
// source: pr71083.c
__extension__ typedef __UINT32_TYPE__ uint32_t;

struct lock_chain {
  uint32_t irq_context: 2,
    depth: 6,
    base: 24;
};

__attribute__((noinline, noclone))
struct lock_chain * foo (struct lock_chain *chain)
{
  int i;
  for (i = 0; i < 100; i++)
    {
      chain[i+1].base = chain[i].base;
    }
  return chain;
}

struct lock_chain1 {
  char x;
  unsigned short base;
} __attribute__((packed));

__attribute__((noinline, noclone))
struct lock_chain1 * bar (struct lock_chain1 *chain)
{
  int i;
  for (i = 0; i < 100; i++)
    {
      chain[i+1].base = chain[i].base;
    }
  return chain;
}

struct lock_chain test [101];
struct lock_chain1 test1 [101];

int
main ()
{
  foo (test);
  bar (test1);
  return 0;
}
// source: pr71335.c
int a;
int
main ()
{
  int b = 0;
  while (a < 0 || b)
    {
      b = 0;
      for (; b < 9; b++)
	;
    }
  exit (0);
}
// source: pr71494.c
/* PR middle-end/71494 */
/* { dg-require-effective-target label_values } */

int
main ()
{
  void *label = &&out;
  int i = 0;
  void test (void)
  {
    label = &&out2;
    goto *label;
   out2:;
    i++;
  }
  goto *label;
 out:
  i += 2;
  test ();
  if (i != 3)
    __builtin_abort ();
  return 0;
}
// source: pr71550.c

extern void exit (int);

int a = 3, b, c, f, g, h;
unsigned d;
char *e;

int
main ()
{
  for (; a; a--)
    {
      int i;
      if (h && i)
	__builtin_printf ("%d%d", c, f);
      i = 0;
      for (; i < 2; i++)
	if (g)
	  for (; d < 10; d++)
	    b = *e;
      i = 0;
      for (; i < 1; i++)
	;
    }
  exit (0);
}
// source: pr71554.c
/* PR target/71554 */

int v;

__attribute__ ((noinline, noclone)) void
bar (void)
{
  v++;
}

__attribute__ ((noinline, noclone))
void
foo (unsigned int x)
{
  signed int y = ((-__INT_MAX__ - 1) / 2);
  signed int r;
  if (__builtin_mul_overflow (x, y, &r))
    bar ();
}

int
main ()
{
  foo (2);
  if (v)
    __builtin_abort ();
  return 0;
}
// source: pr71626-1.c
/* PR middle-end/71626 */

typedef __INTPTR_TYPE__ V __attribute__((__vector_size__(sizeof (__INTPTR_TYPE__))));

__attribute__((noinline, noclone)) V
foo ()
{
  V v = { (__INTPTR_TYPE__) foo };
  return v;
}

int
main ()
{
  V v = foo ();
  if (v[0] != (__INTPTR_TYPE__) foo)
    __builtin_abort ();
  return 0;
}
// source: pr71626-2.c
/* PR middle-end/71626 */
/* { dg-additional-options "-fpic" { target fpic } } */

#include "pr71626-1.c"
// source: pr71631.c
/* PR tree-optimization/71631 */

volatile char v;
int a = 1, b = 1, c = 1;

void
foo (const char *s)
{
  while (*s++)
    v = *s;
}

int
main ()
{
  volatile int d = 1;
  volatile int e = 1;
  int f = 1 / a;
  int g = 1U < f;
  int h = 2 + g;
  int i = 3 % h;
  int j = e && b;
  int k = 1 == c;
  int l = d != 0;
  short m = (short) (-1 * i * l);
  short x = j * (k * m);
  if (i == 1)
    foo ("AB");
  if (x != -1)
    __builtin_abort ();
  return 0;
}
// source: pr71700.c
struct S
{
  signed f0 : 16;
  unsigned f1 : 1;
};

int b;
static struct S c[] = {{-1, 0}, {-1, 0}};
struct S d;

int
main ()
{
  struct S e = c[0];
  d = e;
  if (d.f1 != 0)
    __builtin_abort ();
  return 0;
}
// source: pr7284-1.c
/* Signed left-shift is implementation-defined in C89 (and see
   DR#081), not undefined.  Bug 7284 from Al Grant (AlGrant at
   myrealbox.com).  */

/* { dg-require-effective-target int32plus } */
/* { dg-options "-std=c89" } */

extern void abort (void);
extern void exit (int);

int
f (int n)
{
  return (n << 24) / (1 << 23);
}

volatile int x = 128;

int
main (void)
{
  if (f(x) != -256)
    abort ();
  exit (0);
}
// source: pr77718.c
/* PR middle-end/77718 */

char a[64] __attribute__((aligned (8)));

__attribute__((noinline, noclone)) int
foo (void)
{
  return __builtin_memcmp ("bbbbbb", a, 6);
}

__attribute__((noinline, noclone)) int
bar (void)
{
  return __builtin_memcmp (a, "bbbbbb", 6);
}

int
main ()
{
  __builtin_memset (a, 'a', sizeof (a));
  if (((foo () < 0) ^ ('a' > 'b'))
      || ((bar () < 0) ^ ('a' < 'b')))
    __builtin_abort ();
  return 0;
}
// source: pr77766.c
char a;
short b, d = 5, h;
char c[1];
int e, f = 4, g, j;
int main() {
  int i;
  for (; f; f = a) {
    g = 0;
    for (; g <= 32; ++g) {
      i = 0;
      for (; i < 3; i++)
        while (1 > d)
          if (c[b])
            break;
    L:
      if (j)
        break;
    }
  }
  e = 0;
  for (; e; e = 0) {
    d++;
    for (; h;)
      goto L;
  }
  return 0;
}
// source: pr77767.c
/* PR c/77767 */

void
foo (int a, int b[a++], int c, int d[c++])
{
  if (a != 2 || c != 2)
    __builtin_abort ();
}

int
main ()
{
  int e[10];
  foo (1, e, 1, e);
  return 0;
}
// source: pr78170.c
/* { dg-require-effective-target int32plus } */

/* PR tree-optimization/78170.
   Check that sign-extended store to a bitfield
   doesn't overwrite other fields.  */

int a, b, d;

struct S0
{
  int f0;
  int f1;
  int f2;
  int f3;
  int f4;
  int f5:15;
  int f6:17;
  int f7:2;
  int f8:30;
} c;

void fn1 ()
{
  d = b = 1;
  for (; b; b = a)
    {
      struct S0 e = { 0, 0, 0, 0, 0, 0, 1, 0, 1 };
      c = e;
      c.f6 = -1;
    }
}

int main ()
{
  fn1 ();
  if (c.f7 != 0)
    __builtin_abort ();
  return 0;
}
// source: pr78378.c
/* PR rtl-optimization/78378 */

unsigned long long __attribute__ ((noinline, noclone))
foo (unsigned long long x)
{
  x <<= 41;
  x /= 232;
  return 1 + (unsigned short) x;
}

int
main ()
{
  unsigned long long x = foo (1);
  if (x != 0x2c24)
    __builtin_abort();
  return 0;
}
// source: pr78436.c
/* PR tree-optimization/78436 */

struct S
{
  long int a : 24;
  signed char b : 8;
} s;

__attribute__((noinline, noclone)) void
foo ()
{
  s.b = 0;
  s.a = -1193165L;
}

int
main ()
{
  foo ();
  if (s.b != 0)
    __builtin_abort ();
  return 0;
}
// source: pr78438.c
/* PR target/78438 */

char a = 0;
int b = 197412621;

__attribute__ ((noinline, noclone))
void foo ()
{
  a = 0 > (short) (b >> 11);
}

int
main ()
{
  asm volatile ("" : : : "memory");
  if (__CHAR_BIT__ != 8 || sizeof (short) != 2 || sizeof (int) < 4)
    return 0;
  foo ();
  if (a != 0)
    __builtin_abort ();
  return 0;
}
// source: pr78477.c
/* PR rtl-optimization/78477 */

unsigned a;
unsigned short b;

unsigned
foo (unsigned x)
{
  b = x;
  a >>= (b & 1);
  b = 1 | (b << 5);
  b >>= 15;
  x = (unsigned char) b > ((2 - (unsigned char) b) & 1);
  b = 0;
  return x;
}

int
main ()
{
  if (__CHAR_BIT__ != 8 || sizeof (short) != 2 || sizeof (int) < 4)
    return 0;
  unsigned x = foo (12345);
  if (x != 0)
    __builtin_abort ();
  return 0;
}
// source: pr78559.c
/* PR rtl-optimization/78559 */

int g = 20;
int d = 0;

short
fn2 (int p1, int p2)
{
  return p2 >= 2 || 5 >> p2 ? p1 : p1 << p2;
}

int
main ()
{
  int result = 0;
lbl_2582:
  if (g)
    {
      for (int c = -3; c; c++)
        result = fn2 (1, g);
    }
  else
    {
      for (int i = 0; i < 2; i += 2)
        if (d)
          goto lbl_2582;
    }
  if (result != 1)
    __builtin_abort ();
  return 0;
}
// source: pr78586.c
/* PR tree-optimization/78586 */

void
foo (unsigned long x)
{
  char a[30];
  unsigned long b = __builtin_sprintf (a, "%lu", x);
  if (b != 4)
    __builtin_abort ();
}

int
main ()
{
  foo (1000);
  return 0;
}
// source: pr78617.c
int a = 0;
int d = 1;
int f = 1;

int fn1() {
  return a || 1 >> a;
}

int fn2(int p1, int p2) {
  return p2 >= 2 ? p1 : p1 >> 1;
}

int fn3(int p1) {
  return d ^ p1;
}

int fn4(int p1, int p2) {
  return fn3(!d > fn2((f = fn1() - 1000) || p2, p1));
}

int main() {
  if (fn4(0, 0) != 1)
    __builtin_abort ();
  return 0;
}
// source: pr78622.c
/* PR middle-end/78622 - [7 Regression] -Wformat-overflow/-fprintf-return-value
   incorrect with overflow/wrapping
   { dg-skip-if "Requires %hhd format" { hppa*-*-hpux* } }
   { dg-require-effective-target c99_runtime }
   { dg-additional-options "-Wformat-overflow=2" } */

__attribute__((noinline, noclone)) int
foo (int x)
{
  if (x < 4096 + 8 || x >= 4096 + 256 + 8)
    return -1;

  char buf[5];
  int n = __builtin_snprintf (buf, sizeof buf, "%hhd", x + 1);
  __builtin_printf ("\"%hhd\" => %i\n", x + 1, n);
  return n;
}

int
main (void)
{
  if (__SCHAR_MAX__ != 127 || __CHAR_BIT__ != 8 || __SIZEOF_INT__ != 4)
    return 0;

  if (foo (4095 + 9) != 1
      || foo (4095 + 32) != 2
      || foo (4095 + 127) != 3
      || foo (4095 + 128) != 4
      || foo (4095 + 240) != 3
      || foo (4095 + 248) != 2
      || foo (4095 + 255) != 2
      || foo (4095 + 256) != 1)
    __builtin_abort ();

  return 0;
}
// source: pr78675.c
/* PR tree-optimization/78675 */

long int a;

__attribute__((noinline, noclone)) long int
foo (long int x)
{
  long int b;
  while (a < 1)
    {
      b = a && x;
      ++a;
    }
  return b;
}

int
main ()
{
  if (foo (0) != 0)
    __builtin_abort ();
  a = 0;
  if (foo (1) != 0)
    __builtin_abort ();
  a = 0;
  if (foo (25) != 0)
    __builtin_abort ();
  a = -64;
  if (foo (0) != 0)
    __builtin_abort ();
  a = -64;
  if (foo (1) != 0)
    __builtin_abort ();
  a = -64;
  if (foo (25) != 0)
    __builtin_abort ();
  return 0;
}
// source: pr78720.c
/* PR tree-optimization/78720 */

__attribute__((noinline, noclone)) long int
foo (signed char x)
{
  return x < 0 ? 0x80000L : 0L;
}

__attribute__((noinline, noclone)) long int
bar (signed char x)
{
  return x < 0 ? 0x80L : 0L;
}

__attribute__((noinline, noclone)) long int
baz (signed char x)
{
  return x < 0 ? 0x20L : 0L;
}

int
main ()
{
  if (foo (-1) != 0x80000L || bar (-1) != 0x80L || baz (-1) != 0x20L
      || foo (0) != 0L || bar (0) != 0L || baz (0) != 0L
      || foo (31) != 0L || bar (31) != 0L || baz (31) != 0L)
    __builtin_abort ();
  return 0;
}
// source: pr78726.c
/* PR tree-optimization/78726 */

unsigned char b = 36, c = 173;
unsigned int d;

__attribute__((noinline, noclone)) void
foo (void)
{
  unsigned a = ~b;
  d = a * c * c + 1023094746U * a;
}

int
main ()
{
  if (__SIZEOF_INT__ != 4 || __CHAR_BIT__ != 8)
    return 0;
  asm volatile ("" : : "g" (&b), "g" (&c) : "memory");
  foo ();
  if (d != 799092689U)
    __builtin_abort ();
  return 0;
}
// source: pr78791.c
/* PR target/78791 */

__attribute__((used, noinline, noclone)) unsigned long long
foo (unsigned long long x, unsigned long long y, unsigned long long z)
{
  unsigned long long a = x / y;
  unsigned long long b = x % y;
  a |= z;
  b ^= z;
  return a + b;
}

int
main ()
{
  if (foo (64, 7, 0) != 10 || foo (28, 3, 2) != 14)
    __builtin_abort ();
  return 0;
}
// source: pr78856.c
extern void exit (int);

int a, b, c, d, e, f[3];

int main()
{
  while (d)
    while (1)
      ;
  int g = 0, h, i = 0;
  for (; g < 21; g += 9)
    {
      int j = 1;
      for (h = 0; h < 3; h++)
	f[h] = 1;
      for (; j < 10; j++) {
	d = i && (b ? 0 : c);
	i = 1;
	if (g)
	  a = e;
      }
  }
  exit (0);
}
// source: pr79043.c
/* PR ipa/78791 */

int val;

int *ptr = &val;
float *ptr2 = &val;

static
__attribute__((always_inline, optimize ("-fno-strict-aliasing")))
typepun ()
{
  *ptr2=0;
}

main()
{
  *ptr=1;
  typepun ();
  if (*ptr)
    __builtin_abort ();
}
// source: pr79121.c
#if __SIZEOF_INT__ < 4
  __extension__ typedef __UINT32_TYPE__ uint32_t;
  __extension__ typedef __INT32_TYPE__ int32_t;
#else
  typedef unsigned uint32_t;
  typedef int int32_t;
#endif

extern void abort (void);

__attribute__ ((noinline, noclone)) unsigned long long f1 (int32_t x)
{
  return ((unsigned long long) x) << 4;
}

__attribute__ ((noinline, noclone)) long long f2 (uint32_t x)
{
  return ((long long) x) << 4;
}

__attribute__ ((noinline, noclone)) unsigned long long f3 (uint32_t x)
{
  return ((unsigned long long) x) << 4;
}

__attribute__ ((noinline, noclone)) long long f4 (int32_t x)
{
  return ((long long) x) << 4;
}

int main ()
{
  if (f1 (0xf0000000) != 0xffffffff00000000)
    abort ();
  if (f2 (0xf0000000) != 0xf00000000)
    abort ();
  if (f3 (0xf0000000) != 0xf00000000)
    abort ();
  if (f4 (0xf0000000) != 0xffffffff00000000)
    abort ();
  return 0;
}
// source: pr79286.c
int a = 0, c = 0;
static int d[][8] = {};

int main ()
{
  int e = 0;
  for (int b = 0; b < 4; b++)
    {
      __builtin_printf ("%d\n", b, e);
      while (a && c++)
	e = d[300000000000000000][0];
    }

  return 0;
}
// source: pr79327.c
/* PR tree-optimization/79327 */
/* { dg-require-effective-target c99_runtime } */

volatile int a;

int
main (void)
{
  int i;
  char buf[64];
  if (__builtin_sprintf (buf, "%#hho", a) != 1)
    __builtin_abort ();
  if (__builtin_sprintf (buf, "%#hhx", a) != 1)
    __builtin_abort ();
  a = 1;
  if (__builtin_sprintf (buf, "%#hho", a) != 2)
    __builtin_abort ();
  if (__builtin_sprintf (buf, "%#hhx", a) != 3)
    __builtin_abort ();
  a = 127;
  if (__builtin_sprintf (buf, "%#hho", a) != 4)
    __builtin_abort ();
  if (__builtin_sprintf (buf, "%#hhx", a) != 4)
    __builtin_abort ();
  return 0;
}
// source: pr79354.c
/* PR target/79354 */

int b, f, g;
float e;
unsigned long d;

__attribute__((noinline, noclone)) void
foo (int *a)
{
  for (g = 0; g < 32; g++)
    if (f)
      {
        e = d;
        __builtin_memcpy (&b, &e, sizeof (float));
        b = *a;
      }
}

int
main ()
{
  int h = 5;
  f = 1;
  asm volatile ("" : : : "memory");
  foo (&h);
  asm volatile ("" : : : "memory");
  foo (&b);
  asm volatile ("" : : : "memory");
  return 0;
}
// source: pr79388.c
/* PR rtl-optimization/79388 */
/* { dg-additional-options "-fno-tree-coalesce-vars" } */

unsigned int a, c;

__attribute__ ((noinline, noclone)) unsigned int
foo (unsigned int p)
{
  p |= 1;
  p &= 0xfffe;
  p %= 0xffff;
  c = p;
  return a + p;
}

int
main (void)
{
  int x = foo (6);
  if (x != 6)
    __builtin_abort();
  return 0;
}
// source: pr79450.c
/* PR rtl-optimization/79450 */

unsigned int
foo (unsigned char x, unsigned long long y)
{
  do
    {
      x &= !y;
      x %= 24;
    }
  while (x < y);
  return x + y;
}

int
main (void)
{
  unsigned int x = foo (1, 0);
  if (x != 1)
    __builtin_abort ();
  return 0;
}
// source: pr79737-1.c
/* PR tree-optimization/79737 */

#if __SIZEOF_INT__ < 4
  __extension__ typedef __INT32_TYPE__ int32_t;
#else
  typedef int int32_t;
#endif

#pragma pack(1)
struct S
{
  int32_t b:18;
  int32_t c:1;
  int32_t d:24;
  int32_t e:15;
  int32_t f:14;
} i;
int g, j, k;
static struct S h;

void
foo ()
{
  for (j = 0; j < 6; j++)
    k = 0;
  for (; k < 3; k++)
    {
      struct S m = { 5, 0, -5, 9, 5 };
      h = m;
      if (g)
	i = m;
      h.e = 0;
    }
}

int
main ()
{
  foo ();
  if (h.e != 0)
    __builtin_abort ();
  return 0;
}
// source: pr79737-2.c
/* PR tree-optimization/79737 */

#if __SIZEOF_INT__ < 4
  __extension__ typedef __INT32_TYPE__ int32_t;
#else
  typedef int int32_t;
#endif

#pragma pack(1)
struct S
{
  int32_t b:18;
  int32_t c:1;
  int32_t d:24;
  int32_t e:15;
  int32_t f:14;
} i, j;

void
foo ()
{
  i.e = 0;
  i.b = 5;
  i.c = 0;
  i.d = -5;
  i.f = 5;
}

void
bar ()
{
  j.b = 5;
  j.c = 0;
  j.d = -5;
  j.e = 0;
  j.f = 5;
}

int
main ()
{
  foo ();
  bar ();
  asm volatile ("" : : : "memory");
  if (i.b != j.b || i.c != j.c || i.d != j.d || i.e != j.e || i.f != j.f)
    __builtin_abort ();
}
// source: pr80153.c
/* PR tree-optimization/80153 */

void check (int, int, int) __attribute__((noinline));
void check (int c, int c2, int val)
{
  if (!val) {
    __builtin_abort();
  }
}

static const char *buf;
static int l, i;

void _fputs(const char *str)  __attribute__((noinline));
void _fputs(const char *str)
{
  buf = str;
  i = 0;
  l = __builtin_strlen(buf);
}

char _fgetc() __attribute__((noinline));
char _fgetc()
{
  char val = buf[i];
  i++;
  if (i > l)
    return -1;
  else
    return val;
}

static const char *string = "oops!\n";

int main(void)
{
  int i;
  int c;

  _fputs(string);

  for (i = 0; i < __builtin_strlen(string); i++) {
    c = _fgetc();
    check(c, string[i], c == string[i]);
  }

  return 0;
}
// source: pr80421.c
/* PR middle-end/80421 */

__attribute__ ((noinline, noclone)) void
baz (const char *t, ...)
{
  asm volatile (""::"r" (t):"memory");
  if (*t == 'T')
    __builtin_abort ();
}

unsigned int
foo (char x)
{
  baz ("x %c\n", x);
  switch (x)
    {
    default:
      baz ("case default\n");
      if (x == 'D' || x == 'I')
	baz ("This should never be reached.\n");
      return 0;
    case 'D':
      baz ("case 'D'\n");
      return 0;
    case 'I':
      baz ("case 'I'\n");
      return 0;
    }
}

void
bar (void)
{
  int a = 2;
  int b = 5;
  char c[] = {
    2, 4, 1, 2, 5, 5, 2, 4, 4, 0, 0, 0, 0, 0, 0, 3, 4, 4, 2, 4,
    1, 2, 5, 5, 2, 4, 1, 0, 0, 0, 2, 4, 4, 3, 4, 3, 3, 5, 1, 3,
    5, 5, 2, 4, 4, 2, 4, 1, 3, 5, 3, 3, 5, 1, 3, 5, 1, 2, 4, 4,
    2, 4, 2, 3, 5, 1, 3, 5, 1, 3, 5, 5, 2, 4, 1, 2, 4, 2, 3, 5,
    3, 3, 5, 1, 3, 5, 5, 2, 4, 1, 2, 4, 1, 3, 5, 3, 3, 5, 1, 3,
    5, 5, 2, 4, 4, 2, 4, 1, 3, 5, 3, 3, 5, 1, 3, 5, 1, 2, 4, 1,
    2, 4, 2, 3, 5, 1, 3, 5, 1, 3, 5, 1, 2, 4, 1, 2, 4, 1, 3, 5,
    1, 3, 5, 1, 3, 5, 1, 2, 4, 4, 2, 4, 1, 3, 5, 1, 3, 5, 1, 3,
    5, 5, 2, 4, 4, 2, 4, 2, 3, 5, 3, 3, 5, 1, 3, 5, 5, 2, 4, 4,
    2, 4, 1, 3, 5, 3, 3, 5, 1, 3, 5, 1, 2, 5, 5, 2, 4, 2, 3, 5,
    1, 3, 4, 1, 3, 5, 1, 2, 5, 5, 2, 4, 1, 2, 5, 1, 3, 5, 3, 3,
    5, 1, 2, 5, 5, 2, 4, 2, 2, 5, 1, 3, 5, 3, 3, 5, 1, 2, 5, 1,
    2, 4, 1, 2, 5, 2, 3, 5, 1, 3, 5, 1, 2, 5, 1, 2, 4, 2, 2, 5,
    1, 3, 5, 1, 3, 5, 1, 2, 5, 5, 2, 4, 2, 2, 5, 2, 3, 5, 3, 3,
    5, 1, 2, 5, 5, 2, 4, 2, 2, 5, 2, 3, 5, 3, 3, 5, 1, 2, 5, 5,
    2, 4, 2, 2, 5, 1, 3, 5, 3, 3, 5, 1, 2, 5, 5, 2, 4, 2, 2, 5,
    1, 3, 5, 3, 3, 5, 1, 2, 5, 1, 2, 4, 1, 2, 5, 2, 3, 5, 1, 3,
    5, 1, 2, 5, 5, 2, 4, 2, 2, 5, 2, 3, 5, 3, 3, 5, 1, 2, 5, 5,
    2, 4, 1, 2, 5, 1, 3, 5, 3, 3, 5, 1, 2, 5, 5, 2, 4, 2, 2, 5,
    1, 3, 5, 3, 3, 5, 1, 2, 5, 5, 2, 4, 2, 2, 5, 1, 3, 5, 3, 3,
    5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  };
  char *f = c + 390;
  int i, j, e, g, h;
  char k, l;
  i = 26;
  j = 25;
  k = l = 'M';
  h = 2;
  while (i > 0)
    {
      int x = i - a;
      x = x > 0 ? x : 0;
      x = j - x;
      g = x * 3 + h;
      switch (f[g])
	{
	case 1:
	  --i;
	  --j;
	  h = 2;
	  f -= b * 3;
	  k = 'M';
	  break;
	case 2:
	  --i;
	  h = 0;
	  f -= b * 3;
	  k = 'I';
	  break;
	case 3:
	  --i;
	  h = 2;
	  f -= b * 3;
	  k = 'I';
	  break;
	case 4:
	  --j;
	  h = 1;
	  k = 'D';
	  break;
	case 5:
	  --j;
	  h = 2;
	  k = 'D';
	  break;
	}
      if (k == l)
	++e;
      else
	{
	  foo (l);
	  l = k;
	}
    }
}

int
main ()
{
  char l = 'D';
  foo (l);
  bar ();
  return 0;
}
// source: pr80501.c
/* PR rtl-optimization/80501 */

signed char v = 0;

static signed char
foo (int x, int y)
{
  return x << y;
}

__attribute__((noinline, noclone)) int
bar (void)
{
  return foo (v >= 0, __CHAR_BIT__ - 1) >= 1;
}

int
main ()
{
  if (sizeof (int) > sizeof (char) && bar () != 0)
    __builtin_abort ();
  return 0;
}
// source: pr80692.c
/* { dg-require-effective-target dfp } */

int main () {
	_Decimal64 d64 = -0.DD;

	if (d64 != 0.DD)
		__builtin_abort ();

	if (d64 != -0.DD)
		__builtin_abort ();

	return 0;
}
// source: pr81281.c
/* PR sanitizer/81281 */

void
foo (unsigned p, unsigned a, unsigned b)
{
  unsigned q = p + 7;
  if (a - (1U + __INT_MAX__) >= 2)
    __builtin_unreachable ();
  int d = p + b;
  int c = p + a;
  if (c - d != __INT_MAX__)
    __builtin_abort ();
}

void
bar (unsigned p, unsigned a)
{
  unsigned q = p + 7;
  if (a - (1U + __INT_MAX__) >= 2)
    __builtin_unreachable ();
  int c = p;
  int d = p + a;
  if (c - d != -__INT_MAX__ - 1)
    __builtin_abort ();
}

int
main ()
{
  foo (-1U, 1U + __INT_MAX__, 1U);
  bar (-1U, 1U + __INT_MAX__);
  return 0;
}
// source: pr81423.c
/* PR rtl-optimization/81423 */

extern void abort (void);

unsigned long long int ll = 0;
unsigned long long int ull1 = 1ULL;
unsigned long long int ull2 = 12008284144813806346ULL;
unsigned long long int ull3;

unsigned long long int __attribute__ ((noinline))
foo (void)
{
  ll = -5597998501375493990LL;

  ll = (unsigned int) (5677365550390624949LL - ll) - (ull1 > 0);
  unsigned long long int ull3;
  ull3 = (unsigned int)
    (2067854353LL <<
     (((ll + -2129105131LL) ^ 10280750144413668236ULL) -
      10280750143997242009ULL)) >> ((2873442921854271231ULL | ull2)
				    - 12098357307243495419ULL);

  return ull3;
}

int
main (void)
{
  /* We need a long long of exactly 64 bits and int of exactly 32 bits
     for this test.  */
  if (__SIZEOF_LONG_LONG__ * __CHAR_BIT__ != 64
      || __SIZEOF_INT__ * __CHAR_BIT__ != 32)
    return 0;

  ull3 = foo ();
  if (ull3 != 3998784)
    abort ();
  return 0;
}
// source: pr81503.c
unsigned short a = 41461;
unsigned short b = 3419;
#if __SIZEOF_INT__ >= 4
int c = 0;

void foo() {
  if (a + b * ~(0 != 5))
    c = -~(b * ~(0 != 5)) + 2147483647;
}
#else
__INT32_TYPE__ c = 0;

void foo() {
  if (a + b * ~((__INT32_TYPE__)(0 != 5)))
    c = -~(b * ~((__INT32_TYPE__)(0 != 5))) + 2147483647;
}
#endif

int main() {
  foo();
  if (c != 2147476810)
    return -1;
  return 0;
}
// source: pr81555.c
/* PR tree-optimization/81555 */

unsigned int a = 1, d = 0xfaeU, e = 0xe376U;
_Bool b = 0, f = 1;
unsigned char g = 1;

void
foo (void)
{
  _Bool c = a != b;
  if (c)
    f = 0;
  if (e & c & (unsigned char)d & c)
    g = 0;
}

int
main ()
{
  foo ();
  if (f || g != 1)
    __builtin_abort ();
  return 0;
}
// source: pr81556.c
/* PR tree-optimization/81556 */

unsigned long long int b = 0xb82ff73c5c020599ULL;
unsigned long long int c = 0xd4e8188733a29d8eULL;
unsigned long long int d = 2, f = 1, g = 0, h = 0;
unsigned long long int e = 0xf27771784749f32bULL;

__attribute__((noinline, noclone)) void
foo (void)
{
  _Bool a = d > 1;
  g = f % ((d > 1) << 9);
  h = a & (e & (a & b & c));
}

int
main ()
{
  foo ();
  if (g != 1 || h != 0)
    __builtin_abort ();
  return 0;
}
// source: pr81588.c
/* PR tree-optimization/81588 */

__attribute__((noinline, noclone)) int
bar (int x)
{
  __asm volatile ("" : : "g" (x) : "memory");
}

__attribute__((noinline, noclone)) int
foo (unsigned x, long long y)
{
  if (y < 0)
    return 0;
  if (y < (long long) (4 * x))
    {
      bar (y);
      return 1;
    }
  return 0;
}

int
main ()
{
  volatile unsigned x = 10;
  volatile long long y = -10000;
  if (foo (x, y) != 0)
    __builtin_abort ();
  y = -1;
  if (foo (x, y) != 0)
    __builtin_abort ();
  y = 0;
  if (foo (x, y) != 1)
    __builtin_abort ();
  y = 39;
  if (foo (x, y) != 1)
    __builtin_abort ();
  y = 40;
  if (foo (x, y) != 0)
    __builtin_abort ();
  y = 10000;
  if (foo (x, y) != 0)
    __builtin_abort ();
  return 0;
}
// source: pr81913.c
/* PR tree-optimization/81913 */

typedef __UINT8_TYPE__ u8;
typedef __UINT32_TYPE__ u32;

static u32
b (u8 d, u32 e, u32 g)
{
  do
    {
      e += g + 1;
      d--;
    }
  while (d >= (u8) e);

  return e;
}

int
main (void)
{
  u32 x = b (1, -0x378704, ~0xba64fc);
  if (x != 0xd93190d0)
    __builtin_abort ();
  return 0;
}
// source: pr82192.c
/* PR rtl-optimization/82192 */

unsigned long long int a = 0x95dd3d896f7422e2ULL;
struct S { unsigned int m : 13; } b;

__attribute__((noinline, noclone)) void
foo (void)
{
  b.m = ((unsigned) a) >> (0x644eee9667723bf7LL
			   | a & ~0xdee27af8U) - 0x644eee9667763bd8LL;
}

int
main ()
{
  if (__INT_MAX__ != 0x7fffffffULL)
    return 0;
  foo ();
  if (b.m != 0)
    __builtin_abort ();
  return 0;
}
// source: pr82210.c
/* PR c/82210 */
/* { dg-require-effective-target alloca } */

void
foo (int size)
{
  int i;
  struct S {
    __attribute__((aligned (16))) struct T { short c; } a[size];
    int b[size];
  } s;

  for (i = 0; i < size; i++)
    s.a[i].c = 0x1234;
  for (i = 0; i < size; i++)
    s.b[i] = 0;
  for (i = 0; i < size; i++)
    if (s.a[i].c != 0x1234 || s.b[i] != 0)
      __builtin_abort ();
}

int
main ()
{
  foo (15);
  return 0;
}
// source: pr82387.c
/* PR tree-optimization/82387 */

struct A { int b; };
int f = 1;

struct A
foo (void)
{
  struct A h[] = {
    {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1},
    {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1},
    {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1},
    {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1},
    {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1},
    {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1},
    {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1},
  };
  return h[24];
}

int
main ()
{
  struct A i = foo (), j = i;
  j.b && (f = 0);
  return f;
}
// source: pr82388.c
/* PR tree-optimization/82388 */

struct A { int b; int c; int d; } e;

struct A
foo (void)
{
  struct A h[30] = {{0,0,0}};
  return h[29];
}

int
main ()
{
  e = foo ();
  return e.b;
}
// source: pr82524.c
/* PR target/82524 */

struct S { unsigned char b, g, r, a; };
union U { struct S c; unsigned v; };

static inline unsigned char
foo (unsigned char a, unsigned char b)
{
  return ((a + 1) * b) >> 8;
}

__attribute__((noinline, noclone)) unsigned
bar (union U *x, union U *y)
{
  union U z;
  unsigned char v = x->c.a;
  unsigned char w = foo (y->c.a, 255 - v);
  z.c.r = foo (x->c.r, v) + foo (y->c.r, w);
  z.c.g = foo (x->c.g, v) + foo (y->c.g, w);
  z.c.b = foo (x->c.b, v) + foo (y->c.b, w);
  z.c.a = 0;
  return z.v;
}

int
main ()
{
  union U a, b, c;
  if ((unsigned char) ~0 != 255 || sizeof (unsigned) != 4)
    return 0;
  a.c = (struct S) { 255, 255, 255, 0 };
  b.c = (struct S) { 255, 255, 255, 255 };
  c.v = bar (&a, &b);
  if (c.c.b != 255 || c.c.g != 255 || c.c.r != 255 || c.c.a != 0)
    __builtin_abort ();
  return 0;
}
// source: pr82954.c
/* PR tree-optimization/82954 */

__attribute__((noipa)) void
foo (int *__restrict p, int *__restrict q)
{
  p[0] = p[0] ^ 1;
  p[1] = p[1] ^ 2;
  p[2] = p[2] ^ q[2];
  p[3] = p[3] ^ q[3];
}

int
main ()
{
  int p[4] = { 16, 32, 64, 128 };
  int q[4] = { 8, 4, 2, 1 };
  asm volatile ("" : : "g" (p), "g" (q) : "memory");
  foo (p, q);
  if (p[0] != 17 || p[1] != 34 || p[2] != 66 || p[3] != 129)
    __builtin_abort ();
  return 0;
}
// source: pr83269.c
/* PR tree-optimization/83269 */

int
main ()
{
#if __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ > 4 && __CHAR_BIT__ == 8
  volatile unsigned char a = 1;
  long long b = 0x80000000L;
  int c = -((int)(-b) - (-0x7fffffff * a));
  if (c != 1)
    __builtin_abort ();
#endif
  return 0;
}
// source: pr83298.c

int a, b, c = 1;

int main ()
{
  for (; b < 1; b++)
    ;
  if (!(c * (a < 1)))
    __builtin_abort ();
  return 0;
}
// source: pr83362.c
typedef __UINT8_TYPE__ u8;
typedef __UINT32_TYPE__ u32;

u32 a, b, d, e;
u8 c;

static u32 __attribute__ ((noinline, noclone))
foo (u32 p)
{
  do
    {
      e /= 0xfff;
      if (p > c)
	d = 0;
      e -= 3;
      e *= b <= a;
    }
  while (e >= 88030);
  return e;
}

int
main (void)
{
  u32 x = foo (1164);
  if (x != 0xfd)
    __builtin_abort ();
  return 0;
}
// source: pr83383.c
/* PR tree-optimization/83383 */

unsigned long long int a = 16ULL;
unsigned char b = 195;
unsigned long long int c = ~0ULL;
unsigned char d = 1;
unsigned long long int e[2] = { 3625445792498952486ULL, 0 };
unsigned long long int f[2] = { 0, 8985037393681294663ULL };
unsigned long long int g = 5052410635626804928ULL;

void
foo ()
{
  a = ((signed char) a) < b;
  c = (d ? e[0] : 0) - (f[1] * a ? 1 : g);
}

int
main()
{
  foo ();
  if (a != 1 || c != 3625445792498952485ULL)
    __builtin_abort ();
  return 0;
}
// source: pr83477.c
int yf = 0;

void
pl (int q5, int nd)
{
  unsigned int hp = q5;
  int zx = (q5 == 0) ? hp : (hp / q5);

  yf = ((nd < 2) * zx != 0) ? nd : 0;
}

int
main (void)
{
  pl (1, !yf);
  if (yf != 1)
    __builtin_abort ();

  return 0;
}
// source: pr84169.c
/* PR rtl-optimization/84169 */

#ifdef __SIZEOF_INT128__
typedef unsigned __int128 T;
#else
typedef unsigned long long T;
#endif

T b;

static __attribute__ ((noipa)) T
foo (T c, T d, T e, T f, T g, T h)
{
  __builtin_mul_overflow ((unsigned char) h, -16, &h);
  return b + h;
}

int
main ()
{
  T x = foo (0, 0, 0, 0, 0, 4);
  if (x != -64)
    __builtin_abort ();
  return 0;
}
// source: pr84339.c
/* PR tree-optimization/84339 */

struct S { int a; char b[1]; };

__attribute__((noipa)) int
foo (struct S *p)
{
  return __builtin_strlen (&p->b[0]);
}

__attribute__((noipa)) int
bar (struct S *p)
{
  return __builtin_strlen (p->b);
}

int
main ()
{
  struct S *p = __builtin_malloc (sizeof (struct S) + 16);
  if (p)
    {
      p->a = 1;
      __builtin_strcpy (p->b, "abcdefg");
      if (foo (p) != 7 || bar (p) != 7)
	__builtin_abort ();
      __builtin_free (p);
    }
  return 0;
}
// source: pr84478.c
/* PR tree-optimization/84478 */

long poolptr;
unsigned char *strpool;
static const char *poolfilearr[] = {
  "mu",
  "",
#define A "x",
#define B A "xx", A A "xxx", A A A A A
#define C B B B B B B B B B B
#define D C C C C C C C C C C
  D C C C C C C C B B B
 ((void *)0)
};

__attribute__((noipa)) long
makestring (void)
{
  return 1;
}

__attribute__((noipa)) long
loadpoolstrings (long spare_size)
{
  const char *s;
  long g = 0;
  int i = 0, j = 0;
  while ((s = poolfilearr[j++]))
    {
      int l = __builtin_strlen (s);
      i += l;
      if (i >= spare_size) return 0;
      while (l-- > 0) strpool[poolptr++] = *s++;
      g = makestring ();
    }
  return g;
}

int
main ()
{
  strpool = __builtin_malloc (4000);
  if (!strpool)
    return 0;
  asm volatile ("" : : : "memory");
  volatile int r = loadpoolstrings (4000);
  __builtin_free (strpool);
  return 0;
}
// source: pr84521.c
/* { dg-require-effective-target indirect_jumps } */
/* { dg-additional-options "-fomit-frame-pointer -fno-inline" }  */

extern void abort (void);

void
broken_longjmp (void *p)
{
  __builtin_longjmp (p, 1);
}

volatile int x = 256;
void *volatile p = (void*)&x;
void *volatile p1;

void
test (void)
{
  void *buf[5];
  void *volatile q = p;

  if (!__builtin_setjmp (buf))
    broken_longjmp (buf);

  /* Fails if stack pointer corrupted.  */
  if (p != q)
    abort ();
}

void
test2 (void)
{
  void *volatile q = p;
  p1 = __builtin_alloca (x);
  test ();

  /* Fails if frame pointer corrupted.  */
  if (p != q)
    abort ();
}

int
main (void)
{
  void *volatile q = p;
  test ();
  test2 ();
  /* Fails if stack pointer corrupted.  */
  if (p != q)
    abort ();

  return 0;
}
// source: pr84524.c
/* PR target/84524 */

__attribute__((noipa)) void
foo (unsigned short *x)
{
  unsigned short i, v;
  unsigned char j;
  for (i = 0; i < 256; i++)
    {
      v = i << 8;
      for (j = 0; j < 8; j++)
	if (v & 0x8000)
	  v = (v << 1) ^ 0x1021;
	else
	  v = v << 1;
      x[i] = v;
    }
}

int
main ()
{
  unsigned short a[256];

  foo (a);
  for (int i = 0; i < 256; i++)
    {
      unsigned short v = i << 8;
      for (int j = 0; j < 8; j++)
	{
	  asm volatile ("" : "+r" (v));
	  if (v & 0x8000)
	    v = (v << 1) ^ 0x1021;
	  else
	    v = v << 1;
	}
      if (a[i] != v)
	__builtin_abort ();
    }
  return 0;
}
// source: pr84748.c
/* { dg-require-effective-target int128 } */

typedef unsigned __int128 u128;

int a, c, d;
u128 b;

unsigned long long g0, g1;

void
store (unsigned long long a0, unsigned long long a1)
{
  g0 = a0;
  g1 = a1;
}

void
foo (void)
{
  b += a;
  c = d != 84347;
  b /= c;
  u128 x = b;
  store (x >> 0, x >> 64);
}

int
main (void)
{
  foo ();
  if (g0 != 0 || g1 != 0)
    __builtin_abort ();
  return 0;
}
// source: pr85095.c
/* PR target/85095 */

__attribute__((noipa)) unsigned long
f1 (unsigned long a, unsigned long b)
{
  unsigned long i = __builtin_add_overflow (a, b, &a);
  return a + i;
}

__attribute__((noipa)) unsigned long
f2 (unsigned long a, unsigned long b)
{
  unsigned long i = __builtin_add_overflow (a, b, &a);
  return a - i;
}

__attribute__((noipa)) unsigned long
f3 (unsigned int a, unsigned int b)
{
  unsigned int i = __builtin_add_overflow (a, b, &a);
  return a + i;
}

__attribute__((noipa)) unsigned long
f4 (unsigned int a, unsigned int b)
{
  unsigned int i = __builtin_add_overflow (a, b, &a);
  return a - i;
}

int
main ()
{
  if (f1 (16UL, -18UL) != -2UL
      || f1 (16UL, -17UL) != -1UL
      || f1 (16UL, -16UL) != 1UL
      || f1 (16UL, -15UL) != 2UL
      || f2 (24UL, -26UL) != -2UL
      || f2 (24UL, -25UL) != -1UL
      || f2 (24UL, -24UL) != -1UL
      || f2 (24UL, -23UL) != 0UL
      || f3 (32U, -34U) != -2U
      || f3 (32U, -33U) != -1U
      || f3 (32U, -32U) != 1U
      || f3 (32U, -31U) != 2U
      || f4 (35U, -37U) != -2U
      || f4 (35U, -36U) != -1U
      || f4 (35U, -35U) != -1U
      || f4 (35U, -34U) != 0U)
    __builtin_abort ();
  return 0;
}
// source: pr85156.c
/* PR tree-optimization/85156 */

int x, y;

__attribute__((noipa)) int
foo (int z)
{
  if (__builtin_expect (x ? y != 0 : 0, z++))
    return 7;
  return z;
}

int
main ()
{
  x = 1;
  asm volatile ("" : "+m" (x), "+m" (y));
  if (foo (10) != 11)
    __builtin_abort ();
  return 0;
}
// source: pr85169.c
/* PR target/85169 */

typedef char V __attribute__((vector_size (64)));

static void __attribute__ ((noipa))
foo (V *p)
{
  V v = *p;
  v[63] = 1;
  *p = v;
}

int
main ()
{
  V v = (V) { };
  foo (&v);
  for (unsigned i = 0; i < 64; i++)
    if (v[i] != (i == 63))
      __builtin_abort ();
  return 0;
}
// source: pr85331.c
/* PR tree-optimization/85331 */

typedef double V __attribute__((vector_size (2 * sizeof (double))));
typedef long long W __attribute__((vector_size (2 * sizeof (long long))));

__attribute__((noipa)) void
foo (V *r)
{
  V y = { 1.0, 2.0 };
  W m = { 10000000001LL, 0LL };
  *r = __builtin_shuffle (y, m);
}

int
main ()
{
  V r;
  foo (&r);
  if (r[0] != 2.0 || r[1] != 1.0)
    __builtin_abort ();
  return 0;
}
// source: pr85529-1.c
/* PR tree-optimization/85529 */

struct S { int a; };

int b, c = 1, d, e, f;
static int g;
volatile struct S s;

signed char
foo (signed char i, int j)
{
  return i < 0 ? i : i << j;
}

int
main ()
{
  signed char k = -83;
  if (!d)
    goto L;
  k = e || f;
L:
  for (; b < 1; b++)
    s.a != (k < foo (k, 2) && (c = k = g));
  if (c != 1)
    __builtin_abort ();
  return 0;
}
// source: pr85529-2.c
/* PR tree-optimization/85529 */

__attribute__((noipa)) int
foo (int x)
{
  x &= 63;
  x -= 50;
  x |= 1;
  if (x < 0)
    return 1;
  int y = x >> 2;
  if (x >= y)
    return 1;
  return 0;
}

int
main ()
{
  int i;
  for (i = 0; i < 63; i++)
    if (foo (i) != 1)
      __builtin_abort ();
  return 0;
}
// source: pr85582-1.c
/* PR target/85582 */

int a, b, d = 2, e;
long long c = 1;

int
main ()
{
  int g = 6;
L1:
  e = d;
  if (a)
    goto L1;
  g--;
  int i = c >> ~(~e | ~g);
L2:
  c = (b % c) * i;
  if (!e)
    goto L2;
  return 0;
}
// source: pr85582-2.c
/* PR target/85582 */

#ifdef __SIZEOF_INT128__
typedef __int128 S;
typedef unsigned __int128 U;
#else
typedef long long S;
typedef unsigned long long U;
#endif

__attribute__((noipa)) S
f1 (S x, int y)
{
  x = x << (y & 5);
  x += y;
  return x;
}

__attribute__((noipa)) S
f2 (S x, int y)
{
  x = x >> (y & 5);
  x += y;
  return x;
}

__attribute__((noipa)) U
f3 (U x, int y)
{
  x = x >> (y & 5);
  x += y;
  return x;
}

int
main ()
{
  S a = (S) 1 << (sizeof (S) * __CHAR_BIT__ - 7);
  S b = f1 (a, 12);
  if (b != ((S) 1 << (sizeof (S) * __CHAR_BIT__ - 3)) + 12)
    __builtin_abort ();
  S c = (U) 1 << (sizeof (S) * __CHAR_BIT__ - 1);
  S d = f2 (c, 12);
  if ((U) d != ((U) 0x1f << (sizeof (S) * __CHAR_BIT__ - 5)) + 12)
    __builtin_abort ();
  U e = (U) 1 << (sizeof (U) * __CHAR_BIT__ - 1);
  U f = f3 (c, 12);
  if (f != ((U) 1 << (sizeof (U) * __CHAR_BIT__ - 5)) + 12)
    __builtin_abort ();
  return 0;
}
// source: pr85582-3.c
/* PR target/85582 */

#ifdef __SIZEOF_INT128__
typedef __int128 S;
typedef unsigned __int128 U;
#else
typedef long long S;
typedef unsigned long long U;
#endif

__attribute__((noipa)) U
f1 (U x, int y)
{
  return x << (y & -2);
}

__attribute__((noipa)) S
f2 (S x, int y)
{
  return x >> (y & -2);
}

__attribute__((noipa)) U
f3 (U x, int y)
{
  return x >> (y & -2);
}

int
main ()
{
  U a = (U) 1 << (sizeof (U) * __CHAR_BIT__ - 7);
  if (f1 (a, 5) != ((U) 1 << (sizeof (S) * __CHAR_BIT__ - 3)))
    __builtin_abort ();
  S b = (U) 0x101 << (sizeof (S) * __CHAR_BIT__ / 2 - 7);
  if (f1 (b, sizeof (S) * __CHAR_BIT__ / 2) != (U) 0x101 << (sizeof (S) * __CHAR_BIT__ - 7))
    __builtin_abort ();
  if (f1 (b, sizeof (S) * __CHAR_BIT__ / 2 + 2) != (U) 0x101 << (sizeof (S) * __CHAR_BIT__ - 5))
    __builtin_abort ();
  S c = (U) 1 << (sizeof (S) * __CHAR_BIT__ - 1);
  if ((U) f2 (c, 5) != ((U) 0x1f << (sizeof (S) * __CHAR_BIT__ - 5)))
    __builtin_abort ();
  if ((U) f2 (c, sizeof (S) * __CHAR_BIT__ / 2) != ((U) -1 << (sizeof (S) * __CHAR_BIT__ / 2 - 1)))
    __builtin_abort ();
  if ((U) f2 (c, sizeof (S) * __CHAR_BIT__ / 2 + 2) != ((U) -1 << (sizeof (S) * __CHAR_BIT__ / 2 - 3)))
    __builtin_abort ();
  U d = (U) 1 << (sizeof (S) * __CHAR_BIT__ - 1);
  if (f3 (c, 5) != ((U) 0x1 << (sizeof (S) * __CHAR_BIT__ - 5)))
    __builtin_abort ();
  if (f3 (c, sizeof (S) * __CHAR_BIT__ / 2) != ((U) 1 << (sizeof (S) * __CHAR_BIT__ / 2 - 1)))
    __builtin_abort ();
  if (f3 (c, sizeof (S) * __CHAR_BIT__ / 2 + 2) != ((U) 1 << (sizeof (S) * __CHAR_BIT__ / 2 - 3)))
    __builtin_abort ();
  return 0;
}
// source: pr85756.c
/* PR target/85756 */

#if __CHAR_BIT__ == 8 && __SIZEOF_SHORT__ == 2 && __SIZEOF_INT__ == 4
int a, c, *e, f, h = 10;
short b;
unsigned int p;

__attribute__((noipa)) void
bar (int a)
{
  asm volatile ("" : : "r" (a) : "memory");
}

void
foo ()
{
  unsigned j = 1, m = 430523;
  int k, n = 1, *l = &h;
lab:
  p = m;
  m = -((~65535U | j) - n);
  f = b << ~(n - 8);
  n = (m || b) ^ f;
  j = p;
  if (p < m)
    *l = k < 3;
  if (!n)
    l = &k;
  if (c)
    {
      bar (a);
      goto lab;
    }
  if (!*l)
    *e = 1;
}

int
main ()
{
  foo ();
  return 0;
}
#else
int
main ()
{
  return 0;
}
#endif
// source: pr86231.c
/* PR tree-optimization/86231 */

#define ONE ((void *) 1)
#define TWO ((void *) 2)

__attribute__((noipa)) int
foo (void *p, int x)
{
  if (p == ONE) return 0;
  if (!p)
    p = x ? TWO : ONE;
  return p == ONE ? 0 : 1;
}

int v[8];

int
main ()
{
  if (foo ((void *) 0, 0) != 0
      || foo ((void *) 0, 1) != 1
      || foo (ONE, 0) != 0
      || foo (ONE, 1) != 0
      || foo (TWO, 0) != 1
      || foo (TWO, 1) != 1
      || foo (&v[7], 0) != 1
      || foo (&v[7], 1) != 1)
    __builtin_abort ();
  return 0;
}
// source: pr86492.c
/* PR tree-optimization/86492 */

union U
{
  unsigned int r;
  struct S
  {
    unsigned int a:12;
    unsigned int b:4;
    unsigned int c:16;
  } f;
};

__attribute__((noipa)) unsigned int
foo (unsigned int x)
{
  union U u;
  u.r = 0;
  u.f.c = x;
  u.f.b = 0xe;
  return u.r;
}

int
main ()
{
  union U u;
  if (__CHAR_BIT__ * __SIZEOF_INT__ != 32 || sizeof (u.r) != sizeof (u.f))
    return 0;
  u.r = foo (0x72);
  if (u.f.a != 0 || u.f.b != 0xe || u.f.c != 0x72)
    __builtin_abort ();
  return 0;
}
// source: pr86528.c
// { dg-require-effective-target alloca }
/* PR middle-end/86528 */

void __attribute__((noinline, noclone))
test(char *data, __SIZE_TYPE__ len)
{
    static char const appended[] = "/./";
    char *buf = __builtin_alloca (len + sizeof appended);
    __builtin_memcpy (buf, data, len);
    __builtin_strcpy (buf + len, &appended[data[len - 1] == '/']);
    if (__builtin_strcmp(buf, "test1234/./"))
        __builtin_abort();
}

int
main()
{
   char *arg = "test1234/";
   test(arg, __builtin_strlen(arg));
   return 0;
}
// source: pr86714.c
/* PR tree-optimization/86714 - tree-ssa-forwprop.c confused by too
   long initializer

   The excessively long initializer for a[0] is undefined but this
   test verifies that the excess elements are not considered a part
   of the value of the array as a matter of QoI.  */

const char a[2][3] = { "1234", "xyz" };
char b[6];

void *pb = b;

int main ()
{
   __builtin_memcpy (b, a, 4);
   __builtin_memset (b + 4, 'a', 2);

   if (b[0] != '1' || b[1] != '2' || b[2] != '3'
       || b[3] != 'x' || b[4] != 'a' || b[5] != 'a')
     __builtin_abort ();

   if (__builtin_memcmp (pb, "123xaa", 6))
     __builtin_abort ();

   return 0;
}
// source: pr86844.c
/* PR tree-optimization/86844 */

__attribute__((noipa)) void
foo (int *p)
{
  *p = 0;
  *((char *)p + 3) = 1;
  *((char *)p + 1) = 2;
  *((char *)p + 2) = *((char *)p + 6);
}

int
main ()
{
  int a[2] = { -1, 0 };
  if (sizeof (int) != 4)
    return 0;
  ((char *)a)[6] = 3;
  foo (a);
  if (((char *)a)[0] != 0 || ((char *)a)[1] != 2
      || ((char *)a)[2] != 3 || ((char *)a)[3] != 1)
    __builtin_abort ();
  return 0;
}
// source: pr87053.c
/* PR middle-end/87053 */

const union
{ struct {
    char x[4];
    char y[4];
  };
  struct {
    char z[8];
  };
} u = {{"1234", "567"}};

int main ()
{
  if (__builtin_strlen (u.z) != 7)
    __builtin_abort ();
}
// source: pr87290.c
/* PR middle-end/87290 */

int c;

__attribute__((noipa)) void
f0 (void)
{
  c++;
}

__attribute__((noipa)) int
f1 (int x)
{
  return x % 16 == 13;
}

__attribute__((noipa)) int
f2 (int x)
{
  return x % 16 == -13;
}

__attribute__((noipa)) void
f3 (int x)
{
  if (x % 16 == 13)
    f0 ();
}

__attribute__((noipa)) void
f4 (int x)
{
  if (x % 16 == -13)
    f0 ();
}

int
main ()
{
  int i, j;
  for (i = -30; i < 30; i++)
    {
      if (f1 (13 + i * 16) != (i >= 0) || f2 (-13 + i * 16) != (i <= 0))
	__builtin_abort ();
      f3 (13 + i * 16);
      if (c != (i >= 0))
	__builtin_abort ();
      f4 (-13 + i * 16);
      if (c != 1 + (i == 0))
	__builtin_abort ();
      for (j = 1; j < 16; j++)
	{
	  if (f1 (13 + i * 16 + j) || f2 (-13 + i * 16 + j))
	    __builtin_abort ();
	  f3 (13 + i * 16 + j);
	  f4 (-13 + i * 16 + j);
	}
      if (c != 1 + (i == 0))
	__builtin_abort ();
      c = 0;
    }
  return 0;
}
// source: pr87623.c
/* PR middle-end/87623 */
/* Testcase by George Thopas <george.thopas@gmail.com> */

struct be {
    unsigned short pad[1];
    unsigned char  a;
    unsigned char  b;
} __attribute__((scalar_storage_order("big-endian")));

typedef struct be t_be;

struct le {
    unsigned short pad[3];
    unsigned char  a;
    unsigned char  b;
};

typedef struct le t_le;

int a_or_b_different(t_be *x,t_le *y)
{
   return (x->a != y->a) || (x->b != y->b);
}

int main (void)
{
   t_be x = { .a=1, .b=2  };
   t_le y = { .a=1, .b=2  };

   if (a_or_b_different(&x,&y))
       __builtin_abort ();

   return 0;
}
// source: pr88693.c
/* PR tree-optimization/88693 */

__attribute__((noipa)) void
foo (char *p)
{
  if (__builtin_strlen (p) != 9)
    __builtin_abort ();
}

__attribute__((noipa)) void
quux (char *p)
{
  int i;
  for (i = 0; i < 100; i++)
    if (p[i] != 'x')
      __builtin_abort ();
}

__attribute__((noipa)) void
qux (void)
{
  char b[100];
  __builtin_memset (b, 'x', sizeof (b));
  quux (b);
}

__attribute__((noipa)) void
bar (void)
{
  static unsigned char u[9] = "abcdefghi";
  char b[100];
  __builtin_memcpy (b, u, sizeof (u));
  b[sizeof (u)] = 0;
  foo (b);
}

__attribute__((noipa)) void
baz (void)
{
  static unsigned char u[] = { 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r' };
  char b[100];
  __builtin_memcpy (b, u, sizeof (u));
  b[sizeof (u)] = 0;
  foo (b);
}

int
main ()
{
  qux ();
  bar ();
  baz ();
  return 0;
}
// source: pr88714.c
/* PR bootstrap/88714 */

struct S { int a, b, c; int *d; };
struct T { int *e, *f, *g; } *t = 0;
int *o = 0;

__attribute__((noipa))
void bar (int *x, int y, int z, int w)
{
  if (w == -1)
    {
      if (x != 0 || y != 0 || z != 0)
	__builtin_abort ();
    }
  else if (w != 0 || x != t->g || y != 0 || z != 12)
    __builtin_abort ();
}

__attribute__((noipa)) void
foo (struct S *x, struct S *y, int *z, int w)
{
  *o = w;
  if (w)
    bar (0, 0, 0, -1);
  x->d = z;
  if (y->d)
    y->c = y->c + y->d[0];
  bar (t->g, 0, y->c, 0);
}

int
main ()
{
  int a[4] = { 8, 9, 10, 11 };
  struct S s = { 1, 2, 3, &a[0] };
  struct T u = { 0, 0, &a[3] };
  o = &a[2];
  t = &u;
  foo (&s, &s, &a[1], 5);
  if (s.c != 12 || s.d != &a[1])
    __builtin_abort ();
  return 0;
}
// source: pr88739.c
/* PR tree-optimization/88739 */
#if __SIZEOF_SHORT__ == 2 &&  __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
struct A
{
  unsigned int a, b, c;
  unsigned int d : 30;
  unsigned int e : 2;
};

union U
{
  struct A f;
  unsigned int g[4];
  unsigned short h[8];
  unsigned char i[16];
};
volatile union U v = { .f.d = 0x4089 };

__attribute__((noipa)) void
bar (int x)
{
  static int i;
  switch (i++)
    {
    case 0: if (x != v.f.d) __builtin_abort (); break;
    case 1: if (x != v.f.e) __builtin_abort (); break;
    case 2: if (x != v.g[3]) __builtin_abort (); break;
    case 3: if (x != v.h[6]) __builtin_abort (); break;
    case 4: if (x != v.h[7]) __builtin_abort (); break;
    default: __builtin_abort (); break;
    }
}

void
foo (unsigned int x)
{
  union U u;
  u.f.d = x >> 2;
  u.f.e = 0;
  bar (u.f.d);
  bar (u.f.e);
  bar (u.g[3]);
  bar (u.h[6]);
  bar (u.h[7]);
}

int
main ()
{
  foo (0x10224);
  return 0;
}
#else
int
main ()
{
  return 0;
}
#endif
// source: pr88904.c
/* PR rtl-optimization/88904 */

volatile int v;

__attribute__((noipa)) void
bar (const char *x, const char *y, int z)
{
  if (!v)
    __builtin_abort ();
  asm volatile ("" : "+g" (x));
  asm volatile ("" : "+g" (y));
  asm volatile ("" : "+g" (z));
}

#define my_assert(e) ((e) ? (void) 0 : bar (#e, __FILE__, __LINE__))

typedef struct {
  unsigned M1;
  unsigned M2 : 1;
  int : 0;
  unsigned M3 : 1;
} S;

S
foo ()
{
  S result = {0, 0, 1};
  return result;
}

int
main ()
{
  S ret = foo ();
  my_assert (ret.M2 == 0);
  my_assert (ret.M3 == 1);
  return 0;
}
// source: pr89195.c
/* PR rtl-optimization/89195 */
/* { dg-require-effective-target int32plus } */

struct S { unsigned i : 24; };

volatile unsigned char x;

__attribute__((noipa)) int
foo (struct S d)
{
  return d.i & x;
}

int
main ()
{
  struct S d = { 0x123456 };
  x = 0x75;
  if (foo (d) != (0x56 & 0x75))
    __builtin_abort ();
  return 0;
}
// source: pr89369.c
/* PR target/89369 */

#if __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8 && __CHAR_BIT__ == 8
struct S { unsigned int u[4]; };

static void
foo (struct S *out, struct S const *in, int shift)
{
  unsigned long long th, tl, oh, ol;
  th = ((unsigned long long) in->u[3] << 32) | in->u[2];
  tl = ((unsigned long long) in->u[1] << 32) | in->u[0];
  oh = th >> (shift * 8);
  ol = tl >> (shift * 8);
  ol |= th << (64 - shift * 8);
  out->u[1] = ol >> 32;
  out->u[0] = ol;
  out->u[3] = oh >> 32;
  out->u[2] = oh;
}

static void
bar (struct S *out, struct S const *in, int shift)
{
  unsigned long long th, tl, oh, ol;
  th = ((unsigned long long) in->u[3] << 32) | in->u[2];
  tl = ((unsigned long long) in->u[1] << 32) | in->u[0];
  oh = th << (shift * 8);
  ol = tl << (shift * 8);
  oh |= tl >> (64 - shift * 8);
  out->u[1] = ol >> 32;
  out->u[0] = ol;
  out->u[3] = oh >> 32;
  out->u[2] = oh;
}

__attribute__((noipa)) static void
baz (struct S *r, struct S *a, struct S *b, struct S *c, struct S *d)
{
  struct S x, y;
  bar (&x, a, 1);
  foo (&y, c, 1);
  r->u[0] = a->u[0] ^ x.u[0] ^ ((b->u[0] >> 11) & 0xdfffffefU) ^ y.u[0] ^ (d->u[0] << 18);
  r->u[1] = a->u[1] ^ x.u[1] ^ ((b->u[1] >> 11) & 0xddfecb7fU) ^ y.u[1] ^ (d->u[1] << 18);
  r->u[2] = a->u[2] ^ x.u[2] ^ ((b->u[2] >> 11) & 0xbffaffffU) ^ y.u[2] ^ (d->u[2] << 18);
  r->u[3] = a->u[3] ^ x.u[3] ^ ((b->u[3] >> 11) & 0xbffffff6U) ^ y.u[3] ^ (d->u[3] << 18);
}

int
main ()
{
  struct S a[] = { { 0x000004d3, 0xbc5448db, 0xf22bde9f, 0xebb44f8f },
		   { 0x03a32799, 0x60be8246, 0xa2d266ed, 0x7aa18536 },
		   { 0x15a38518, 0xcf655ce1, 0xf3e09994, 0x50ef69fe },
		   { 0x88274b07, 0xe7c94866, 0xc0ea9f47, 0xb6a83c43 },
		   { 0xcd0d0032, 0x5d47f5d7, 0x5a0afbf6, 0xaea87b24 },
		   { 0, 0, 0, 0 } };
  baz (&a[5], &a[0], &a[1], &a[2], &a[3]);
  if (a[4].u[0] != a[5].u[0] || a[4].u[1] != a[5].u[1]
      || a[4].u[2] != a[5].u[2] || a[4].u[3] != a[5].u[3])
    __builtin_abort ();
  return 0;
}
#else
int
main ()
{
  return 0;
}
#endif
// source: pr89434.c
/* PR target/89434 */

#if __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8 && __CHAR_BIT__ == 8
long g = 0;

static inline unsigned long long
foo (unsigned long long u)
{
  unsigned x;
  __builtin_mul_overflow (-1, g, &x);
  u |= (unsigned) u < (unsigned short) x;
  return x - u;
}

int
main ()
{
  unsigned long long x = foo (0x222222222ULL);
  if (x != 0xfffffffddddddddeULL)
    __builtin_abort ();
  return 0;
}
#else
int
main ()
{
  return 0;
}
#endif
// source: pr89634.c
/* PR rtl-optimization/89634 */

static unsigned long *
foo (unsigned long *x)
{
  return x + (1 + *x);
}

__attribute__((noipa)) unsigned long
bar (unsigned long *x)
{
  unsigned long c, d = 1, e, *f, g, h = 0, i;
  for (e = *x - 1; e > 0; e--)
    {
      f = foo (x + 1);
      for (i = 1; i < e; i++)
	f = foo (f);
      c = *f;
      if (c == 2)
	d *= 2;
      else
	{
	  i = (c - 1) / 2 - 1;
	  g = (2 * i + 1) * (d + 1) + (2 * d + 1);
	  if (g > h)
	    h = g;
	  d *= c;
	}
    }
  return h;
}

int
main ()
{
  unsigned long a[18] = { 4, 2, -200, 200, 2, -400, 400, 3, -600, 0, 600, 5, -100, -66, 0, 66, 100, __LONG_MAX__ / 8 + 1 };
  if (bar (a) != 17)
    __builtin_abort ();
  return 0;
}
// source: pr89826.c
typedef unsigned int u32;
typedef unsigned long long u64;
u64 a;
u32 b;

u64
foo (u32 d)
{
  a -= d ? 0 : ~a;
  return a + b;
}

int
main (void)
{
  u64 x = foo (2);
  if (x != 0)
    __builtin_abort();
  return 0;
}
// source: pr90025.c
/* PR middle-end/90025 */

__attribute__((noipa)) void
bar (char *p)
{
  int i;
  for (i = 0; i < 6; i++)
    if (p[i] != "foobar"[i])
      __builtin_abort ();
  for (; i < 32; i++)
    if (p[i] != '\0')
      __builtin_abort ();
}

__attribute__((noipa)) void
foo (unsigned int x)
{
  char s[32] = { 'f', 'o', 'o', 'b', 'a', 'r', 0 };
  ((unsigned int *) s)[2] = __builtin_bswap32 (x);
  bar (s);
}

int
main ()
{
  foo (0);
  return 0;
}
// source: pr90949.c
void __attribute__ ((noipa, noinline)) my_puts (const char *str) { }

void __attribute__ ((noipa, noinline)) my_free (void *p) { }


struct Node
{
  struct Node *child;
};

struct Node space[2] = { };

struct Node * __attribute__ ((noipa, noinline)) my_malloc (int bytes)
{
  return &space[0];
}

void
walk (struct Node *module, int cleanup)
{
  if (module == 0)
    {
      return;
    }
  if (!cleanup)
    {
      my_puts ("No cleanup");
    }
  walk (module->child, cleanup);
  if (cleanup)
    {
      my_free (module);
    }
}

int
main ()
{
  struct Node *node = my_malloc (sizeof (struct Node));
  node->child = 0;
  walk (node, 1);
}
// source: pr91137.c
long long a;
unsigned b;
int c[70];
int d[70][70];
int e;

__attribute__ ((noinline)) void f(long long *g, int p2) {
  *g = p2;
}

__attribute__ ((noinline)) void fn2() {
  for (int j = 0; j < 70; j++) {
    for (int i = 0; i < 70; i++) {
      if (b)
        c[i] = 0;
      for (int l = 0; l < 70; l++)
        d[i][1] = d[l][i];
    }
    for (int k = 0; k < 70; k++)
      e = c[0];
  }
}

int main() {
  b = 5;
  for (int j = 0; j < 70; ++j)
    c[j] = 2075593088;
  fn2();
  f(&a, e);
  if (a)
    __builtin_abort();
  return 0;
}
// source: printf-1.c
/* { dg-skip-if "requires io" { freestanding } }  */

#include <stdio.h>
#include <stdlib.h>

int
main (void)
{
#define test(ret, args...) \
  printf (args); 		\
  if (printf (args) != ret)	\
    abort ();
  test (5, "hello");
  test (6, "hello\n");
  test (1, "a");
  test (0, "");
  test (5, "%s", "hello");
  test (6, "%s", "hello\n");
  test (1, "%s", "a");
  test (0, "%s", "");
  test (1, "%c", 'x');
  test (7, "%s\n", "hello\n");
  test (2, "%d\n", 0);
  return 0;
}
// source: printf-2.c
/* Verify that calls to printf don't get eliminated even if their
   result on success can be computed at compile time (they can fail).
   The calls can still be transformed into those of other functions.
   { dg-require-effective-target unwrapped }
   { dg-skip-if "requires io" { freestanding } } */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

__attribute__ ((noipa)) void
write_file (void)
{
  printf ("1");
  printf ("%c", '2');
  printf ("%c%c", '3', '4');
  printf ("%s", "5");
  printf ("%s%s", "6", "7");
  printf ("%i", 8);
  printf ("%.1s\n", "9x");
}


int main (void)
{
  char *tmpfname = tmpnam (0);
  FILE *f = freopen (tmpfname, "w", stdout);
  if (!f)
    {
      perror ("fopen for writing");
      return 1;
    }

  write_file ();
  fclose (f);

  f = fopen (tmpfname, "r");
  if (!f)
    {
      perror ("fopen for reading");
      remove (tmpfname);
      return 1;
    }

  char buf[12] = "";
  if (1 != fscanf (f, "%s", buf))
    {
      perror ("fscanf");
      fclose (f);
      remove (tmpfname);
      return 1;
    }

  fclose (f);
  remove (tmpfname);

  if (strcmp (buf, "123456789"))
    abort ();

  return 0;
}
// source: printf-chk-1.c
/* { dg-skip-if "requires io" { freestanding } }  */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

volatile int should_optimize;

int
__attribute__((noinline))
__printf_chk (int flag, const char *fmt, ...)
{
  va_list ap;
  int ret;
#ifdef __OPTIMIZE__
  if (should_optimize)
    abort ();
#endif
  should_optimize = 1;
  va_start (ap, fmt);
  ret = vprintf (fmt, ap);
  va_end (ap);
  return ret;
}

int
main (void)
{
#define test(ret, opt, args...) \
  should_optimize = opt;		\
  __printf_chk (1, args); 		\
  if (!should_optimize)			\
    abort ();				\
  should_optimize = 0;			\
  if (__printf_chk (1, args) != ret)	\
    abort ();				\
  if (!should_optimize)			\
    abort ();
  test (5, 0, "hello");
  test (6, 1, "hello\n");
  test (1, 1, "a");
  test (0, 1, "");
  test (5, 0, "%s", "hello");
  test (6, 1, "%s", "hello\n");
  test (1, 1, "%s", "a");
  test (0, 1, "%s", "");
  test (1, 1, "%c", 'x');
  test (7, 1, "%s\n", "hello\n");
  test (2, 0, "%d\n", 0);
  return 0;
}
// source: pta-field-1.c
struct Foo {
  int *p;
  int *q;
};

void __attribute__((noinline))
bar (int **x)
{
  struct Foo *f = (struct Foo *)x;
  *(f->q) = 0;
}

int foo(void)
{
  struct Foo f;
  int i = 1, j = 2;
  f.p = &i;
  f.q = &j;
  bar(&f.p);
  return j;
}

extern void abort (void);
int main()
{
  if (foo () != 0)
    abort ();
  return 0;
}
// source: pta-field-2.c
struct Foo {
  int *p;
  int *q;
};

void __attribute__((noinline))
bar (int **x)
{
  struct Foo *f = (struct Foo *)(x - 1);
  *(f->p) = 0;
}

int foo(void)
{
  struct Foo f;
  int i = 1, j = 2;
  f.p = &i;
  f.q = &j;
  bar(&f.q);
  return i;
}

extern void abort (void);
int main()
{
  if (foo () != 0)
    abort ();
  return 0;
}
// source: ptr-arith-1.c
char *
f (char *s, unsigned int i)
{
  return &s[i + 3 - 1];
}

main ()
{
  char *str = "abcdefghijkl";
  char *x2 = f (str, 12);
  if (str + 14 != x2)
    abort ();
  exit (0);
}
// source: pure-1.c

/* Origin: Kaveh Ghazi <ghazi@caip.rutgers.edu> 2002-05-27.  */

/* Use a different function for each test so the link failures
   indicate which one is broken.  */
extern void link_error0 (void);
extern void link_error1 (void);
extern void link_error2 (void);
extern void link_error3 (void);
extern void link_error4 (void);
extern void link_error5 (void);
extern void link_error6 (void);
extern void link_error7 (void);

extern int i;

extern int func0 (int) __attribute__ ((__pure__));
extern int func1 (int) __attribute__ ((__const__));

/* GCC should automatically detect attributes for these functions.
   At -O3 They'll be inlined, but that's ok.  */
static int func2 (int a) { return i + a; } /* pure */
static int func3 (int a) { return a * 3; } /* const */
static int func4 (int a) { return func0(a) + a; } /* pure */
static int func5 (int a) { return a + func1(a); } /* const */
static int func6 (int a) { return func2(a) + a; } /* pure */
static int func7 (int a) { return a + func3(a); } /* const */

int main ()
{
  int i[10], r;

  i[0] = 0;
  r = func0(0);
  if (i[0])
    link_error0();

  i[1] = 0;
  r = func1(0);
  if (i[1])
    link_error1();

  i[2] = 0;
  r = func2(0);
  if (i[2])
    link_error2();

  i[3] = 0;
  r = func3(0);
  if (i[3])
    link_error3();

  i[4] = 0;
  r = func4(0);
  if (i[4])
    link_error4();

  i[5] = 0;
  r = func5(0);
  if (i[5])
    link_error5();

  i[6] = 0;
  r = func6(0);
  if (i[6])
    link_error6();

  i[7] = 0;
  r = func7(0);
  if (i[7])
    link_error7();

  return r;
}

int func0 (int a) { return a - i; } /* pure */
int func1 (int a) { return a - a; } /* const */

int i = 2;

#ifndef __OPTIMIZE__
/* Avoid link failures when not optimizing. */
void link_error0() {}
void link_error1() {}
void link_error2() {}
void link_error3() {}
void link_error4() {}
void link_error5() {}
void link_error6() {}
void link_error7() {}
#endif /* ! __OPTIMIZE__ */
// source: pushpop_macro.c
extern void abort ();

#define _ 2
#pragma push_macro("_")
#undef _
#define _ 1
#pragma pop_macro("_")

int main ()
{
  if (_ != 2)
    abort ();
  return 0;
}
// source: regstack-1.c
long double C = 5;
long double U = 1;
long double Y2 = 11;
long double Y1 = 17;
long double X, Y, Z, T, R, S;
main ()
{
  X = (C + U) * Y2;
  Y = C - U - U;
  Z = C + U + U;
  T = (C - U) * Y1;
  X = X - (Z + U);
  R = Y * Y1;
  S = Z * Y2;
  T = T - Y;
  Y = (U - Y) + R;
  Z = S - (Z + U + U);
  R = (Y2 + U) * Y1;
  Y1 = Y2 * Y1;
  R = R - Y2;
  Y1 = Y1 - 0.5L;
  if (Z != 68. || Y != 49. || X != 58. || Y1 != 186.5 || R != 193. || S != 77.
      || T != 65. || Y2 != 11.)
    abort ();
  exit (0);
}
// source: restrict-1.c
/*  PR rtl-optimization/16536
    Origin:  Jeremy Denise      <jeremy.denise@libertysurf.fr>
    Reduced: Wolfgang Bangerth  <bangerth@dealii.org>
             Volker Reichelt    <reichelt@igpm.rwth-aachen.de>  */
/* { dg-options "-fgnu89-inline" } */

extern void abort ();

typedef struct
{
  int i, dummy;
} A;

inline A foo (const A* p, const A* q)
{
  return (A){p->i+q->i};
}

void bar (A* __restrict__ p)
{
  *p=foo(p,p);
  if (p->i!=2)
    abort();
}

int main ()
{
  A a={1};
  bar(&a);
  return 0;
}
// source: return-addr.c
/* Test to verify that a function that returns either the address
   of a local variable or a non-local via a MAX_EXPR or MIN_EXPR
   doesn't return null when the result of the expression is
   the latter.  */

#define NOIPA __attribute__ ((noclone, noinline, noipa))

#define A(expr)                                                 \
  ((expr)                                                       \
   ? (void)0                                                    \
   : (__builtin_printf ("assertion failed on line %i: %s\n",    \
                        __LINE__, #expr),                       \
      __builtin_abort ()))


typedef __UINTPTR_TYPE__ uintptr_t;

/* Return a bigger value than P.  The address still points (just
   past) the local variable pointed to by P so the caller does
   return the address of a local variable but that's hidden from
   GCC by the attribute and the point of the test is to verify
   that the address in the return statement in the caller isn't
   replaced by null when GCC cannot prove the address doesn't
   reference a non-local variable.  */

NOIPA char* get_max_2 (char *p)
{
  return p + 1;
}

NOIPA char* get_max_3 (char *p, char *q)
{
  return p < q ? q + 1 : p + 1;
}

/* Analogous to the above.  The expressions are undefined because
   they form an address prior to the beginning of the object but
   it's hidden from GCC by the attributes.  */

NOIPA char* get_min_2 (char *p)
{
  return p - 1;
}

NOIPA char* get_min_3 (char *p, char *q)
{
  return p < q ? p - 1 : q - 1;
}


NOIPA void* test_max_2 (void)
{
  char c;

  char *p = get_max_2 (&c);

  void *q = p > &c ? p : &c;  /* MAX_EXPR */
  return q;
}

NOIPA void* test_max_3 (void)
{
  char c;
  char d;

  char *p = get_max_3 (&c, &d);

  void *q = p < &c ? &c < &d ? &d : &c : p;
  return q;
}

NOIPA void* test_min_2 (void)
{
  char c;

  char *p = get_min_2 (&c);

  void *q = p < &c ? p : &c;  /* MIN_EXPR" */
  return q;
}

NOIPA void* test_min_3 (void)
{
  char c;
  char d;

  char *p = get_min_3 (&c, &d);

  void *q = p > &c ? &c > &d ? &d : &c : p;
  return q;
}

NOIPA void* test_min_3_phi (int i)
{
  char a, b;

  char *p0 = &a;
  char *p1 = &b;
  char *p2 = get_min_3 (&a, &b);
  char *p3 = get_min_3 (&a, &b);

  char *p4 = p2 < p0 ? p2 : p0;
  char *p5 = p3 < p1 ? p3 : p1;

  __builtin_printf ("%p %p %p %p\n", p2, p3, p4, p5);

  if (i == 1)
    return p4;
  else
    return p5;
}

int main ()
{
  A (0 != test_max_2 ());
  A (0 != test_max_3 ());

  A (0 != test_min_2 ());
  A (0 != test_min_3 ());

  A (0 != test_min_3_phi (0));
}
// source: scal-to-vec1.c
#define vector(elcount, type)  \
__attribute__((vector_size((elcount)*sizeof(type)))) type

#define vidx(type, vec, idx) (*((type *) &(vec) + idx))

#define operl(a, b, op) (a op b)
#define operr(a, b, op) (b op a)

#define check(type, count, vec0, vec1, num, op, lr) \
do {\
    int __i; \
    for (__i = 0; __i < count; __i++) {\
        if (vidx (type, vec1, __i) != oper##lr (num, vidx (type, vec0, __i), op)) \
            __builtin_abort (); \
    }\
} while (0)

#define veccompare(type, count, v0, v1) \
do {\
    int __i; \
    for (__i = 0; __i < count; __i++) { \
        if (vidx (type, v0, __i) != vidx (type, v1, __i)) \
            __builtin_abort (); \
    } \
} while (0)

volatile int one = 1;

int main (int argc, char *argv[]) {
#define fvec_2 (vector(4, float)){2., 2., 2., 2.}
#define dvec_2 (vector(2, double)){2., 2.}


    vector(8, short) v0 = {one, 1, 2, 3, 4, 5, 6, 7};
    vector(8, short) v1;

    vector(4, float) f0 = {1., 2., 3., 4.};
    vector(4, float) f1, f2;

    vector(2, double) d0 = {1., 2.};
    vector(2, double) d1, d2;



    v1 = 2 + v0;   check (short, 8, v0, v1, 2, +, l);
    v1 = 2 - v0;   check (short, 8, v0, v1, 2, -, l);
    v1 = 2 * v0;   check (short, 8, v0, v1, 2, *, l);
    v1 = 2 / v0;   check (short, 8, v0, v1, 2, /, l);
    v1 = 2 % v0;   check (short, 8, v0, v1, 2, %, l);
    v1 = 2 ^ v0;   check (short, 8, v0, v1, 2, ^, l);
    v1 = 2 & v0;   check (short, 8, v0, v1, 2, &, l);
    v1 = 2 | v0;   check (short, 8, v0, v1, 2, |, l);
    v1 = 2 << v0;   check (short, 8, v0, v1, 2, <<, l);
    v1 = 2 >> v0;   check (short, 8, v0, v1, 2, >>, l);

    v1 = v0 + 2;   check (short, 8, v0, v1, 2, +, r);
    v1 = v0 - 2;   check (short, 8, v0, v1, 2, -, r);
    v1 = v0 * 2;   check (short, 8, v0, v1, 2, *, r);
    v1 = v0 / 2;   check (short, 8, v0, v1, 2, /, r);
    v1 = v0 % 2;   check (short, 8, v0, v1, 2, %, r);
    v1 = v0 ^ 2;   check (short, 8, v0, v1, 2, ^, r);
    v1 = v0 & 2;   check (short, 8, v0, v1, 2, &, r);
    v1 = v0 | 2;   check (short, 8, v0, v1, 2, |, r);

    f1 = 2. + f0;  f2 = fvec_2 + f0; veccompare (float, 4, f1, f2);
    f1 = 2. - f0;  f2 = fvec_2 - f0; veccompare (float, 4, f1, f2);
    f1 = 2. * f0;  f2 = fvec_2 * f0; veccompare (float, 4, f1, f2);
    f1 = 2. / f0;  f2 = fvec_2 / f0; veccompare (float, 4, f1, f2);

    f1 = f0 + 2.;  f2 = f0 + fvec_2; veccompare (float, 4, f1, f2);
    f1 = f0 - 2.;  f2 = f0 - fvec_2; veccompare (float, 4, f1, f2);
    f1 = f0 * 2.;  f2 = f0 * fvec_2; veccompare (float, 4, f1, f2);
    f1 = f0 / 2.;  f2 = f0 / fvec_2; veccompare (float, 4, f1, f2);

    d1 = 2. + d0;  d2 = dvec_2 + d0; veccompare (double, 2, d1, d2);
    d1 = 2. - d0;  d2 = dvec_2 - d0; veccompare (double, 2, d1, d2);
    d1 = 2. * d0;  d2 = dvec_2 * d0; veccompare (double, 2, d1, d2);
    d1 = 2. / d0;  d2 = dvec_2 / d0; veccompare (double, 2, d1, d2);

    d1 = d0 + 2.;  d2 = d0 + dvec_2; veccompare (double, 2, d1, d2);
    d1 = d0 - 2.;  d2 = d0 - dvec_2; veccompare (double, 2, d1, d2);
    d1 = d0 * 2.;  d2 = d0 * dvec_2; veccompare (double, 2, d1, d2);
    d1 = d0 / 2.;  d2 = d0 / dvec_2; veccompare (double, 2, d1, d2);

    return 0;
}
// source: scal-to-vec2.c
#define vector(elcount, type)  \
__attribute__((vector_size((elcount)*sizeof(type)))) type

#define vidx(type, vec, idx) (*((type *) &(vec) + idx))

#define operl(a, b, op) (a op b)
#define operr(a, b, op) (b op a)

#define check(type, count, vec0, vec1, num, op, lr) \
do {\
    int __i; \
    for (__i = 0; __i < count; __i++) {\
        if (vidx (type, vec1, __i) != oper##lr (num, vidx (type, vec0, __i), op)) \
            __builtin_abort (); \
    }\
} while (0)

#define veccompare(type, count, v0, v1) \
do {\
    int __i; \
    for (__i = 0; __i < count; __i++) { \
        if (vidx (type, v0, __i) != vidx (type, v1, __i)) \
            __builtin_abort (); \
    } \
} while (0)


long __attribute__ ((noinline)) vlng () {   return (long)42; }
int  __attribute__ ((noinline)) vint () {   return (int) 43; }
short __attribute__ ((noinline)) vsrt () {   return (short)42; }
char __attribute__ ((noinline)) vchr () {    return (char)42; }


int main (int argc, char *argv[]) {
    vector(16, char) c0 = {argc, 1,2,3,4,5,6,7, argc, 1,2,3,4,5,6,7};
    vector(16, char) c1;

    vector(8, short) s0 = {argc, 1,2,3,4,5,6,7};
    vector(8, short) s1;

    vector(4, int) i0 = {argc, 1, 2, 3};
    vector(4, int) i1;

    vector(2, long) l0 = {argc, 1};
    vector(2, long) l1;

    c1 = vchr() + c0; check (char, 16, c0, c1, vchr(), +, l);

    s1 = vsrt() + s0; check (short, 8, s0, s1, vsrt(), +, l);
    s1 = vchr() + s0; check (short, 8, s0, s1, vchr(), +, l);

    i1 = vint() * i0; check (int, 4, i0, i1, vint(), *, l);
    i1 = vsrt() * i0; check (int, 4, i0, i1, vsrt(), *, l);
    i1 = vchr() * i0; check (int, 4, i0, i1, vchr(), *, l);

    l1 = vlng() * l0; check (long, 2, l0, l1, vlng(), *, l);
    l1 = vint() * l0; check (long, 2, l0, l1, vint(), *, l);
    l1 = vsrt() * l0; check (long, 2, l0, l1, vsrt(), *, l);
    l1 = vchr() * l0; check (long, 2, l0, l1, vchr(), *, l);

    return 0;
}
// source: scal-to-vec3.c
#define vector(elcount, type)  \
__attribute__((vector_size((elcount)*sizeof(type)))) type

#define vidx(type, vec, idx) (*((type *) &(vec) + idx))

#define veccompare(type, count, v0, v1) \
do {\
    int __i; \
    for (__i = 0; __i < count; __i++) { \
        if (vidx (type, v0, __i) != vidx (type, v1, __i)) \
            __builtin_abort (); \
    } \
} while (0)


int main (int argc, char *argv[]) {
#define fvec_2 (vector(4, float)){2., 2., 2., 2.}
#define dvec_2 (vector(2, double)){2., 2.}

    vector(4, float) f0 = {1., 2., 3., 4.};
    vector(4, float) f1, f2;

    vector(2, double) d0 = {1., 2.};
    vector(2, double) d1, d2;


    f1 = 2 + f0;  f2 = fvec_2 + f0; veccompare (float, 4, f1, f2);
    f1 = 2 - f0;  f2 = fvec_2 - f0; veccompare (float, 4, f1, f2);
    f1 = 2 * f0;  f2 = fvec_2 * f0; veccompare (float, 4, f1, f2);
    f1 = 2 / f0;  f2 = fvec_2 / f0; veccompare (float, 4, f1, f2);

    f1 = f0 + 2;  f2 = f0 + fvec_2; veccompare (float, 4, f1, f2);
    f1 = f0 - 2;  f2 = f0 - fvec_2; veccompare (float, 4, f1, f2);
    f1 = f0 * 2;  f2 = f0 * fvec_2; veccompare (float, 4, f1, f2);
    f1 = f0 / 2;  f2 = f0 / fvec_2; veccompare (float, 4, f1, f2);

    d1 = 2 + d0;  d2 = dvec_2 + d0; veccompare (double, 2, d1, d2);
    d1 = 2 - d0;  d2 = dvec_2 - d0; veccompare (double, 2, d1, d2);
    d1 = 2 * d0;  d2 = dvec_2 * d0; veccompare (double, 2, d1, d2);
    d1 = 2 / d0;  d2 = dvec_2 / d0; veccompare (double, 2, d1, d2);

    d1 = d0 + 2;  d2 = d0 + dvec_2; veccompare (double, 2, d1, d2);
    d1 = d0 - 2;  d2 = d0 - dvec_2; veccompare (double, 2, d1, d2);
    d1 = d0 * 2;  d2 = d0 * dvec_2; veccompare (double, 2, d1, d2);
    d1 = d0 / 2;  d2 = d0 / dvec_2; veccompare (double, 2, d1, d2);

    return 0;
}
// source: scope-1.c
int v = 3;

f ()
{
  int v = 4;
  {
    extern int v;
    if (v != 3)
      abort ();
  }
}

main ()
{
  f ();
  exit (0);
}
// source: shiftdi-2.c
/* { dg-require-effective-target longlong64 } */

long long a = 568513516876543756;
long long b = -754324895235774564;
unsigned long long c = 156789543257562457;

long long expected_a[64] = {568513516876543756, 1137027033753087512, 2274054067506175024, 4548108135012350048, 9096216270024700096, -254311533660151424, -508623067320302848, -1017246134640605696, -2034492269281211392, -4068984538562422784, -8137969077124845568, 2170805919459860480, 4341611838919720960, 8683223677839441920, -1080296718030667776, -2160593436061335552, -4321186872122671104, -8642373744245342208, 1161996585218867200, 2323993170437734400, 4647986340875468800, -9150771391958614016, 145201289792323584, 290402579584647168, 580805159169294336, 1161610318338588672, 2323220636677177344, 4646441273354354688, -9153861527000842240, 139021019707867136, 278042039415734272, 556084078831468544, 1112168157662937088, 2224336315325874176, 4448672630651748352, 8897345261303496704, -652053551102558208, -1304107102205116416, -2608214204410232832, -5216428408820465664, 8013887256068620288, -2418969561572311040, -4837939123144622080, 8770865827420307456, -905012418868936704, -1810024837737873408, -3620049675475746816, -7240099350951493632, 3966545371806564352, 7933090743613128704, -2580562586483294208, -5161125172966588416, 8124493727776374784, -2197756618156802048, -4395513236313604096, -8791026472627208192, 864691128455135232, 1729382256910270464, 3458764513820540928, 6917529027641081856, -4611686018427387904, -9223372036854775808ULL, 0, 0};
long long expected_b[64] = {-754324895235774564, -377162447617887282, -188581223808943641, -94290611904471821, -47145305952235911, -23572652976117956, -11786326488058978, -5893163244029489, -2946581622014745, -1473290811007373, -736645405503687, -368322702751844, -184161351375922, -92080675687961, -46040337843981, -23020168921991, -11510084460996, -5755042230498, -2877521115249, -1438760557625, -719380278813, -359690139407, -179845069704, -89922534852, -44961267426, -22480633713, -11240316857, -5620158429, -2810079215, -1405039608, -702519804, -351259902, -175629951, -87814976, -43907488, -21953744, -10976872, -5488436, -2744218, -1372109, -686055, -343028, -171514, -85757, -42879, -21440, -10720, -5360, -2680, -1340, -670, -335, -168, -84, -42, -21, -11, -6, -3, -2, -1, -1, -1, -1};
unsigned long long expected_c[64] = {156789543257562457, 78394771628781228, 39197385814390614, 19598692907195307, 9799346453597653, 4899673226798826, 2449836613399413, 1224918306699706, 612459153349853, 306229576674926, 153114788337463, 76557394168731, 38278697084365, 19139348542182, 9569674271091, 4784837135545, 2392418567772, 1196209283886, 598104641943, 299052320971, 149526160485, 74763080242, 37381540121, 18690770060, 9345385030, 4672692515, 2336346257, 1168173128, 584086564, 292043282, 146021641, 73010820, 36505410, 18252705, 9126352, 4563176, 2281588, 1140794, 570397, 285198, 142599, 71299, 35649, 17824, 8912, 4456, 2228, 1114, 557, 278, 139, 69, 34, 17, 8, 4, 2, 1, 0, 0, 0, 0, 0, 0};

int
main (void)
{
  int i;

  for (i = 0; i < 64; i++)
  {
    if ((a << i) != expected_a[i]
	|| (b >> i) != expected_b[i]
	|| (c >> i) != expected_c[i])
      __builtin_abort ();
  }
  return 0;
}
// source: shiftdi.c
/* { dg-require-effective-target int32plus } */

/* Failed on sparc with -mv8plus because sparc.c:set_extends() thought
   erroneously that SImode ASHIFT chops the upper bits, it does not.  */

typedef unsigned long long uint64;

void g(uint64 x, int y, int z, uint64 *p)
{
	unsigned w = ((x >> y) & 0xffffffffULL) << (z & 0x1f);
	*p |= (w & 0xffffffffULL) << z;
}

int main(void)
{
	uint64 a = 0;
	g(0xdeadbeef01234567ULL, 0, 0, &a);
	return (a == 0x01234567) ? 0 : 1;
}
// source: shiftopt-1.c
/* Copyright (C) 2002  Free Software Foundation

   Check that constant folding of shift operations is working.

   Roger Sayle, 10th October 2002.  */

extern void abort (void);
extern void link_error (void);

void
utest (unsigned int x)
{
  if (x >> 0 != x)
    link_error ();

  if (x << 0 != x)
    link_error ();

  if (0 << x != 0)
    link_error ();

  if (0 >> x != 0)
    link_error ();

  if (-1 >> x != -1)
    link_error ();

  if (~0 >> x != ~0)
    link_error ();
}

void
stest (int x)
{
  if (x >> 0 != x)
    link_error ();

  if (x << 0 != x)
    link_error ();

  if (0 << x != 0)
    link_error ();

  if (0 >> x != 0)
    link_error ();
}

int
main ()
{
  utest(9);
  utest(0);

  stest(9);
  stest(0);

  return 0;
}

#ifndef __OPTIMIZE__
void
link_error ()
{
  abort ();
}
#endif
// source: simd-1.c
/* Origin: Aldy Hernandez <aldyh@redhat.com>

   Purpose: Test generic SIMD support.  This test should work
   regardless of if the target has SIMD instructions.
*/

typedef int __attribute__((mode(SI))) __attribute__((vector_size (16))) vecint;
typedef int __attribute__((mode(SI))) siint;

vecint i = { 150, 100, 150, 200 };
vecint j = { 10, 13, 20, 30 };
vecint k;

union {
  vecint v;
  siint i[4];
} res;

/* This should go away once we can use == and != on vector types.  */
void
verify (siint a1, siint a2, siint a3, siint a4,
	siint b1, siint b2, siint b3, siint b4)
{
  if (a1 != b1
      || a2 != b2
      || a3 != b3
      || a4 != b4)
    abort ();
}

int
main ()
{
  k = i + j;
  res.v = k;

  verify (res.i[0], res.i[1], res.i[2], res.i[3], 160, 113, 170, 230);

  k = i * j;
  res.v = k;

  verify (res.i[0], res.i[1], res.i[2], res.i[3], 1500, 1300, 3000, 6000);

  k = i / j;
  res.v = k;

  verify (res.i[0], res.i[1], res.i[2], res.i[3], 15, 7, 7, 6);

  k = i & j;
  res.v = k;

  verify (res.i[0], res.i[1], res.i[2], res.i[3], 2, 4, 20, 8);

  k = i | j;
  res.v = k;

  verify (res.i[0], res.i[1], res.i[2], res.i[3], 158, 109, 150, 222);

  k = i ^ j;
  res.v = k;

  verify (res.i[0], res.i[1], res.i[2], res.i[3], 156, 105, 130, 214);

  k = -i;
  res.v = k;
  verify (res.i[0], res.i[1], res.i[2], res.i[3],
	  -150, -100, -150, -200);

  k = ~i;
  res.v = k;
  verify (res.i[0], res.i[1], res.i[2], res.i[3], -151, -101, -151, -201);

  exit (0);
}
// source: simd-2.c
/*
   Purpose: Test generic SIMD support, V8HImode.  This test should work
   regardless of if the target has SIMD instructions.
*/

typedef short __attribute__((vector_size (16))) vecint;

vecint i = { 150, 100, 150, 200, 0, 0, 0, 0 };
vecint j = { 10, 13, 20, 30, 1, 1, 1, 1 };
vecint k;

union {
  vecint v;
  short i[8];
} res;

/* This should go away once we can use == and != on vector types.  */
void
verify (int a1, int a2, int a3, int a4,
	int b1, int b2, int b3, int b4)
{
  if (a1 != b1
      || a2 != b2
      || a3 != b3
      || a4 != b4)
    abort ();
}

int
main ()
{
  k = i + j;
  res.v = k;

  verify (res.i[0], res.i[1], res.i[2], res.i[3], 160, 113, 170, 230);

  k = i * j;
  res.v = k;

  verify (res.i[0], res.i[1], res.i[2], res.i[3], 1500, 1300, 3000, 6000);

  k = i / j;
  res.v = k;

  verify (res.i[0], res.i[1], res.i[2], res.i[3], 15, 7, 7, 6);

  k = i & j;
  res.v = k;

  verify (res.i[0], res.i[1], res.i[2], res.i[3], 2, 4, 20, 8);

  k = i | j;
  res.v = k;

  verify (res.i[0], res.i[1], res.i[2], res.i[3], 158, 109, 150, 222);

  k = i ^ j;
  res.v = k;

  verify (res.i[0], res.i[1], res.i[2], res.i[3], 156, 105, 130, 214);

  k = -i;
  res.v = k;
  verify (res.i[0], res.i[1], res.i[2], res.i[3],
	  -150, -100, -150, -200);

  k = ~i;
  res.v = k;
  verify (res.i[0], res.i[1], res.i[2], res.i[3], -151, -101, -151, -201);

  exit (0);
}
// source: simd-4.c
/* { dg-require-effective-target stdint_types } */
#include <stdint.h>
typedef int32_t __attribute__((vector_size(8))) v2si;
int64_t s64;

static inline int64_t
__ev_convert_s64 (v2si a)
{
  return (int64_t) a;
}

int main()
{
  union { int64_t ll; int32_t i[2]; } endianness_test;
  endianness_test.ll = 1;
  int32_t little_endian = endianness_test.i[0];
  s64 = __ev_convert_s64 ((v2si){1,0xffffffff});
  if (s64 != (little_endian ? 0xffffffff00000001LL : 0x1ffffffffLL))
    abort ();
  return 0;
}
// source: simd-5.c
/* Test saving and restoring of SIMD registers.  */

typedef short Q __attribute__((vector_size(8)));

Q q1 = {1, 2}, q2 = {3, 4}, q3 = {5, 6}, q4 = {7, 8};

Q w1, w2, w3, w4;
Q z1, z2, z3, z4;

volatile int dummy;

void  __attribute__((__noinline__))
func0 (void)
{
  dummy = 1;
}

void __attribute__((__noinline__))
func1 (void)
{
  Q a, b;
  a = q1 * q2;
  b = q3 * q4;
  w1 = a;
  w2 = b;
  func0 ();
  w3 = a;
  w4 = b;
}

void __attribute__((__noinline__))
func2 (void)
{
  Q a, b;
  a = q1 + q2;
  b = q3 - q4;
  z1 = a;
  z2 = b;
  func1 ();
  z3 = a;
  z4 = b;
}

int
main (void)
{
  func2 ();

  if (memcmp (&w1, &w3, sizeof (Q)) != 0)
    abort ();
  if (memcmp (&w2, &w4, sizeof (Q)) != 0)
    abort ();
  if (memcmp (&z1, &z3, sizeof (Q)) != 0)
    abort ();
  if (memcmp (&z2, &z4, sizeof (Q)) != 0)
    abort ();

  return 0;
}
// source: simd-6.c
extern void abort (void);
extern int memcmp (const void *, const void *, __SIZE_TYPE__);

typedef unsigned char v8qi __attribute__((vector_size(8)));

v8qi foo(v8qi x, v8qi y)
{
  return x * y;
}

int main()
{
  v8qi a = { 1, 2, 3, 4, 5, 6, 7, 8 };
  v8qi b = { 3, 3, 3, 3, 3, 3, 3, 3 };
  v8qi c = { 3, 6, 9, 12, 15, 18, 21, 24 };
  v8qi r;

  r = foo (a, b);
  if (memcmp (&r, &c, 8) != 0)
    abort ();
  return 0;
}
// source: ssad-run.c
extern void abort ();
extern int abs (int __x) __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__const__));

static int
foo (signed char *w, int i, signed char *x, int j)
{
  int tot = 0;
  for (int a = 0; a < 16; a++)
    {
      for (int b = 0; b < 16; b++)
	tot += abs (w[b] - x[b]);
      w += i;
      x += j;
    }
  return tot;
}

void
bar (signed char *w, signed char *x, int i, int *result)
{
  *result = foo (w, 16, x, i);
}

int
main (void)
{
  signed char m[256];
  signed char n[256];
  int sum, i;

  for (i = 0; i < 256; ++i)
    if (i % 2 == 0)
      {
	m[i] = (i % 8) * 2 + 1;
	n[i] = -(i % 8);
      }
    else
      {
	m[i] = -((i % 8) * 2 + 2);
	n[i] = -((i % 8) >> 1);
      }

  bar (m, n, 16, &sum);

  if (sum != 2368)
    abort ();

  return 0;
}
// source: stdarg-1.c
#include <stdarg.h>

extern void abort (void);

int foo_arg, bar_arg;
long x;
double d;
va_list gap;
va_list *pap;

void
foo (int v, va_list ap)
{
  switch (v)
    {
    case 5: foo_arg = va_arg (ap, int); break;
    default: abort ();
    }
}

void
bar (int v)
{
  if (v == 0x4006)
    {
      if (va_arg (gap, double) != 17.0
	  || va_arg (gap, long) != 129L)
	abort ();
    }
  else if (v == 0x4008)
    {
      if (va_arg (*pap, long long) != 14LL
	  || va_arg (*pap, long double) != 131.0L
	  || va_arg (*pap, int) != 17)
	abort ();
    }
  bar_arg = v;
}

void
f0 (int i, ...)
{
}

void
f1 (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  va_end (ap);
}

void
f2 (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  bar (d);
  x = va_arg (ap, long);
  bar (x);
  va_end (ap);
}

void
f3 (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  d = va_arg (ap, double);
  va_end (ap);
}

void
f4 (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  x = va_arg (ap, double);
  foo (i, ap);
  va_end (ap);
}

void
f5 (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  va_copy (gap, ap);
  bar (i);
  va_end (ap);
  va_end (gap);
}

void
f6 (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  bar (d);
  va_arg (ap, long);
  va_arg (ap, long);
  x = va_arg (ap, long);
  bar (x);
  va_end (ap);
}

void
f7 (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  pap = &ap;
  bar (i);
  va_end (ap);
}

void
f8 (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  pap = &ap;
  bar (i);
  d = va_arg (ap, double);
  va_end (ap);
}

int
main (void)
{
  f0 (1);
  f1 (2);
  d = 31.0;
  f2 (3, 28L);
  if (bar_arg != 28 || x != 28)
    abort ();
  f3 (4, 131.0);
  if (d != 131.0)
    abort ();
  f4 (5, 16.0, 128);
  if (x != 16 || foo_arg != 128)
    abort ();
  f5 (0x4006, 17.0, 129L);
  if (bar_arg != 0x4006)
    abort ();
  f6 (7, 12L, 14L, -31L);
  if (bar_arg != -31)
    abort ();
  f7 (0x4008, 14LL, 131.0L, 17, 26.0);
  if (bar_arg != 0x4008)
    abort ();
  f8 (0x4008, 14LL, 131.0L, 17, 27.0);
  if (bar_arg != 0x4008 || d != 27.0)
    abort ();
  return 0;
}
// source: stdarg-2.c
#include <stdarg.h>

extern void abort (void);

int foo_arg, bar_arg;
long x;
double d;
va_list gap;

void
foo (int v, va_list ap)
{
  switch (v)
    {
    case 5:
      foo_arg = va_arg (ap, int);
      foo_arg += va_arg (ap, double);
      foo_arg += va_arg (ap, long long);
      break;
    case 8:
      foo_arg = va_arg (ap, long long);
      foo_arg += va_arg (ap, double);
      break;
    case 11:
      foo_arg = va_arg (ap, int);
      foo_arg += va_arg (ap, long double);
      break;
    default:
      abort ();
    }
}

void
bar (int v)
{
  if (v == 0x4002)
    {
      if (va_arg (gap, int) != 13 || va_arg (gap, double) != -14.0)
	abort ();
    }
  bar_arg = v;
}

void
f1 (int i, ...)
{
  va_start (gap, i);
  x = va_arg (gap, long);
  va_end (gap);
}

void
f2 (int i, ...)
{
  va_start (gap, i);
  bar (i);
  va_end (gap);
}

void
f3 (int i, ...)
{
  va_list aps[10];
  va_start (aps[4], i);
  x = va_arg (aps[4], long);
  va_end (aps[4]);
}

void
f4 (int i, ...)
{
  va_list aps[10];
  va_start (aps[4], i);
  bar (i);
  va_end (aps[4]);
}

void
f5 (int i, ...)
{
  va_list aps[10];
  va_start (aps[4], i);
  foo (i, aps[4]);
  va_end (aps[4]);
}

struct A { int i; va_list g; va_list h[2]; };

void
f6 (int i, ...)
{
  struct A a;
  va_start (a.g, i);
  x = va_arg (a.g, long);
  va_end (a.g);
}

void
f7 (int i, ...)
{
  struct A a;
  va_start (a.g, i);
  bar (i);
  va_end (a.g);
}

void
f8 (int i, ...)
{
  struct A a;
  va_start (a.g, i);
  foo (i, a.g);
  va_end (a.g);
}

void
f10 (int i, ...)
{
  struct A a;
  va_start (a.h[1], i);
  x = va_arg (a.h[1], long);
  va_end (a.h[1]);
}

void
f11 (int i, ...)
{
  struct A a;
  va_start (a.h[1], i);
  bar (i);
  va_end (a.h[1]);
}

void
f12 (int i, ...)
{
  struct A a;
  va_start (a.h[1], i);
  foo (i, a.h[1]);
  va_end (a.h[1]);
}

int
main (void)
{
  f1 (1, 79L);
  if (x != 79L)
    abort ();
  f2 (0x4002, 13, -14.0);
  if (bar_arg != 0x4002)
    abort ();
  f3 (3, 2031L);
  if (x != 2031)
    abort ();
  f4 (4, 18);
  if (bar_arg != 4)
    abort ();
  f5 (5, 1, 19.0, 18LL);
  if (foo_arg != 38)
    abort ();
  f6 (6, 18L);
  if (x != 18L)
    abort ();
  f7 (7);
  if (bar_arg != 7)
    abort ();
  f8 (8, 2031LL, 13.0);
  if (foo_arg != 2044)
    abort ();
  f10 (9, 180L);
  if (x != 180L)
    abort ();
  f11 (10);
  if (bar_arg != 10)
    abort ();
  f12 (11, 2030, 12.0L);
  if (foo_arg != 2042)
    abort ();
  return 0;
}
// source: stdarg-3.c
#include <stdarg.h>

extern void abort (void);

int foo_arg, bar_arg;
long x;
double d;
va_list gap;
struct S1 { int i; double d; int j; double e; } s1;
struct S2 { double d; long i; } s2;
int y;

void
bar (int v)
{
  bar_arg = v;
}

void
f1 (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  while (i-- > 0)
    x = va_arg (ap, long);
  va_end (ap);
}

void
f2 (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  while (i-- > 0)
    d = va_arg (ap, double);
  va_end (ap);
}

void
f3 (int i, ...)
{
  va_list ap;
  int j = i;
  while (j-- > 0)
    {
      va_start (ap, i);
      x = va_arg (ap, long);
      va_end (ap);
      bar (x);
    }
}

void
f4 (int i, ...)
{
  va_list ap;
  int j = i;
  while (j-- > 0)
    {
      va_start (ap, i);
      d = va_arg (ap, double);
      va_end (ap);
      bar (d + 4.0);
    }
}

void
f5 (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  while (i-- > 0)
    s1 = va_arg (ap, struct S1);
  va_end (ap);
}

void
f6 (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  while (i-- > 0)
    s2 = va_arg (ap, struct S2);
  va_end (ap);
}

void
f7 (int i, ...)
{
  va_list ap;
  int j = i;
  while (j-- > 0)
    {
      va_start (ap, i);
      s1 = va_arg (ap, struct S1);
      va_end (ap);
      bar (s1.i);
    }
}

void
f8 (int i, ...)
{
  va_list ap;
  int j = i;
  while (j-- > 0)
    {
      va_start (ap, i);
      s2 = va_arg (ap, struct S2);
      y = va_arg (ap, int);
      va_end (ap);
      bar (s2.i);
    }
}

int
main (void)
{
  struct S1 a1, a3;
  struct S2 a2, a4;

  f1 (7, 1L, 2L, 3L, 5L, 7L, 9L, 11L, 13L);
  if (x != 11L)
    abort ();
  f2 (6, 1.0, 2.0, 4.0, 8.0, 16.0, 32.0, 64.0);
  if (d != 32.0)
    abort ();
  f3 (2, 1L, 3L);
  if (bar_arg != 1L || x != 1L)
    abort ();
  f4 (2, 17.0, 19.0);
  if (bar_arg != 21 || d != 17.0)
    abort ();
  a1.i = 131;
  a1.j = 251;
  a1.d = 15.0;
  a1.e = 191.0;
  a3 = a1;
  a3.j = 254;
  a3.e = 178.0;
  f5 (2, a1, a3, a1);
  if (s1.i != 131 || s1.j != 254 || s1.d != 15.0 || s1.e != 178.0)
    abort ();
  f5 (3, a1, a3, a1);
  if (s1.i != 131 || s1.j != 251 || s1.d != 15.0 || s1.e != 191.0)
    abort ();
  a2.i = 138;
  a2.d = 16.0;
  a4.i = 257;
  a4.d = 176.0;
  f6 (2, a2, a4, a2);
  if (s2.i != 257 || s2.d != 176.0)
    abort ();
  f6 (3, a2, a4, a2);
  if (s2.i != 138 || s2.d != 16.0)
    abort ();
  f7 (2, a3, a1, a1);
  if (s1.i != 131 || s1.j != 254 || s1.d != 15.0 || s1.e != 178.0)
    abort ();
  if (bar_arg != 131)
    abort ();
  f8 (3, a4, a2, a2);
  if (s2.i != 257 || s2.d != 176.0)
    abort ();
  return 0;
}
// source: stdarg-4.c
#include <stdarg.h>

extern void abort (void);
long x, y;

inline void __attribute__((always_inline))
f1i (va_list ap)
{
  x = va_arg (ap, double);
  x += va_arg (ap, long);
  x += va_arg (ap, double);
}

void
f1 (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  f1i (ap);
  va_end (ap);
}

inline void __attribute__((always_inline))
f2i (va_list ap)
{
  y = va_arg (ap, int);
  y += va_arg (ap, long);
  y += va_arg (ap, double);
  f1i (ap);
}

void
f2 (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  f2i (ap);
  va_end (ap);
}

long
f3h (int i, long arg0, long arg1, long arg2, long arg3)
{
  return i + arg0 + arg1 + arg2 + arg3;
}

long
f3 (int i, ...)
{
  long t, arg0, arg1, arg2, arg3;
  va_list ap;

  va_start (ap, i);
  switch (i)
    {
    case 0:
      t = f3h (i, 0, 0, 0, 0);
      break;
    case 1:
      arg0 = va_arg (ap, long);
      t = f3h (i, arg0, 0, 0, 0);
      break;
    case 2:
      arg0 = va_arg (ap, long);
      arg1 = va_arg (ap, long);
      t = f3h (i, arg0, arg1, 0, 0);
      break;
    case 3:
      arg0 = va_arg (ap, long);
      arg1 = va_arg (ap, long);
      arg2 = va_arg (ap, long);
      t = f3h (i, arg0, arg1, arg2, 0);
      break;
    case 4:
      arg0 = va_arg (ap, long);
      arg1 = va_arg (ap, long);
      arg2 = va_arg (ap, long);
      arg3 = va_arg (ap, long);
      t = f3h (i, arg0, arg1, arg2, arg3);
      break;
    default:
      abort ();
    }
  va_end (ap);

  return t;
}

void
f4 (int i, ...)
{
  va_list ap;

  va_start (ap, i);
  switch (i)
    {
    case 4:
      y = va_arg (ap, double);
      break;
    case 5:
      y = va_arg (ap, double);
      y += va_arg (ap, double);
      break;
    default:
      abort ();
    }
  f1i (ap);
  va_end (ap);
}

int
main (void)
{
  f1 (3, 16.0, 128L, 32.0);
  if (x != 176L)
    abort ();
  f2 (6, 5, 7L, 18.0, 19.0, 17L, 64.0);
  if (x != 100L || y != 30L)
    abort ();
  if (f3 (0) != 0)
    abort ();
  if (f3 (1, 18L) != 19L)
    abort ();
  if (f3 (2, 18L, 100L) != 120L)
    abort ();
  if (f3 (3, 18L, 100L, 300L) != 421L)
    abort ();
  if (f3 (4, 18L, 71L, 64L, 86L) != 243L)
    abort ();
  f4 (4, 6.0, 9.0, 16L, 18.0);
  if (x != 43L || y != 6L)
    abort ();
  f4 (5, 7.0, 21.0, 1.0, 17L, 126.0);
  if (x != 144L || y != 28L)
    abort ();
  return 0;
}
// source: stkalign.c
/* { dg-options "-fno-inline" } */
/* Check that stack alignment is not affected by variables not placed
   on the stack.  */

#include <assert.h>

#define ALIGNMENT 64

unsigned test(unsigned n, unsigned p)
{
  static struct { char __attribute__((__aligned__(ALIGNMENT))) c; } s;
  unsigned x;

  assert(__alignof__(s) == ALIGNMENT);
  asm ("" : "=g" (x), "+m" (s) : "0" (&x));

  return n ? test(n - 1, x) : (x ^ p);
}

unsigned test2(unsigned n, unsigned p)
{
  static struct { char c; } s;
  unsigned x;

  assert(__alignof__(s) != ALIGNMENT);
  asm ("" : "=g" (x), "+m" (s) : "0" (&x));

  return n ? test2(n - 1, x) : (x ^ p);
}

int main (int argc, char *argv[] __attribute__((unused)))
{
  unsigned int x, y;

  x = test(argc, 0);
  x |= test(argc + 1, 0);
  x |= test(argc + 2, 0);

  y = test2(argc, 0);
  y |= test2(argc + 1, 0);
  y |= test2(argc + 2, 0);

  return (x & (ALIGNMENT - 1)) == 0 && (y & (ALIGNMENT - 1)) != 0 ? 1 : 0;
}
// source: strcmp-1.c
/* Copyright (C) 2002  Free Software Foundation.

   Test strcmp with various combinations of pointer alignments and lengths to
   make sure any optimizations in the library are correct.

   Written by Michael Meissner, March 9, 2002.  */

#include <string.h>
#include <stddef.h>

#ifndef MAX_OFFSET
#define MAX_OFFSET (sizeof (long long))
#endif

#ifndef MAX_TEST
#define MAX_TEST (8 * sizeof (long long))
#endif

#ifndef MAX_EXTRA
#define MAX_EXTRA (sizeof (long long))
#endif

#define MAX_LENGTH (MAX_OFFSET + MAX_TEST + MAX_EXTRA + 2)

static union {
  unsigned char buf[MAX_LENGTH];
  long long align_int;
  long double align_fp;
} u1, u2;

void
test (const unsigned char *s1, const unsigned char *s2, int expected)
{
  int value = strcmp ((char *) s1, (char *) s2);

  if (expected < 0 && value >= 0)
    abort ();
  else if (expected == 0 && value != 0)
    abort ();
  else if (expected > 0 && value <= 0)
    abort ();
}

main ()
{
  size_t off1, off2, len, i;
  unsigned char *buf1, *buf2;
  unsigned char *mod1, *mod2;
  unsigned char *p1, *p2;

  for (off1 = 0; off1 < MAX_OFFSET; off1++)
    for (off2 = 0; off2 < MAX_OFFSET; off2++)
      for (len = 0; len < MAX_TEST; len++)
	{
	  p1 = u1.buf;
	  for (i = 0; i < off1; i++)
	    *p1++ = '\0';

	  buf1 = p1;
	  for (i = 0; i < len; i++)
	    *p1++ = 'a';

	  mod1 = p1;
	  for (i = 0; i < MAX_EXTRA+2; i++)
	    *p1++ = 'x';

	  p2 = u2.buf;
	  for (i = 0; i < off2; i++)
	    *p2++ = '\0';

	  buf2 = p2;
	  for (i = 0; i < len; i++)
	    *p2++ = 'a';

	  mod2 = p2;
	  for (i = 0; i < MAX_EXTRA+2; i++)
	    *p2++ = 'x';

	  mod1[0] = '\0';
	  mod2[0] = '\0';
	  test (buf1, buf2, 0);

	  mod1[0] = 'a';
	  mod1[1] = '\0';
	  mod2[0] = '\0';
	  test (buf1, buf2, +1);

	  mod1[0] = '\0';
	  mod2[0] = 'a';
	  mod2[1] = '\0';
	  test (buf1, buf2, -1);

	  mod1[0] = 'b';
	  mod1[1] = '\0';
	  mod2[0] = 'c';
	  mod2[1] = '\0';
	  test (buf1, buf2, -1);

	  mod1[0] = 'c';
	  mod1[1] = '\0';
	  mod2[0] = 'b';
	  mod2[1] = '\0';
	  test (buf1, buf2, +1);

	  mod1[0] = 'b';
	  mod1[1] = '\0';
	  mod2[0] = (unsigned char)'\251';
	  mod2[1] = '\0';
	  test (buf1, buf2, -1);

	  mod1[0] = (unsigned char)'\251';
	  mod1[1] = '\0';
	  mod2[0] = 'b';
	  mod2[1] = '\0';
	  test (buf1, buf2, +1);

	  mod1[0] = (unsigned char)'\251';
	  mod1[1] = '\0';
	  mod2[0] = (unsigned char)'\252';
	  mod2[1] = '\0';
	  test (buf1, buf2, -1);

	  mod1[0] = (unsigned char)'\252';
	  mod1[1] = '\0';
	  mod2[0] = (unsigned char)'\251';
	  mod2[1] = '\0';
	  test (buf1, buf2, +1);
	}

  exit (0);
}
// source: strcpy-1.c
/* Copyright (C) 2002  Free Software Foundation.

   Test strcpy with various combinations of pointer alignments and lengths to
   make sure any optimizations in the library are correct.  */

#include <string.h>

#ifndef MAX_OFFSET
#define MAX_OFFSET (sizeof (long long))
#endif

#ifndef MAX_COPY
#define MAX_COPY (10 * sizeof (long long))
#endif

#ifndef MAX_EXTRA
#define MAX_EXTRA (sizeof (long long))
#endif

#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + 1 + MAX_EXTRA)

/* Use a sequence length that is not divisible by two, to make it more
   likely to detect when words are mixed up.  */
#define SEQUENCE_LENGTH 31

static union {
  char buf[MAX_LENGTH];
  long long align_int;
  long double align_fp;
} u1, u2;

main ()
{
  int off1, off2, len, i;
  char *p, *q, c;

  for (off1 = 0; off1 < MAX_OFFSET; off1++)
    for (off2 = 0; off2 < MAX_OFFSET; off2++)
      for (len = 1; len < MAX_COPY; len++)
	{
	  for (i = 0, c = 'A'; i < MAX_LENGTH; i++, c++)
	    {
	      u1.buf[i] = 'a';
	      if (c >= 'A' + SEQUENCE_LENGTH)
		c = 'A';
	      u2.buf[i] = c;
	    }
	  u2.buf[off2 + len] = '\0';

	  p = strcpy (u1.buf + off1, u2.buf + off2);
	  if (p != u1.buf + off1)
	    abort ();

	  q = u1.buf;
	  for (i = 0; i < off1; i++, q++)
	    if (*q != 'a')
	      abort ();

	  for (i = 0, c = 'A' + off2; i < len; i++, q++, c++)
	    {
	      if (c >= 'A' + SEQUENCE_LENGTH)
		c = 'A';
	      if (*q != c)
		abort ();
	    }

	  if (*q++ != '\0')
	    abort ();
	  for (i = 0; i < MAX_EXTRA; i++, q++)
	    if (*q != 'a')
	      abort ();
	}

  exit (0);
}
// source: strcpy-2.c
/* Test to make sure strcpy works correctly. */
#define STRING "Hi!THE"

const char a[] = STRING;

void f(char *a) __attribute__((noinline));
void f(char *a)
{
  __builtin_strcpy (a, STRING);
}


int main(void)
{
  int i;
  char b[sizeof(a)] = {};
  f(b);
  for(i = 0; i < sizeof(b); i++)
    {
      if (a[i] != b[i])
	__builtin_abort ();
    }
  return 0;
}
// source: strct-pack-1.c
typedef struct
{
  short s __attribute__ ((aligned(2), packed));
  double d __attribute__ ((aligned(2), packed));
} TRIAL;

int
check (TRIAL *t)
{
  if (t->s != 1 || t->d != 16.0)
    return 1;
  return 0;
}

main ()
{
  TRIAL trial;

  trial.s = 1;
  trial.d = 16.0;

  if (check (&trial) != 0)
    abort ();
  exit (0);
}
// source: strct-pack-2.c
typedef struct
{
  short a __attribute__ ((aligned (2),packed));
  short *ap[2]  __attribute__ ((aligned (2),packed));
} A;

main ()
{
  short i, j = 1;
  A a, *ap = &a;
  ap->ap[j] = &i;
  exit (0);
}
// source: strct-pack-3.c
typedef struct
{
  short i __attribute__ ((aligned (2),packed));
  int f[2] __attribute__ ((aligned (2),packed));
} A;

f (ap)
  A *ap;
{
  short i, j = 1;

  i = ap->f[1];
  i += ap->f[j];
  for (j = 0; j < 2; j++)
    i += ap->f[j];

  return i;
}

main ()
{
  A a;
  a.f[0] = 100;
  a.f[1] = 13;
  if (f (&a) != 139)
    abort ();
  exit (0);
}
// source: strct-pack-4.c
typedef struct
{
  unsigned char a __attribute__((packed));
  unsigned short b __attribute__((packed));
} three_char_t;

unsigned char
my_set_a (void)
{
  return 0xab;
}

unsigned short
my_set_b (void)
{
  return 0x1234;
}

main ()
{
  three_char_t three_char;

  three_char.a = my_set_a ();
  three_char.b = my_set_b ();
  if (three_char.a != 0xab || three_char.b != 0x1234)
    abort ();
  exit (0);
}
// source: strct-stdarg-1.c
#include <stdarg.h>

struct tiny
{
  char c;
  char d;
  char e;
  char f;
  char g;
};

f (int n, ...)
{
  struct tiny x;
  int i;

  va_list ap;
  va_start (ap,n);
  for (i = 0; i < n; i++)
    {
      x = va_arg (ap,struct tiny);
      if (x.c != i + 10)
	abort();
      if (x.d != i + 20)
	abort();
      if (x.e != i + 30)
	abort();
      if (x.f != i + 40)
	abort();
      if (x.g != i + 50)
	abort();
    }
  {
    long x = va_arg (ap, long);
    if (x != 123)
      abort();
  }
  va_end (ap);
}

main ()
{
  struct tiny x[3];
  x[0].c = 10;
  x[1].c = 11;
  x[2].c = 12;
  x[0].d = 20;
  x[1].d = 21;
  x[2].d = 22;
  x[0].e = 30;
  x[1].e = 31;
  x[2].e = 32;
  x[0].f = 40;
  x[1].f = 41;
  x[2].f = 42;
  x[0].g = 50;
  x[1].g = 51;
  x[2].g = 52;
  f (3, x[0], x[1], x[2], (long) 123);
  exit(0);
}
// source: strct-varg-1.c
#include <stdarg.h>

struct s { int x, y; };

f (int attr, ...)
{
  struct s va_values;
  va_list va;
  int i;

  va_start (va, attr);

  if (attr != 2)
    abort ();

  va_values = va_arg (va, struct s);
  if (va_values.x != 0xaaaa || va_values.y != 0x5555)
    abort ();

  attr = va_arg (va, int);
  if (attr != 3)
    abort ();

  va_values = va_arg (va, struct s);
  if (va_values.x != 0xffff || va_values.y != 0x1111)
    abort ();

  va_end (va);
}

main ()
{
  struct s a, b;

  a.x = 0xaaaa;
  a.y = 0x5555;
  b.x = 0xffff;
  b.y = 0x1111;

  f (2, a, 3, b);
  exit (0);
}
// source: string-opt-17.c
/* Copyright (C) 2003  Free Software Foundation.

   Test strcpy optimizations don't evaluate side-effects twice.

   Written by Jakub Jelinek, June 23, 2003.  */

typedef __SIZE_TYPE__ size_t;
extern char *strcpy (char *, const char *);
extern int memcmp (const void *, const void *, size_t);
extern void abort (void);
extern void exit (int);

size_t
test1 (char *s, size_t i)
{
  strcpy (s, "foobarbaz" + i++);
  return i;
}

size_t
check2 (void)
{
  static size_t r = 5;
  if (r != 5)
    abort ();
  return ++r;
}

void
test2 (char *s)
{
  strcpy (s, "foobarbaz" + check2 ());
}

int
main (void)
{
  char buf[10];
  if (test1 (buf, 7) != 8 || memcmp (buf, "az", 3))
    abort ();
  test2 (buf);
  if (memcmp (buf, "baz", 4))
    abort ();
  exit (0);
}
// source: string-opt-18.c
/* Copyright (C) 2003  Free Software Foundation.

   Test equal pointer optimizations don't break anything.

   Written by Roger Sayle, July 14, 2003.  */

extern void abort ();
typedef __SIZE_TYPE__ size_t;

extern void *memcpy(void*, const void*, size_t);
extern void *mempcpy(void*, const void*, size_t);
extern void *memmove(void*, const void*, size_t);
extern char *strcpy(char*, const char*);
extern int memcmp(const void*, const void*, size_t);
extern int strcmp(const char*, const char*);
extern int strncmp(const char*, const char*, size_t);


void test1 (void *ptr)
{
  if (memcpy(ptr,ptr,8) != ptr)
    abort ();
}

void test2 (char *ptr)
{
  if (mempcpy(ptr,ptr,8) != ptr+8)
    abort ();
}

void test3 (void *ptr)
{
  if (memmove(ptr,ptr,8) != ptr)
    abort ();
}

void test4 (char *ptr)
{
  if (strcpy(ptr,ptr) != ptr)
    abort ();
}

void test5 (void *ptr)
{
  if (memcmp(ptr,ptr,8) != 0)
    abort ();
}

void test6 (const char *ptr)
{
  if (strcmp(ptr,ptr) != 0)
    abort ();
}

void test7 (const char *ptr)
{
  if (strncmp(ptr,ptr,8) != 0)
    abort ();
}


int main ()
{
  char buf[10];

  test1 (buf);
  test2 (buf);
  test3 (buf);
  test4 (buf);
  test5 (buf);
  test6 (buf);
  test7 (buf);

  return 0;
}
// source: string-opt-5.c
/* Copyright (C) 2000  Free Software Foundation.

   Ensure builtin strlen, strcmp, strchr, strrchr and strncpy
   perform correctly.

   Written by Jakub Jelinek, 11/7/2000.  */

extern void abort (void);
extern __SIZE_TYPE__ strlen (const char *);
extern int strcmp (const char *, const char *);
extern char *strchr (const char *, int);
extern char *strrchr (const char *, int);
extern char *strncpy (char *, const char *, __SIZE_TYPE__);
extern void *memset (void *, int, __SIZE_TYPE__);
extern int memcmp (const void *, const void *, __SIZE_TYPE__);

int x = 6;
int y = 1;
char *bar = "hi world";
char buf [64];

int main()
{
  const char *const foo = "hello world";
  char dst [64];

  if (strlen (bar) != 8)
    abort ();
  if (strlen (bar + (++x & 2)) != 6)
    abort ();
  if (x != 7)
    abort ();
  if (strlen (foo + (x++, 6)) != 5)
    abort ();
  if (x != 8)
    abort ();
  if (strlen (foo + (++x & 1)) != 10)
    abort ();
  if (x != 9)
    abort ();
  if (strcmp (foo + (x -= 6), "lo world"))
    abort ();
  if (x != 3)
    abort ();
  if (strcmp (foo, bar) >= 0)
    abort ();
  if (strcmp (foo, bar + (x++ & 1)) >= 0)
    abort ();
  if (x != 4)
    abort ();
  if (strchr (foo + (x++ & 7), 'l') != foo + 9)
    abort ();
  if (x != 5)
    abort ();
  if (strchr (bar, 'o') != bar + 4)
    abort ();
  if (strchr (bar, '\0')  != bar + 8)
    abort ();
  if (strrchr (bar, 'x'))
    abort ();
  if (strrchr (bar, 'o') != bar + 4)
    abort ();
  if (strcmp (foo + (x++ & 1), "ello world" + (--y & 1)))
    abort ();
  if (x != 6 || y != 0)
    abort ();
  dst[5] = ' ';
  dst[6] = '\0';
  x = 5;
  y = 1;
  if (strncpy (dst + 1, foo + (x++ & 3), 4) != dst + 1
      || x != 6
      || strcmp (dst + 1, "ello "))
    abort ();
  memset (dst, ' ', sizeof dst);
  if (strncpy (dst + (++x & 1), (y++ & 3) + "foo", 10) != dst + 1
      || x != 7
      || y != 2
      || memcmp (dst, " oo\0\0\0\0\0\0\0\0 ", 12))
    abort ();
  memset (dst, ' ', sizeof dst);
  if (strncpy (dst, "hello", 8) != dst || memcmp (dst, "hello\0\0\0 ", 9))
    abort ();
  x = '!';
  memset (buf, ' ', sizeof buf);
  if (memset (buf, x++, ++y) != buf
      || x != '!' + 1
      || y != 3
      || memcmp (buf, "!!!", 3))
    abort ();
  if (memset (buf + y++, '-', 8) != buf + 3
      || y != 4
      || memcmp (buf, "!!!--------", 11))
    abort ();
  x = 10;
  if (memset (buf + ++x, 0, y++) != buf + 11
      || x != 11
      || y != 5
      || memcmp (buf + 8, "---\0\0\0", 7))
    abort ();
  if (memset (buf + (x += 4), 0, 6) != buf + 15
      || x != 15
      || memcmp (buf + 10, "-\0\0\0\0\0\0\0\0\0", 11))
    abort ();

  return 0;
}
// source: strlen-1.c
/* Copyright (C) 2002  Free Software Foundation.

   Test strlen with various combinations of pointer alignments and lengths to
   make sure any optimizations in the library are correct.

   Written by Michael Meissner, March 9, 2002.  */

#include <string.h>
#include <stddef.h>

#ifndef MAX_OFFSET
#define MAX_OFFSET (sizeof (long long))
#endif

#ifndef MAX_TEST
#define MAX_TEST (8 * sizeof (long long))
#endif

#ifndef MAX_EXTRA
#define MAX_EXTRA (sizeof (long long))
#endif

#define MAX_LENGTH (MAX_OFFSET + MAX_TEST + MAX_EXTRA + 1)

static union {
  char buf[MAX_LENGTH];
  long long align_int;
  long double align_fp;
} u;

main ()
{
  size_t off, len, len2, i;
  char *p;

  for (off = 0; off < MAX_OFFSET; off++)
    for (len = 0; len < MAX_TEST; len++)
      {
	p = u.buf;
	for (i = 0; i < off; i++)
	  *p++ = '\0';

	for (i = 0; i < len; i++)
	  *p++ = 'a';

	*p++ = '\0';
	for (i = 0; i < MAX_EXTRA; i++)
	  *p++ = 'b';

	p = u.buf + off;
	len2 = strlen (p);
	if (len != len2)
	  abort ();
      }

  exit (0);
}
// source: strlen-2.c
/* PR tree-optimization/86532 - Wrong code due to a wrong strlen folding  */

extern __SIZE_TYPE__ strlen (const char*);

static const char a[2][3] = { "1", "12" };
static const char b[2][2][5] = { { "1", "12" }, { "123", "1234" } };

volatile int v0 = 0;
volatile int v1 = 1;
volatile int v2 = 2;

#define A(expr)								\
  ((expr) ? (void)0 : (__builtin_printf ("assertion on line %i: %s\n",	\
					 __LINE__, #expr),		\
		       __builtin_abort ()))

void test_array_ref_2_3 (void)
{
  A (strlen (a[v0]) == 1);
  A (strlen (&a[v0][v0]) == 1);
  A (strlen (&a[0][v0]) == 1);
  A (strlen (&a[v0][0]) == 1);

  A (strlen (a[v1]) == 2);
  A (strlen (&a[v1][0]) == 2);
  A (strlen (&a[1][v0]) == 2);
  A (strlen (&a[v1][v0]) == 2);

  A (strlen (&a[v1][1]) == 1);
  A (strlen (&a[v1][1]) == 1);

  A (strlen (&a[v1][2]) == 0);
  A (strlen (&a[v1][v2]) == 0);

  int i0 = 0;
  int i1 = i0 + 1;
  int i2 = i1 + 1;

  A (strlen (a[v0]) == 1);
  A (strlen (&a[v0][v0]) == 1);
  A (strlen (&a[i0][v0]) == 1);
  A (strlen (&a[v0][i0]) == 1);

  A (strlen (a[v1]) == 2);
  A (strlen (&a[v1][i0]) == 2);
  A (strlen (&a[i1][v0]) == 2);
  A (strlen (&a[v1][v0]) == 2);

  A (strlen (&a[v1][i1]) == 1);
  A (strlen (&a[v1][i1]) == 1);

  A (strlen (&a[v1][i2]) == 0);
  A (strlen (&a[v1][v2]) == 0);
}

void test_array_off_2_3 (void)
{
  A (strlen (a[0] + 0) == 1);
  A (strlen (a[0] + v0) == 1);
  A (strlen (a[v0] + 0) == 1);
  A (strlen (a[v0] + v0) == 1);

  A (strlen (a[v1] + 0) == 2);
  A (strlen (a[1] + v0) == 2);
  A (strlen (a[v1] + 0) == 2);
  A (strlen (a[v1] + v0) == 2);

  A (strlen (a[v1] + 1) == 1);
  A (strlen (a[v1] + v1) == 1);

  A (strlen (a[v1] + 2) == 0);
  A (strlen (a[v1] + v2) == 0);

  int i0 = 0;
  int i1 = i0 + 1;
  int i2 = i1 + 1;

  A (strlen (a[i0] + i0) == 1);
  A (strlen (a[i0] + v0) == 1);
  A (strlen (a[v0] + i0) == 1);
  A (strlen (a[v0] + v0) == 1);

  A (strlen (a[v1] + i0) == 2);
  A (strlen (a[i1] + v0) == 2);
  A (strlen (a[v1] + i0) == 2);
  A (strlen (a[v1] + v0) == 2);

  A (strlen (a[v1] + i1) == 1);
  A (strlen (a[v1] + v1) == 1);

  A (strlen (a[v1] + i2) == 0);
  A (strlen (a[v1] + v2) == 0);
}

void test_array_ref_2_2_5 (void)
{
  A (strlen (b[0][v0]) == 1);
  A (strlen (b[v0][0]) == 1);

  A (strlen (&b[0][0][v0]) == 1);
  A (strlen (&b[0][v0][0]) == 1);
  A (strlen (&b[v0][0][0]) == 1);

  A (strlen (&b[0][v0][v0]) == 1);
  A (strlen (&b[v0][0][v0]) == 1);
  A (strlen (&b[v0][v0][0]) == 1);

  A (strlen (b[0][v1]) == 2);
  A (strlen (b[v1][0]) == 3);

  A (strlen (&b[0][0][v1]) == 0);
  A (strlen (&b[0][v1][0]) == 2);
  A (strlen (&b[v0][0][0]) == 1);

  A (strlen (&b[0][v0][v0]) == 1);
  A (strlen (&b[v0][0][v0]) == 1);
  A (strlen (&b[v0][v0][0]) == 1);

  A (strlen (&b[0][v1][v1]) == 1);
  A (strlen (&b[v1][0][v1]) == 2);
  A (strlen (&b[v1][v1][0]) == 4);
  A (strlen (&b[v1][v1][1]) == 3);
  A (strlen (&b[v1][v1][2]) == 2);

  int i0 = 0;
  int i1 = i0 + 1;
  int i2 = i1 + 1;

  A (strlen (b[i0][v0]) == 1);
  A (strlen (b[v0][i0]) == 1);

  A (strlen (&b[i0][i0][v0]) == 1);
  A (strlen (&b[i0][v0][i0]) == 1);
  A (strlen (&b[v0][i0][i0]) == 1);

  A (strlen (&b[i0][v0][v0]) == 1);
  A (strlen (&b[v0][i0][v0]) == 1);
  A (strlen (&b[v0][v0][i0]) == 1);

  A (strlen (b[i0][v1]) == 2);
  A (strlen (b[v1][i0]) == 3);

  A (strlen (&b[i0][i0][v1]) == 0);
  A (strlen (&b[i0][v1][i0]) == 2);
  A (strlen (&b[v0][i0][i0]) == 1);

  A (strlen (&b[i0][v0][v0]) == 1);
  A (strlen (&b[v0][i0][v0]) == 1);
  A (strlen (&b[v0][v0][i0]) == 1);

  A (strlen (&b[i0][v1][v1]) == 1);
  A (strlen (&b[v1][i0][v1]) == 2);
  A (strlen (&b[v1][v1][i0]) == 4);
  A (strlen (&b[v1][v1][i1]) == 3);
  A (strlen (&b[v1][v1][i2]) == 2);
}

void test_array_off_2_2_5 (void)
{
  A (strlen (b[0][0] + v0) == 1);
  A (strlen (b[0][v0] + v0) == 1);
  A (strlen (b[v0][0] + v0) == 1);
  A (strlen (b[v0][v0] + v0) == 1);

  A (strlen (b[0][0] + v1) == 0);
  A (strlen (b[0][v1] + 0) == 2);
  A (strlen (b[v0][0] + 0) == 1);

  A (strlen (b[0][v0] + v0) == 1);
  A (strlen (b[v0][0] + v0) == 1);
  A (strlen (b[v0][v0] + 0) == 1);

  A (strlen (b[0][v1] + v1) == 1);
  A (strlen (b[v1][0] + v1) == 2);
  A (strlen (b[v1][v1] + 0) == 4);
  A (strlen (b[v1][v1] + 1) == 3);
  A (strlen (b[v1][v1] + 2) == 2);

  int i0 = 0;
  int i1 = i0 + 1;
  int i2 = i1 + 1;

  A (strlen (b[i0][i0] + v0) == 1);
  A (strlen (b[i0][v0] + v0) == 1);
  A (strlen (b[v0][i0] + v0) == 1);
  A (strlen (b[v0][v0] + v0) == 1);

  A (strlen (b[i0][i0] + v1) == 0);
  A (strlen (b[i0][v1] + i0) == 2);
  A (strlen (b[v0][i0] + i0) == 1);

  A (strlen (b[i0][v0] + v0) == 1);
  A (strlen (b[v0][i0] + v0) == 1);
  A (strlen (b[v0][v0] + i0) == 1);

  A (strlen (b[i0][v1] + v1) == 1);
  A (strlen (b[v1][i0] + v1) == 2);
  A (strlen (b[v1][v1] + i0) == 4);
  A (strlen (b[v1][v1] + i1) == 3);
  A (strlen (b[v1][v1] + i2) == 2);
}

int main ()
{
  test_array_ref_2_3 ();
  test_array_off_2_3 ();

  test_array_ref_2_2_5 ();
  test_array_off_2_2_5 ();
}
// source: strlen-3.c
/* PR tree-optimization/86532 - Wrong code due to a wrong strlen folding
   starting with r262522
   Exercise strlen() with a multi-dimensional array of strings with
   embedded nuls.  */

extern __SIZE_TYPE__ strlen (const char*);

static const char a[2][3][9] = {
  { "1", "1\0002" },
  { "12\0003", "123\0004" }
};

volatile int v0 = 0;
volatile int v1 = 1;
volatile int v2 = 2;
volatile int v3 = 3;
volatile int v4 = 4;
volatile int v5 = 5;
volatile int v6 = 6;
volatile int v7 = 7;

#define A(expr)								\
  ((expr) ? (void)0 : (__builtin_printf ("assertion on line %i: %s\n",	\
					 __LINE__, #expr),		\
		       __builtin_abort ()))

void test_array_ref (void)
{
  int i0 = 0;
  int i1 = i0 + 1;
  int i2 = i1 + 1;
  int i3 = i2 + 1;
  int i4 = i3 + 1;
  int i5 = i4 + 1;
  int i6 = i5 + 1;
  int i7 = i6 + 1;

  A (strlen (a[0][0]) == 1);
  A (strlen (a[0][1]) == 1);

  A (strlen (a[1][0]) == 2);
  A (strlen (a[1][1]) == 3);

  A (strlen (&a[0][0][0]) == 1);
  A (strlen (&a[0][1][0]) == 1);

  A (strlen (&a[1][0][0]) == 2);
  A (strlen (&a[1][1][0]) == 3);

  A (strlen (&a[0][0][0] + 1) == 0);
  A (strlen (&a[0][1][0] + 1) == 0);
  A (strlen (&a[0][1][0] + 2) == 1);
  A (strlen (&a[0][1][0] + 3) == 0);
  A (strlen (&a[0][1][0] + 7) == 0);

  A (strlen (&a[1][0][0] + 1) == 1);
  A (strlen (&a[1][1][0] + 1) == 2);
  A (strlen (&a[1][1][0] + 2) == 1);
  A (strlen (&a[1][1][0] + 7) == 0);


  A (strlen (a[i0][i0]) == 1);
  A (strlen (a[i0][i1]) == 1);

  A (strlen (a[i1][i0]) == 2);
  A (strlen (a[i1][i1]) == 3);

  A (strlen (&a[i0][i0][i0]) == 1);
  A (strlen (&a[i0][i1][i0]) == 1);
  A (strlen (&a[i0][i1][i1]) == 0);
  A (strlen (&a[i0][i1][i2]) == 1);
  A (strlen (&a[i0][i1][i3]) == 0);
  A (strlen (&a[i0][i1][i3]) == 0);

  A (strlen (&a[i1][i0][i0]) == 2);
  A (strlen (&a[i1][i1][i0]) == 3);
  A (strlen (&a[i1][i1][i1]) == 2);
  A (strlen (&a[i1][i1][i2]) == 1);
  A (strlen (&a[i1][i1][i3]) == 0);
  A (strlen (&a[i1][i1][i4]) == 1);
  A (strlen (&a[i1][i1][i5]) == 0);
  A (strlen (&a[i1][i1][i6]) == 0);
  A (strlen (&a[i1][i1][i7]) == 0);

  A (strlen (&a[i0][i0][i0] + i1) == 0);
  A (strlen (&a[i0][i1][i0] + i1) == 0);
  A (strlen (&a[i0][i1][i0] + i7) == 0);

  A (strlen (&a[i1][i0][i0] + i1) == 1);
  A (strlen (&a[i1][i1][i0] + i1) == 2);
  A (strlen (&a[i1][i1][i0] + i2) == 1);
  A (strlen (&a[i1][i1][i0] + i3) == 0);
  A (strlen (&a[i1][i1][i0] + i4) == 1);
  A (strlen (&a[i1][i1][i0] + i5) == 0);
  A (strlen (&a[i1][i1][i0] + i6) == 0);
  A (strlen (&a[i1][i1][i0] + i7) == 0);


  A (strlen (a[i0][i0]) == 1);
  A (strlen (a[i0][i1]) == 1);

  A (strlen (a[i1][i0]) == 2);
  A (strlen (a[i1][i1]) == 3);

  A (strlen (&a[i0][i0][i0]) == 1);
  A (strlen (&a[i0][i1][i0]) == 1);

  A (strlen (&a[i1][i0][i0]) == 2);
  A (strlen (&a[i1][i1][i0]) == 3);

  A (strlen (&a[i0][i0][i0] + v1) == 0);
  A (strlen (&a[i0][i0][i0] + v2) == 0);
  A (strlen (&a[i0][i0][i0] + v7) == 0);

  A (strlen (&a[i0][i1][i0] + v1) == 0);
  A (strlen (&a[i0][i1][i0] + v2) == 1);
  A (strlen (&a[i0][i1][i0] + v3) == 0);

  A (strlen (&a[i1][i0][i0] + v1) == 1);
  A (strlen (&a[i1][i1][i0] + v1) == 2);
  A (strlen (&a[i1][i1][i0] + v2) == 1);
  A (strlen (&a[i1][i1][i0] + v3) == 0);
  A (strlen (&a[i1][i1][i0] + v4) == 1);
  A (strlen (&a[i1][i1][i0] + v5) == 0);
  A (strlen (&a[i1][i1][i0] + v6) == 0);
  A (strlen (&a[i1][i1][i0] + v7) == 0);
}

int main (void)
{
  test_array_ref ();
}
// source: strlen-4.c
/* PR tree-optimization/86622 - incorrect strlen of array of array plus
   variable offset
   Exercise strlen() with a multi-dimensional array of strings with
   offsets.  */

extern int printf (const char*, ...);
extern __SIZE_TYPE__ strlen (const char*);

typedef char A28[28];
typedef A28 A3_28[3];
typedef A3_28 A2_3_28[2];

static const A2_3_28 a = {
  /* [0][0]    [0][1]         [0][2] */
  { "1\00012", "123\0001234", "12345\000123456" },
  /* [1][0]    [1][1]         [1][2] */
  { "1234567\00012345678", "123456789\0001234567890", "12345678901\000123456789012" }
};

volatile int v0 = 0;
volatile int v1 = 1;
volatile int v2 = 2;
volatile int v3 = 3;
volatile int v4 = 4;
volatile int v5 = 5;
volatile int v6 = 6;
volatile int v7 = 7;

#define A(expr, N)							\
  ((strlen (expr) == N)							\
   ? (void)0 : (printf ("line %i: strlen (%s = \"%s\") != %i\n",	\
			__LINE__, #expr, expr, N),			\
		__builtin_abort ()))

/* Verify that strlen() involving pointer to array arguments computes
   the correct result.  */

void test_array_ptr (void)
{
  /* Compute the length of the string at the refeenced array.  */
  A (*(&a[0][0] + 0), 1);
  A (*(&a[0][0] + 1), 3);
  A (*(&a[0][0] + 2), 5);

  A (*(&a[0][1] - 1), 1);
  A (*(&a[0][1] + 0), 3);
  A (*(&a[0][1] + 1), 5);

  A (*(&a[0][2] - 2), 1);
  A (*(&a[0][2] - 1), 3);
  A (*(&a[0][2] + 0), 5);

  A (*(&a[1][0] + 0), 7);
  A (*(&a[1][0] + 1), 9);
  A (*(&a[1][0] + 2), 11);

  A (*(&a[1][1] - 1), 7);
  A (*(&a[1][1] + 0), 9);
  A (*(&a[1][1] + 1), 11);

  A (*(&a[1][2] - 2), 7);
  A (*(&a[1][2] - 1), 9);
  A (*(&a[1][2] - 0), 11);

  /* Compute the length of the string past the first nul.  */
  A (*(&a[0][0] + 0) + 2, 2);
  A (*(&a[0][0] + 1) + 4, 4);
  A (*(&a[0][0] + 2) + 6, 6);

  /* Compute the length of the string past the second nul.  */
  A (*(&a[0][0] + 0) + 5, 0);
  A (*(&a[0][0] + 1) + 10, 0);
  A (*(&a[0][0] + 2) + 14, 0);

  int i0 = 0;
  int i1 = i0 + 1;
  int i2 = i1 + 1;
  int i3 = i2 + 1;
  int i4 = i3 + 1;
  int i5 = i4 + 1;

  A (*(&a[0][0] + i0), 1);
  A (*(&a[0][0] + i1), 3);
  A (*(&a[0][0] + i2), 5);

  A (*(&a[0][1] - i1), 1);
  A (*(&a[0][1] + i0), 3);
  A (*(&a[0][1] + i1), 5);

  A (*(&a[0][2] - i2), 1);
  A (*(&a[0][2] - i1), 3);
  A (*(&a[0][2] + i0), 5);

  A (*(&a[1][0] + i0), 7);
  A (*(&a[1][0] + i1), 9);
  A (*(&a[1][0] + i2), 11);

  A (*(&a[1][1] - i1), 7);
  A (*(&a[1][1] + i0), 9);
  A (*(&a[1][1] + i1), 11);

  A (*(&a[1][2] - i2), 7);
  A (*(&a[1][2] - i1), 9);
  A (*(&a[1][2] - i0), 11);


  A (*(&a[i0][i0] + i0), 1);
  A (*(&a[i0][i0] + i1), 3);
  A (*(&a[i0][i0] + i2), 5);

  A (*(&a[i0][i1] - i1), 1);
  A (*(&a[i0][i1] + i0), 3);
  A (*(&a[i0][i1] + i1), 5);

  A (*(&a[i0][i2] - i2), 1);
  A (*(&a[i0][i2] - i1), 3);
  A (*(&a[i0][i2] + i0), 5);

  A (*(&a[i1][i0] + i0), 7);
  A (*(&a[i1][i0] + i1), 9);
  A (*(&a[i1][i0] + i2), 11);

  A (*(&a[i1][i1] - i1), 7);
  A (*(&a[i1][i1] + i0), 9);
  A (*(&a[i1][i1] + i1), 11);

  A (*(&a[i1][i2] - i2), 7);
  A (*(&a[i1][i2] - i1), 9);
  A (*(&a[i1][i2] - i0), 11);


  A (*(&a[i0][i0] + v0), 1);
  A (*(&a[i0][i0] + v1), 3);
  A (*(&a[i0][i0] + v2), 5);

  A (*(&a[i0][i1] - v1), 1);
  A (*(&a[i0][i1] + v0), 3);
  A (*(&a[i0][i1] + v1), 5);

  A (*(&a[i0][i2] - v2), 1);
  A (*(&a[i0][i2] - v1), 3);
  A (*(&a[i0][i2] + v0), 5);

  A (*(&a[i1][i0] + v0), 7);
  A (*(&a[i1][i0] + v1), 9);
  A (*(&a[i1][i0] + v2), 11);

  A (*(&a[i1][i1] - v1), 7);
  A (*(&a[i1][i1] + v0), 9);
  A (*(&a[i1][i1] + v1), 11);

  A (*(&a[i1][i2] - v2), 7);
  A (*(&a[i1][i2] - v1), 9);
  A (*(&a[i1][i2] - v0), 11);


  A (*(&a[i0][i0] + v0) + i1, 0);
  A (*(&a[i0][i0] + v1) + i2, 1);
  A (*(&a[i0][i0] + v2) + i3, 2);

  A (*(&a[i0][i1] - v1) + v1, 0);
  A (*(&a[i0][i1] + v0) + v3, 0);
  A (*(&a[i0][i1] + v1) + v5, 0);

  A (*(&a[i0][v1] - i1) + i1, 0);
  A (*(&a[i0][v1] + i0) + i3, 0);
  A (*(&a[i0][v1] + i1) + i5, 0);
}

static const A3_28* const pa0 = &a[0];
static const A3_28* const pa1 = &a[1];

static const A3_28* const paa[] = { &a[0], &a[1] };

/* Verify that strlen() involving pointers and arrays of pointers
   to array arguments computes the correct result.  */

void test_ptr_array (void)
{
  int i0 = 0;
  int i1 = i0 + 1;
  int i2 = i1 + 1;
  int i3 = i2 + 1;

  A (*((*pa0) + i0), 1);
  A (*((*pa0) + i1), 3);
  A (*((*pa0) + i2), 5);

  A (*(pa0[0] + i0), 1);
  A (*(pa0[0] + i1), 3);
  A (*(pa0[0] + i2), 5);

  A ((*pa0)[i0] + i1, 0);
  A ((*pa0)[i1] + i2, 1);
  A ((*pa0)[i2] + i3, 2);


  A (*((*pa1) + i0), 7);
  A (*((*pa1) + i1), 9);
  A (*((*pa1) + i2), 11);

  A (*(pa1[0] + i0), 7);
  A (*(pa1[0] + i1), 9);
  A (*(pa1[0] + i2), 11);

  A ((*pa1)[i0] + i1, 6);
  A ((*pa1)[i1] + i2, 7);
  A ((*pa1)[i2] + i3, 8);

  A (*(*(paa[0]) + i0), 1);
  A (*(*(paa[0]) + i1), 3);
  A (*(*(paa[0]) + i2), 5);

  A (*(*(paa[1]) + i0), 7);
  A (*(*(paa[1]) + i1), 9);
  A (*(*(paa[1]) + i2), 11);

  A (*(*(paa[1]) - i1), 5);
  A (*(*(paa[1]) - i2), 3);
  A (*(*(paa[1]) - i3), 1);

  A (*(*(paa[0]) + i0) + i1, 0);
  A (*(*(paa[0]) + i1) + i2, 1);
  A (*(*(paa[0]) + i2) + i3, 2);
}

int main (void)
{
  test_array_ptr ();

  test_ptr_array ();
}
// source: strlen-5.c
/* Test to verify that even strictly undefined strlen() calls with
   unterminated character arrays yield the "expected" results when
   the terminating nul is present in a subsequent suobobject.  */

extern __SIZE_TYPE__ strlen (const char *);

unsigned nfails;

#define A(expr, N)						\
  do {								\
    const char *s = (expr);					\
    unsigned n = strlen (s);					\
    ((n == N)							\
     ? 0							\
     : (__builtin_printf ("line %i: strlen (%s = \"%s\")"	\
			  " == %u failed\n",			\
			  __LINE__, #expr, s, N),		\
	++nfails));						\
  } while (0)


int idx;


const char ca[][4] = {
  { '1', '2', '3', '4' }, { '5' },
  { '1', '2', '3', '4' }, { '5', '6' },
  { '1', '2', '3', '4' }, { '5', '6', '7' },
  { '1', '2', '3', '4' }, { '5', '6', '7', '8' },
  { '9' }
};

static void test_const_global_arrays (void)
{
  A (ca[0], 5);
  A (&ca[0][0], 5);
  A (&ca[0][1], 4);
  A (&ca[0][3], 2);

  int i = 0;
  A (ca[i], 5);
  A (&ca[i][0], 5);
  A (&ca[i][1], 4);
  A (&ca[i][3], 2);

  int j = i;
  A (&ca[i][i], 5);
  A (&ca[i][j + 1], 4);
  A (&ca[i][j + 2], 3);

  A (&ca[idx][i], 5);
  A (&ca[idx][j + 1], 4);
  A (&ca[idx][j + 2], 3);

  A (&ca[idx][idx], 5);
  A (&ca[idx][idx + 1], 4);
  A (&ca[idx][idx + 2], 3);

  A (&ca[0][++j], 4);
  A (&ca[0][++j], 3);
  A (&ca[0][++j], 2);

  if (j != 3)
    ++nfails;
}


static void test_const_local_arrays (void)
{
  const char a[][4] = {
    { '1', '2', '3', '4' }, { '5' },
    { '1', '2', '3', '4' }, { '5', '6' },
    { '1', '2', '3', '4' }, { '5', '6', '7' },
    { '1', '2', '3', '4' }, { '5', '6', '7', '8' },
    { '9' }
  };

  A (a[0], 5);
  A (&a[0][0], 5);
  A (&a[0][1], 4);
  A (&a[0][3], 2);

  int i = 0;
  A (a[i], 5);
  A (&a[i][0], 5);
  A (&a[i][1], 4);
  A (&a[i][3], 2);

  int j = i;
  A (&a[i][i], 5);
  A (&a[i][j + 1], 4);
  A (&a[i][j + 2], 3);

  A (&a[idx][i], 5);
  A (&a[idx][j + 1], 4);
  A (&a[idx][j + 2], 3);

  A (&a[idx][idx], 5);
  A (&a[idx][idx + 1], 4);
  A (&a[idx][idx + 2], 3);

  A (&a[0][++j], 4);
  A (&a[0][++j], 3);
  A (&a[0][++j], 2);

  if (j != 3)
    ++nfails;
}


char va[][4] = {
  { '1', '2', '3', '4' }, { '5' },
  { '1', '2', '3', '4' }, { '5', '6' },
  { '1', '2', '3', '4' }, { '5', '6', '7' },
  { '1', '2', '3', '4' }, { '5', '6', '7', '8' },
  { '9' }
};

static void test_nonconst_global_arrays (void)
{
  {
    A (va[0], 5);
    A (&va[0][0], 5);
    A (&va[0][1], 4);
    A (&va[0][3], 2);

    int i = 0;
    A (va[i], 5);
    A (&va[i][0], 5);
    A (&va[i][1], 4);
    A (&va[i][3], 2);

    int j = i;
    A (&va[i][i], 5);
    A (&va[i][j + 1], 4);
    A (&va[i][j + 2], 3);

    A (&va[idx][i], 5);
    A (&va[idx][j + 1], 4);
    A (&va[idx][j + 2], 3);

    A (&va[idx][idx], 5);
    A (&va[idx][idx + 1], 4);
    A (&va[idx][idx + 2], 3);
  }

  {
    A (va[2], 6);
    A (&va[2][0], 6);
    A (&va[2][1], 5);
    A (&va[2][3], 3);

    int i = 2;
    A (va[i], 6);
    A (&va[i][0], 6);
    A (&va[i][1], 5);
    A (&va[i][3], 3);

    int j = i - 1;
    A (&va[i][j - 1], 6);
    A (&va[i][j], 5);
    A (&va[i][j + 1], 4);

    A (&va[idx + 2][i - 1], 5);
    A (&va[idx + 2][j], 5);
    A (&va[idx + 2][j + 1], 4);
  }

  int j = 0;

  A (&va[0][++j], 4);
  A (&va[0][++j], 3);
  A (&va[0][++j], 2);

  if (j != 3)
    ++nfails;
}


static void test_nonconst_local_arrays (void)
{
  char a[][4] = {
    { '1', '2', '3', '4' }, { '5' },
    { '1', '2', '3', '4' }, { '5', '6' },
    { '1', '2', '3', '4' }, { '5', '6', '7' },
    { '1', '2', '3', '4' }, { '5', '6', '7', '8' },
    { '9' }
  };

  A (a[0], 5);
  A (&a[0][0], 5);
  A (&a[0][1], 4);
  A (&a[0][3], 2);

  int i = 0;
  A (a[i], 5);
  A (&a[i][0], 5);
  A (&a[i][1], 4);
  A (&a[i][3], 2);

  int j = i;
  A (&a[i][i], 5);
  A (&a[i][j + 1], 4);
  A (&a[i][j + 2], 3);

  A (&a[idx][i], 5);
  A (&a[idx][j + 1], 4);
  A (&a[idx][j + 2], 3);

  A (&a[idx][idx], 5);
  A (&a[idx][idx + 1], 4);
  A (&a[idx][idx + 2], 3);

  A (&a[0][++j], 4);
  A (&a[0][++j], 3);
  A (&a[0][++j], 2);

  if (j != 3)
    ++nfails;
}


struct MemArrays { char a[4], b[4]; };

const struct MemArrays cma[] = {
  { { '1', '2', '3', '4' }, { '5' } },
  { { '1', '2', '3', '4' }, { '5', '6' } },
  { { '1', '2', '3', '4' }, { '5', '6' } },
  { { '1', '2', '3', '4' }, { '5', '6', '7' } },
  { { '1', '2', '3', '4' }, { '5', '6', '7', '8' } },
  { { '9' }, { '\0' } }
};

static void test_const_global_member_arrays (void)
{
  {
    A (cma[0].a, 5);
    A (&cma[0].a[0], 5);
    A (&cma[0].a[1], 4);
    A (&cma[0].a[2], 3);

    int i = 0;
    A (cma[i].a, 5);
    A (&cma[i].a[0], 5);
    A (&cma[i].a[1], 4);
    A (&cma[i].a[2], 3);

    int j = i;
    A (&cma[i].a[j], 5);
    A (&cma[i].a[j + 1], 4);
    A (&cma[i].a[j + 2], 3);

    A (&cma[idx].a[i], 5);
    A (&cma[idx].a[j + 1], 4);
    A (&cma[idx].a[j + 2], 3);

    A (&cma[idx].a[idx], 5);
    A (&cma[idx].a[idx + 1], 4);
    A (&cma[idx].a[idx + 2], 3);
  }

  {
    A (cma[1].a, 6);
    A (&cma[1].a[0], 6);
    A (&cma[1].a[1], 5);
    A (&cma[1].a[2], 4);

    int i = 1;
    A (cma[i].a, 6);
    A (&cma[i].a[0], 6);
    A (&cma[i].a[1], 5);
    A (&cma[i].a[2], 4);

    int j = i - 1;
    A (&cma[i].a[j], 6);
    A (&cma[i].a[j + 1], 5);
    A (&cma[i].a[j + 2], 4);

    A (&cma[idx + 1].a[j], 6);
    A (&cma[idx + 1].a[j + 1], 5);
    A (&cma[idx + 1].a[j + 2], 4);

    A (&cma[idx + 1].a[idx], 6);
    A (&cma[idx + 1].a[idx + 1], 5);
    A (&cma[idx + 1].a[idx + 2], 4);
  }

  {
    A (cma[4].a, 9);
    A (&cma[4].a[0], 9);
    A (&cma[4].a[1], 8);
    A (&cma[4].b[0], 5);

    int i = 4;
    A (cma[i].a, 9);
    A (&cma[i].a[0], 9);
    A (&cma[i].a[1], 8);
    A (&cma[i].b[0], 5);

    int j = i - 1;
    A (&cma[i].a[j], 6);
    A (&cma[i].a[j + 1], 5);
    A (&cma[i].b[j - 2], 4);

    A (&cma[idx + 4].a[j], 6);
    A (&cma[idx + 4].a[j + 1], 5);
    A (&cma[idx + 4].b[j - 2], 4);

    A (&cma[idx + 4].a[idx], 9);
    A (&cma[idx + 4].a[idx + 1], 8);
    A (&cma[idx + 4].b[idx + 1], 4);
  }
}


static void test_const_local_member_arrays (void)
{
  const struct MemArrays ma[] = {
    { { '1', '2', '3', '4' }, { '5' } },
    { { '1', '2', '3', '4' }, { '5', '6' } },
    { { '1', '2', '3', '4' }, { '5', '6' } },
    { { '1', '2', '3', '4' }, { '5', '6', '7' } },
    { { '1', '2', '3', '4' }, { '5', '6', '7', '8' } },
    { { '9' }, { '\0' } }
  };

  {
    A (ma[0].a, 5);
    A (&ma[0].a[0], 5);
    A (&ma[0].a[1], 4);
    A (&ma[0].a[2], 3);

    int i = 0;
    A (ma[i].a, 5);
    A (&ma[i].a[0], 5);
    A (&ma[i].a[1], 4);
    A (&ma[i].a[2], 3);

    int j = i;
    A (&ma[i].a[j], 5);
    A (&ma[i].a[j + 1], 4);
    A (&ma[i].a[j + 2], 3);

    A (&ma[idx].a[i], 5);
    A (&ma[idx].a[j + 1], 4);
    A (&ma[idx].a[j + 2], 3);

    A (&ma[idx].a[idx], 5);
    A (&ma[idx].a[idx + 1], 4);
    A (&ma[idx].a[idx + 2], 3);
  }

  {
    A (ma[1].a, 6);
    A (&ma[1].a[0], 6);
    A (&ma[1].a[1], 5);
    A (&ma[1].a[2], 4);

    int i = 1;
    A (ma[i].a, 6);
    A (&ma[i].a[0], 6);
    A (&ma[i].a[1], 5);
    A (&ma[i].a[2], 4);

    int j = i - 1;
    A (&ma[i].a[j], 6);
    A (&ma[i].a[j + 1], 5);
    A (&ma[i].a[j + 2], 4);

    A (&ma[idx + 1].a[j], 6);
    A (&ma[idx + 1].a[j + 1], 5);
    A (&ma[idx + 1].a[j + 2], 4);

    A (&ma[idx + 1].a[idx], 6);
    A (&ma[idx + 1].a[idx + 1], 5);
    A (&ma[idx + 1].a[idx + 2], 4);
  }

  {
    A (ma[4].a, 9);
    A (&ma[4].a[0], 9);
    A (&ma[4].a[1], 8);
    A (&ma[4].b[0], 5);

    int i = 4;
    A (ma[i].a, 9);
    A (&ma[i].a[0], 9);
    A (&ma[i].a[1], 8);
    A (&ma[i].b[0], 5);

    int j = i - 1;
    A (&ma[i].a[j], 6);
    A (&ma[i].a[j + 1], 5);
    A (&ma[i].b[j - 2], 4);

    A (&ma[idx + 4].a[j], 6);
    A (&ma[idx + 4].a[j + 1], 5);
    A (&ma[idx + 4].b[j - 2], 4);

    A (&ma[idx + 4].a[idx], 9);
    A (&ma[idx + 4].a[idx + 1], 8);
    A (&ma[idx + 4].b[idx + 1], 4);
  }
}

struct MemArrays vma[] = {
  { { '1', '2', '3', '4' }, { '5' } },
  { { '1', '2', '3', '4' }, { '5', '6' } },
  { { '1', '2', '3', '4' }, { '5', '6' } },
  { { '1', '2', '3', '4' }, { '5', '6', '7' } },
  { { '1', '2', '3', '4' }, { '5', '6', '7', '8' } },
  { { '9' }, { '\0' } }
};

static void test_nonconst_global_member_arrays (void)
{
  {
    A (vma[0].a, 5);
    A (&vma[0].a[0], 5);
    A (&vma[0].a[1], 4);
    A (&vma[0].a[2], 3);

    int i = 0;
    A (vma[i].a, 5);
    A (&vma[i].a[0], 5);
    A (&vma[i].a[1], 4);
    A (&vma[i].a[2], 3);

    int j = i;
    A (&vma[i].a[j], 5);
    A (&vma[i].a[j + 1], 4);
    A (&vma[i].a[j + 2], 3);

    A (&vma[idx].a[i], 5);
    A (&vma[idx].a[j + 1], 4);
    A (&vma[idx].a[j + 2], 3);

    A (&vma[idx].a[idx], 5);
    A (&vma[idx].a[idx + 1], 4);
    A (&vma[idx].a[idx + 2], 3);
  }

  {
    A (vma[1].a, 6);
    A (&vma[1].a[0], 6);
    A (&vma[1].a[1], 5);
    A (&vma[1].a[2], 4);

    int i = 1;
    A (vma[i].a, 6);
    A (&vma[i].a[0], 6);
    A (&vma[i].a[1], 5);
    A (&vma[i].a[2], 4);

    int j = i - 1;
    A (&vma[i].a[j], 6);
    A (&vma[i].a[j + 1], 5);
    A (&vma[i].a[j + 2], 4);

    A (&vma[idx + 1].a[j], 6);
    A (&vma[idx + 1].a[j + 1], 5);
    A (&vma[idx + 1].a[j + 2], 4);

    A (&vma[idx + 1].a[idx], 6);
    A (&vma[idx + 1].a[idx + 1], 5);
    A (&vma[idx + 1].a[idx + 2], 4);
  }

  {
    A (vma[4].a, 9);
    A (&vma[4].a[0], 9);
    A (&vma[4].a[1], 8);
    A (&vma[4].b[0], 5);

    int i = 4;
    A (vma[i].a, 9);
    A (&vma[i].a[0], 9);
    A (&vma[i].a[1], 8);
    A (&vma[i].b[0], 5);

    int j = i - 1;
    A (&vma[i].a[j], 6);
    A (&vma[i].a[j + 1], 5);
    A (&vma[i].b[j - 2], 4);

    A (&vma[idx + 4].a[j], 6);
    A (&vma[idx + 4].a[j + 1], 5);
    A (&vma[idx + 4].b[j - 2], 4);

    A (&vma[idx + 4].a[idx], 9);
    A (&vma[idx + 4].a[idx + 1], 8);
    A (&vma[idx + 4].b[idx + 1], 4);
  }
}


static void test_nonconst_local_member_arrays (void)
{
  struct MemArrays ma[] = {
    { { '1', '2', '3', '4' }, { '5' } },
    { { '1', '2', '3', '4' }, { '5', '6' } },
    { { '1', '2', '3', '4' }, { '5', '6' } },
    { { '1', '2', '3', '4' }, { '5', '6', '7' } },
    { { '1', '2', '3', '4' }, { '5', '6', '7', '8' } },
    { { '9' }, { '\0' } }
  };

  {
    A (ma[0].a, 5);
    A (&ma[0].a[0], 5);
    A (&ma[0].a[1], 4);
    A (&ma[0].a[2], 3);

    int i = 0;
    A (ma[i].a, 5);
    A (&ma[i].a[0], 5);
    A (&ma[i].a[1], 4);
    A (&ma[i].a[2], 3);

    int j = i;
    A (&ma[i].a[j], 5);
    A (&ma[i].a[j + 1], 4);
    A (&ma[i].a[j + 2], 3);

    A (&ma[idx].a[i], 5);
    A (&ma[idx].a[j + 1], 4);
    A (&ma[idx].a[j + 2], 3);

    A (&ma[idx].a[idx], 5);
    A (&ma[idx].a[idx + 1], 4);
    A (&ma[idx].a[idx + 2], 3);
  }

  {
    A (ma[1].a, 6);
    A (&ma[1].a[0], 6);
    A (&ma[1].a[1], 5);
    A (&ma[1].a[2], 4);

    int i = 1;
    A (ma[i].a, 6);
    A (&ma[i].a[0], 6);
    A (&ma[i].a[1], 5);
    A (&ma[i].a[2], 4);

    int j = i - 1;
    A (&ma[i].a[j], 6);
    A (&ma[i].a[j + 1], 5);
    A (&ma[i].a[j + 2], 4);

    A (&ma[idx + 1].a[j], 6);
    A (&ma[idx + 1].a[j + 1], 5);
    A (&ma[idx + 1].a[j + 2], 4);

    A (&ma[idx + 1].a[idx], 6);
    A (&ma[idx + 1].a[idx + 1], 5);
    A (&ma[idx + 1].a[idx + 2], 4);
  }

  {
    A (ma[4].a, 9);
    A (&ma[4].a[0], 9);
    A (&ma[4].a[1], 8);
    A (&ma[4].b[0], 5);

    int i = 4;
    A (ma[i].a, 9);
    A (&ma[i].a[0], 9);
    A (&ma[i].a[1], 8);
    A (&ma[i].b[0], 5);

    int j = i - 1;
    A (&ma[i].a[j], 6);
    A (&ma[i].a[j + 1], 5);
    A (&ma[i].b[j - 2], 4);

    A (&ma[idx + 4].a[j], 6);
    A (&ma[idx + 4].a[j + 1], 5);
    A (&ma[idx + 4].b[j - 2], 4);

    A (&ma[idx + 4].a[idx], 9);
    A (&ma[idx + 4].a[idx + 1], 8);
    A (&ma[idx + 4].b[idx + 1], 4);
  }
}


union UnionMemberArrays
{
  struct { char a[4], b[4]; } a;
  struct { char a[8]; } c;
};

const union UnionMemberArrays cu = {
  { { '1', '2', '3', '4' }, { '5', } }
};

static void test_const_union_member_arrays (void)
{
  A (cu.a.a, 5);
  A (cu.a.b, 1);
  A (cu.c.a, 5);

  const union UnionMemberArrays clu = {
    { { '1', '2', '3', '4' }, { '5', '6' } }
  };

  A (clu.a.a, 6);
  A (clu.a.b, 2);
  A (clu.c.a, 6);
}


union UnionMemberArrays vu = {
  { { '1', '2', '3', '4' }, { '5', '6' } }
};

static void test_nonconst_union_member_arrays (void)
{
  A (vu.a.a, 6);
  A (vu.a.b, 2);
  A (vu.c.a, 6);

  union UnionMemberArrays lvu = {
    { { '1', '2', '3', '4' }, { '5', '6', '7' } }
  };

  A (lvu.a.a, 7);
  A (lvu.a.b, 3);
  A (lvu.c.a, 7);
}


int main (void)
{
  test_const_global_arrays ();
  test_const_local_arrays ();

  test_nonconst_global_arrays ();
  test_nonconst_local_arrays ();

  test_const_global_member_arrays ();
  test_const_local_member_arrays ();

  test_nonconst_global_member_arrays ();
  test_nonconst_local_member_arrays ();

  test_const_union_member_arrays ();
  test_nonconst_union_member_arrays ();

  if (nfails)
    __builtin_abort ();
}
// source: strlen-6.c
/* Test to verify that strlen() calls with conditional expressions
   and unterminated arrays or pointers to such things as arguments
   are evaluated without making assumptions about array sizes.  */

extern __SIZE_TYPE__ strlen (const char *);

unsigned nfails;

#define A(expr, N)						\
  do {								\
    const char *_s = (expr);					\
    unsigned _n = strlen (_s);					\
    ((_n == N)							\
     ? 0							\
     : (__builtin_printf ("line %i: strlen ((%s) = (\"%s\"))"	\
			  " == %u failed\n",			\
			  __LINE__, #expr, _s, N),		\
	++nfails));						\
  } while (0)


volatile int i0 = 0;

const char ca[2][3] = { "12" };
const char cb[2][3] = { { '1', '2', '3', }, { '4' } };

char va[2][3] = { "123" };
char vb[2][3] = { { '1', '2', '3', }, { '4', '5' } };

const char *s = "123456";


static void test_binary_cond_expr_global (void)
{
  A (i0 ? "1" : ca[0], 2);
  A (i0 ? ca[0] : "123", 3);

  /* The call to strlen (cb[0]) is strictly undefined because the array
     isn't nul-terminated.  This test verifies that the strlen range
     optimization doesn't assume that the argument is necessarily nul
     terminated.
     Ditto for strlen (vb[0]).  */
  A (i0 ? "1" : cb[0], 4);              /* GCC 8.2 failure */
  A (i0 ? cb[0] : "12", 2);

  A (i0 ? "1" : va[0], 3);              /* GCC 8.2 failure */
  A (i0 ? va[0] : "1234", 4);

  A (i0 ? "1" : vb[0], 5);              /* GCC 8.2 failure */
  A (i0 ? vb[0] : "12", 2);
}


static void test_binary_cond_expr_local (void)
{
  const char lca[2][3] = { "12" };
  const char lcb[2][3] = { { '1', '2', '3', }, { '4' } };

  char lva[2][3] = { "123" };
  char lvb[2][3] = { { '1', '2', '3', }, { '4', '5' } };

  /* Also undefined as above.  */
  A (i0 ? "1" : lca[0], 2);
  A (i0 ? lca[0] : "123", 3);

  A (i0 ? "1" : lcb[0], 4);             /* GCC 8.2 failure */
  A (i0 ? lcb[0] : "12", 2);

  A (i0 ? "1" : lva[0], 3);             /* GCC 8.2 failure */
  A (i0 ? lva[0] : "1234", 4);

  A (i0 ? "1" : lvb[0], 5);             /* GCC 8.2 failure */
  A (i0 ? lvb[0] : "12", 2);
}


static void test_ternary_cond_expr (void)
{
  /* Also undefined.  */
  A (i0 == 0 ? s : i0 == 1 ? vb[0] : "123", 6);
  A (i0 == 0 ? vb[0] : i0 == 1 ? s : "123", 5);
  A (i0 == 0 ? "123" : i0 == 1 ? s : vb[0], 3);
}


const char (*pca)[3] = &ca[0];
const char (*pcb)[3] = &cb[0];

char (*pva)[3] = &va[0];
char (*pvb)[3] = &vb[0];

static void test_binary_cond_expr_arrayptr (void)
{
  /* Also undefined.  */
  A (i0 ? *pca : *pcb, 4);              /* GCC 8.2 failure */
  A (i0 ? *pcb : *pca, 2);

  A (i0 ? *pva : *pvb, 5);              /* GCC 8.2 failure */
  A (i0 ? *pvb : *pva, 3);
}


int main (void)
{
  test_binary_cond_expr_global ();
  test_binary_cond_expr_local ();

  test_ternary_cond_expr ();
  test_binary_cond_expr_arrayptr ();

  if (nfails)
    __builtin_abort ();
}
// source: strlen-7.c
/* Test to verify that a strlen() call with a pointer to a dynamic type
   doesn't make assumptions based on the static type of the original
   pointer.  See g++.dg/init/strlen.C for the corresponding C++ test.  */

struct A { int i; char a[1]; void (*p)(); };
struct B { char a[sizeof (struct A) - __builtin_offsetof (struct A, a)]; };

__attribute__ ((noipa)) void
init (char *d, const char *s)
{
  __builtin_strcpy (d, s);
}

struct B b;

__attribute__ ((noipa)) void
test_dynamic_type (struct A *p)
{
  /* The following call is undefined because it writes past the end
     of the p->a subobject, but the corresponding GIMPLE considers
     it valid and there's apparently no way to distinguish invalid
     cases from ones like it that might be valid.  If/when GIMPLE
     changes to make this possible this test can be removed.  */
  char *q = (char*)__builtin_memcpy (p->a, &b, sizeof b);

  init (q, "foobar");

  if (6 != __builtin_strlen (q))
    __builtin_abort();
}

int main (void)
{
  struct A *p = (struct A*)__builtin_malloc (sizeof *p);
  test_dynamic_type (p);
  return 0;
}
// source: strncmp-1.c
/* { dg-xfail-if "kernel strncmp does not perform unsigned comparisons" { vxworks_kernel } } */
/* Copyright (C) 2002  Free Software Foundation.

   Test strncmp with various combinations of pointer alignments and lengths to
   make sure any optimizations in the library are correct.

   Written by Michael Meissner, March 9, 2002.  */

#include <string.h>
#include <stddef.h>

#ifndef MAX_OFFSET
#define MAX_OFFSET (sizeof (long long))
#endif

#ifndef MAX_TEST
#define MAX_TEST (8 * sizeof (long long))
#endif

#ifndef MAX_EXTRA
#define MAX_EXTRA (sizeof (long long))
#endif

#define MAX_LENGTH (MAX_OFFSET + MAX_TEST + MAX_EXTRA)

static union {
  unsigned char buf[MAX_LENGTH];
  long long align_int;
  long double align_fp;
} u1, u2;

void
test (const unsigned char *s1, const unsigned char *s2, size_t len, int expected)
{
  int value = strncmp ((char *) s1, (char *) s2, len);

  if (expected < 0 && value >= 0)
    abort ();
  else if (expected == 0 && value != 0)
    abort ();
  else if (expected > 0 && value <= 0)
    abort ();
}

main ()
{
  size_t off1, off2, len, i;
  unsigned char *buf1, *buf2;
  unsigned char *mod1, *mod2;
  unsigned char *p1, *p2;

  for (off1 = 0; off1 < MAX_OFFSET; off1++)
    for (off2 = 0; off2 < MAX_OFFSET; off2++)
      for (len = 0; len < MAX_TEST; len++)
	{
	  p1 = u1.buf;
	  for (i = 0; i < off1; i++)
	    *p1++ = '\0';

	  buf1 = p1;
	  for (i = 0; i < len; i++)
	    *p1++ = 'a';

	  mod1 = p1;
	  for (i = 0; i < MAX_EXTRA; i++)
	    *p1++ = 'x';

	  p2 = u2.buf;
	  for (i = 0; i < off2; i++)
	    *p2++ = '\0';

	  buf2 = p2;
	  for (i = 0; i < len; i++)
	    *p2++ = 'a';

	  mod2 = p2;
	  for (i = 0; i < MAX_EXTRA; i++)
	    *p2++ = 'x';

	  mod1[0] = '\0';
	  mod2[0] = '\0';
	  test (buf1, buf2, MAX_LENGTH, 0);
	  test (buf1, buf2, len, 0);

	  mod1[0] = 'a';
	  mod1[1] = '\0';
	  mod2[0] = '\0';
	  test (buf1, buf2, MAX_LENGTH, +1);
	  test (buf1, buf2, len, 0);

	  mod1[0] = '\0';
	  mod2[0] = 'a';
	  mod2[1] = '\0';
	  test (buf1, buf2, MAX_LENGTH, -1);
	  test (buf1, buf2, len, 0);

	  mod1[0] = 'b';
	  mod1[1] = '\0';
	  mod2[0] = 'c';
	  mod2[1] = '\0';
	  test (buf1, buf2, MAX_LENGTH, -1);
	  test (buf1, buf2, len, 0);

	  mod1[0] = 'c';
	  mod1[1] = '\0';
	  mod2[0] = 'b';
	  mod2[1] = '\0';
	  test (buf1, buf2, MAX_LENGTH, +1);
	  test (buf1, buf2, len, 0);

	  mod1[0] = 'b';
	  mod1[1] = '\0';
	  mod2[0] = (unsigned char)'\251';
	  mod2[1] = '\0';
	  test (buf1, buf2, MAX_LENGTH, -1);
	  test (buf1, buf2, len, 0);

	  mod1[0] = (unsigned char)'\251';
	  mod1[1] = '\0';
	  mod2[0] = 'b';
	  mod2[1] = '\0';
	  test (buf1, buf2, MAX_LENGTH, +1);
	  test (buf1, buf2, len, 0);

	  mod1[0] = (unsigned char)'\251';
	  mod1[1] = '\0';
	  mod2[0] = (unsigned char)'\252';
	  mod2[1] = '\0';
	  test (buf1, buf2, MAX_LENGTH, -1);
	  test (buf1, buf2, len, 0);

	  mod1[0] = (unsigned char)'\252';
	  mod1[1] = '\0';
	  mod2[0] = (unsigned char)'\251';
	  mod2[1] = '\0';
	  test (buf1, buf2, MAX_LENGTH, +1);
	  test (buf1, buf2, len, 0);
	}

  exit (0);
}
// source: struct-aliasing-1.c
struct S { float f; };
int __attribute__((noinline))
foo (int *r, struct S *p)
{
  int *q = (int *)&p->f;
  int i = *q;
  *r = 0;
  return i + *q;
}
extern void abort (void);
int main()
{
  int i = 1;
  if (foo (&i, (struct S *)&i) != 1)
    abort ();
  return (0);
}
// source: struct-cpy-1.c
/* powerpc64-linux gcc miscompiled this due to rs6000.c:expand_block_move
   not setting mem aliasing info correctly for the code implementing the
   structure assignment.  */

struct termios
{
  unsigned int a;
  unsigned int b;
  unsigned int c;
  unsigned int d;
  unsigned char pad[28];
};

struct tty_driver
{
  unsigned char pad1[38];
  struct termios t __attribute__ ((aligned (8)));
};

static struct termios zero_t;
static struct tty_driver pty;

void ini (void)
{
  pty.t = zero_t;
  pty.t.a = 1;
  pty.t.b = 2;
  pty.t.c = 3;
  pty.t.d = 4;
}

int main (void)
{
  extern void abort (void);

  ini ();
  if (pty.t.a != 1
      || pty.t.b != 2
      || pty.t.c != 3
      || pty.t.d != 4)
    abort ();
  return 0;
}
// source: struct-ini-1.c
struct S
{
  char f1;
  int f2[2];
};

struct S object = {'X', 8, 9};

main ()
{
  if (object.f1 != 'X' || object.f2[0] != 8 || object.f2[1] != 9)
    abort ();
  exit (0);
}
// source: struct-ini-2.c
struct {
  int a:4;
  int :4;
  int b:4;
  int c:4;
} x = { 2,3,4 };

main ()
{
  if (x.a != 2)
    abort ();
  if (x.b != 3)
    abort ();
  if (x.c != 4)
    abort ();
  exit (0);
}
// source: struct-ini-3.c
struct
{
  unsigned int f1:1, f2:1, f3:3, f4:3, f5:2, f6:1, f7:1;
} result = {1, 1, 7, 7, 3, 1, 1};

main ()
{
  if ((result.f3 & ~7) != 0 || (result.f4 & ~7) != 0)
    abort ();
  exit (0);
}
// source: struct-ini-4.c
struct s {
  int a[3];
  int c[3];
};

struct s s = {
  c: {1, 2, 3}
};

main()
{
  if (s.c[0] != 1)
    abort ();
  exit (0);
}
// source: struct-ret-1.c
#include <stdio.h>
#include <string.h>

char out[100];

typedef struct { double d; int i[3]; } B;
typedef struct { char c[33],c1; } X;

char c1 = 'a';
char c2 = 127;
char c3 = (char)128;
char c4 = (char)255;
char c5 = -1;

double d1 = 0.1;
double d2 = 0.2;
double d3 = 0.3;
double d4 = 0.4;
double d5 = 0.5;
double d6 = 0.6;
double d7 = 0.7;
double d8 = 0.8;
double d9 = 0.9;

B B1 = {0.1,{1,2,3}};
B B2 = {0.2,{5,4,3}};
X X1 = {"abcdefghijklmnopqrstuvwxyzABCDEF", 'G'};
X X2 = {"123",'9'};
X X3 = {"return-return-return",'R'};

X f (B a, char b, double c, B d)
{
  static X xr = {"return val", 'R'};
  X r;
  r = xr;
  r.c1 = b;
  sprintf (out, "X f(B,char,double,B):({%g,{%d,%d,%d}},'%c',%g,{%g,{%d,%d,%d}})",
	   a.d, a.i[0], a.i[1], a.i[2], b, c, d.d, d.i[0], d.i[1], d.i[2]);
  return r;
}

X (*fp) (B, char, double, B) = &f;

main ()
{
  X Xr;
  char tmp[100];

  Xr = f (B1, c2, d3, B2);
  strcpy (tmp, out);
  Xr.c[0] = Xr.c1 = '\0';
  Xr = (*fp) (B1, c2, d3, B2);
  if (strcmp (tmp, out))
    abort ();

  exit (0);
}
// source: struct-ret-2.c
typedef struct
{
  unsigned char a __attribute__ ((packed));
  unsigned short b __attribute__ ((packed));
} three_byte_t;

unsigned char
f (void)
{
  return 0xab;
}

unsigned short
g (void)
{
  return 0x1234;
}

main ()
{
  three_byte_t three_byte;

  three_byte.a = f ();
  three_byte.b = g ();
  if (three_byte.a != 0xab || three_byte.b != 0x1234)
    abort ();
  exit (0);
}
// source: switch-1.c
/* Copyright (C) 2003  Free Software Foundation.

   Test that switch statements suitable using case bit tests are
   implemented correctly.

   Written by Roger Sayle, 01/25/2001.  */

extern void abort (void);

int
foo (int x)
{
  switch (x)
    {
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
    }
  return 31;
}

int
main ()
{
  int i, r;

  for (i=-1; i<66; i++)
    {
      r = foo (i);
      if (i == 4)
	{
	  if (r != 30)
	    abort ();
	}
      else if (i == 6)
	{
	  if (r != 30)
	    abort ();
	}
      else if (i == 9)
	{
	  if (r != 30)
	    abort ();
	}
      else if (i == 11)
	{
	  if (r != 30)
	    abort ();
	}
      else if (r != 31)
	abort ();
    }
  return 0;
}
// source: tstdi-1.c
#define FALSE 140
#define TRUE 13

feq (x)
     long long int x;
{
  if (x == 0)
    return TRUE;
  else
    return FALSE;
}

fne (x)
     long long int x;
{
  if (x != 0)
    return TRUE;
  else
    return FALSE;
}

flt (x)
     long long int x;
{
  if (x < 0)
    return TRUE;
  else
    return FALSE;
}

fge (x)
     long long int x;
{
  if (x >= 0)
    return TRUE;
  else
    return FALSE;
}

fgt (x)
     long long int x;
{
  if (x > 0)
    return TRUE;
  else
    return FALSE;
}

fle (x)
     long long int x;
{
  if (x <= 0)
    return TRUE;
  else
    return FALSE;
}

main ()
{
  if (feq (0LL) != TRUE)
    abort ();
  if (feq (-1LL) != FALSE)
    abort ();
  if (feq (0x8000000000000000LL) != FALSE)
    abort ();
  if (feq (0x8000000000000001LL) != FALSE)
    abort ();
  if (feq (1LL) != FALSE)
    abort ();
  if (feq (0x7fffffffffffffffLL) != FALSE)
    abort ();

  if (fne (0LL) != FALSE)
    abort ();
  if (fne (-1LL) != TRUE)
    abort ();
  if (fne (0x8000000000000000LL) != TRUE)
    abort ();
  if (fne (0x8000000000000001LL) != TRUE)
    abort ();
  if (fne (1LL) != TRUE)
    abort ();
  if (fne (0x7fffffffffffffffLL) != TRUE)
    abort ();

  if (flt (0LL) != FALSE)
    abort ();
  if (flt (-1LL) != TRUE)
    abort ();
  if (flt (0x8000000000000000LL) != TRUE)
    abort ();
  if (flt (0x8000000000000001LL) != TRUE)
    abort ();
  if (flt (1LL) != FALSE)
    abort ();
  if (flt (0x7fffffffffffffffLL) != FALSE)
    abort ();

  if (fge (0LL) != TRUE)
    abort ();
  if (fge (-1LL) != FALSE)
    abort ();
  if (fge (0x8000000000000000LL) != FALSE)
    abort ();
  if (fge (0x8000000000000001LL) != FALSE)
    abort ();
  if (fge (1LL) != TRUE)
    abort ();
  if (fge (0x7fffffffffffffffLL) != TRUE)
    abort ();

  if (fgt (0LL) != FALSE)
    abort ();
  if (fgt (-1LL) != FALSE)
    abort ();
  if (fgt (0x8000000000000000LL) != FALSE)
    abort ();
  if (fgt (0x8000000000000001LL) != FALSE)
    abort ();
  if (fgt (1LL) != TRUE)
    abort ();
  if (fgt (0x7fffffffffffffffLL) != TRUE)
    abort ();

  if (fle (0LL) != TRUE)
    abort ();
  if (fle (-1LL) != TRUE)
    abort ();
  if (fle (0x8000000000000000LL) != TRUE)
    abort ();
  if (fle (0x8000000000000001LL) != TRUE)
    abort ();
  if (fle (1LL) != FALSE)
    abort ();
  if (fle (0x7fffffffffffffffLL) != FALSE)
    abort ();

  exit (0);
}
// source: unroll-1.c
/* { dg-options "-fgnu89-inline" } */

extern void abort (void);
extern void exit (int);

inline int
f (int x)
{
  return (x + 1);
}

int
main (void)
{
  int a = 0 ;

  while ( (f(f(f(f(f(f(f(f(f(f(1))))))))))) + a < 12 )
    {
      a++;
      exit (0);
    }
  if (a != 1)
    abort();
}
// source: usad-run.c
extern void abort ();
extern int abs (int __x) __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__const__));

static int
foo (unsigned char *w, int i, unsigned char *x, int j)
{
  int tot = 0;
  for (int a = 0; a < 16; a++)
    {
      for (int b = 0; b < 16; b++)
	tot += abs (w[b] - x[b]);
      w += i;
      x += j;
    }
  return tot;
}

void
bar (unsigned char *w, unsigned char *x, int i, int *result)
{
  *result = foo (w, 16, x, i);
}

int
main (void)
{
  unsigned char m[256];
  unsigned char n[256];
  int sum, i;

  for (i = 0; i < 256; ++i)
    if (i % 2 == 0)
      {
	m[i] = (i % 8) * 2 + 1;
	n[i] = -(i % 8);
      }
    else
      {
	m[i] = -((i % 8) * 2 + 2);
	n[i] = -((i % 8) >> 1);
      }

  bar (m, n, 16, &sum);

  if (sum != 32384)
    abort ();

  return 0;
}
// source: user-printf.c
/* Verify that calls to a function declared wiith attribute format (printf)
   don't get eliminated even if their result on success can be computed at
   compile time (they can fail).
   { dg-require-effective-target unwrapped }
   { dg-skip-if "requires io" { freestanding } } */

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void __attribute__ ((format (printf, 1, 2), noipa))
user_print (const char *fmt, ...)
{
  va_list va;
  va_start (va, fmt);
  vfprintf (stdout, fmt, va);
  va_end (va);
}

int main (void)
{
  char *tmpfname = tmpnam (0);
  FILE *f = freopen (tmpfname, "w", stdout);
  if (!f)
    {
      perror ("fopen for writing");
      return 1;
    }

  user_print ("1");
  user_print ("%c", '2');
  user_print ("%c%c", '3', '4');
  user_print ("%s", "5");
  user_print ("%s%s", "6", "7");
  user_print ("%i", 8);
  user_print ("%.1s\n", "9x");

  fclose (f);

  f = fopen (tmpfname, "r");
  if (!f)
    {
      perror ("fopen for reading");
      remove (tmpfname);
      return 1;
    }

  char buf[12] = "";
  if (1 != fscanf (f, "%s", buf))
    {
      perror ("fscanf");
      fclose (f);
      remove (tmpfname);
      return 1;
    }

  fclose (f);
  remove (tmpfname);

  if (strcmp (buf, "123456789"))
    abort ();

  return 0;
}
// source: usmul.c
/* { dg-require-effective-target int32plus } */
int __attribute__ ((noinline)) foo (short x, unsigned short y)
{
  return x * y;
}

int __attribute__ ((noinline)) bar (unsigned short x, short y)
{
  return x * y;
}

int main ()
{
  if (foo (-2, 0xffff) != -131070)
    abort ();
  if (foo (2, 0xffff) != 131070)
    abort ();
  if (foo (-32768, 0x8000) != -1073741824)
    abort ();
  if (foo (32767, 0x8000) != 1073709056)
    abort ();

  if (bar (0xffff, -2) != -131070)
    abort ();
  if (bar (0xffff, 2) != 131070)
    abort ();
  if (bar (0x8000, -32768) != -1073741824)
    abort ();
  if (bar (0x8000, 32767) != 1073709056)
    abort ();

  exit (0);
}
// source: va-arg-1.c
#include <stdarg.h>

typedef unsigned long L;
f (L p0, L p1, L p2, L p3, L p4, L p5, L p6, L p7, L p8, ...)
{
  va_list select;

  va_start (select, p8);

  if (va_arg (select, L) != 10)
    abort ();
  if (va_arg (select, L) != 11)
    abort ();
  if (va_arg (select, L) != 0)
    abort ();

  va_end (select);
}

main ()
{
  f (1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L, 0L);
  exit (0);
}
// source: va-arg-10.c
/* This is a modfied version of va-arg-9.c to test va_copy.  */

#include <stdarg.h>

#ifndef va_copy
#define va_copy __va_copy
#endif

extern __SIZE_TYPE__ strlen (const char *);

int
to_hex (unsigned int a)
{
  static char hex[] = "0123456789abcdef";

  if (a > 15)
    abort ();
  return hex[a];
}

void
fap (int i, char* format, va_list ap)
{
  va_list apc;
  char *formatc;

  va_copy (apc, ap);
  formatc = format;

  if (strlen (format) != 16 - i)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  while (*formatc)
    if (*formatc++ != to_hex (va_arg (apc, int)))
      abort ();
}

void
f0 (char* format, ...)
{
  va_list ap;

  va_start (ap, format);
  fap(0, format, ap);
  va_end(ap);
}

void
f1 (int a1, char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(1, format, ap);
  va_end(ap);
}

void
f2 (int a1, int a2, char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(2, format, ap);
  va_end(ap);
}

void
f3 (int a1, int a2, int a3, char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(3, format, ap);
  va_end(ap);
}

void
f4 (int a1, int a2, int a3, int a4, char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(4, format, ap);
  va_end(ap);
}

void
f5 (int a1, int a2, int a3, int a4, int a5,
    char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(5, format, ap);
  va_end(ap);
}

void
f6 (int a1, int a2, int a3, int a4, int a5,
    int a6,
    char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(6, format, ap);
  va_end(ap);
}

void
f7 (int a1, int a2, int a3, int a4, int a5,
    int a6, int a7,
    char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(7, format, ap);
  va_end(ap);
}

void
f8 (int a1, int a2, int a3, int a4, int a5,
    int a6, int a7, int a8,
    char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(8, format, ap);
  va_end(ap);
}

void
f9 (int a1, int a2, int a3, int a4, int a5,
    int a6, int a7, int a8, int a9,
    char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(9, format, ap);
  va_end(ap);
}

void
f10 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(10, format, ap);
  va_end(ap);
}

void
f11 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(11, format, ap);
  va_end(ap);
}

void
f12 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11, int a12,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(12, format, ap);
  va_end(ap);
}

void
f13 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11, int a12, int a13,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(13, format, ap);
  va_end(ap);
}

void
f14 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11, int a12, int a13, int a14,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(14, format, ap);
  va_end(ap);
}

void
f15 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11, int a12, int a13, int a14, int a15,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(15, format, ap);
  va_end(ap);
}

main ()
{
  char *f = "0123456789abcdef";

  f0 (f+0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f1 (0, f+1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f2 (0, 1, f+2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f3 (0, 1, 2, f+3, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f4 (0, 1, 2, 3, f+4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f5 (0, 1, 2, 3, 4, f+5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f6 (0, 1, 2, 3, 4, 5, f+6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f7 (0, 1, 2, 3, 4, 5, 6, f+7, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f8 (0, 1, 2, 3, 4, 5, 6, 7, f+8, 8, 9, 10, 11, 12, 13, 14, 15);
  f9 (0, 1, 2, 3, 4, 5, 6, 7, 8, f+9, 9, 10, 11, 12, 13, 14, 15);
  f10 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, f+10, 10, 11, 12, 13, 14, 15);
  f11 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, f+11, 11, 12, 13, 14, 15);
  f12 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, f+12, 12, 13, 14, 15);
  f13 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, f+13, 13, 14, 15);
  f14 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, f+14, 14, 15);
  f15 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, f+15, 15);

  exit (0);
}
// source: va-arg-11.c
/* Test va_arg when the result is ignored and only the pointer increment
   side effect is used.  */
#include <stdarg.h>

static int
foo (int a, ...)
{
  va_list va;
  int i, res;

  va_start (va, a);

  for (i = 0; i < 4; ++i)
    (void) va_arg (va, int);

  res = va_arg (va, int);

  va_end (va);

  return res;
}

int
main (void)
{
  if (foo (5, 4, 3, 2, 1, 0))
    abort ();
  exit (0);
}
// source: va-arg-12.c
#include <stdarg.h>

/*typedef unsigned long L;*/
typedef double L;
void f (L p0, L p1, L p2, L p3, L p4, L p5, L p6, L p7, L p8, ...)
{
  va_list select;

  va_start (select, p8);

  if (va_arg (select, L) != 10.)
    abort ();
  if (va_arg (select, L) != 11.)
    abort ();
  if (va_arg (select, L) != 0.)
    abort ();

  va_end (select);
}

int main ()
{
  f (1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 0.);
  exit (0);
}
// source: va-arg-13.c
/* derived from mozilla source code */

#include <stdarg.h>

typedef struct {
  void *stream;
  va_list ap;
  int nChar;
} ScanfState;

void dummy (va_list vap)
{
  if (va_arg (vap, int) != 1234) abort();
  return;
}

void test (int fmt, ...)
{
  ScanfState state, *statep;

  statep = &state;

  va_start (statep->ap, fmt);
  dummy (statep->ap);
  va_end (statep->ap);

  va_start (state.ap, fmt);
  dummy (state.ap);
  va_end (state.ap);

  return;
}

int main (void)
{
  test (456, 1234);
  exit (0);
}
// source: va-arg-14.c
#include <stdarg.h>

va_list global;

void vat(va_list param, ...)
{
  va_list local;

  va_start (local, param);
  va_copy (global, local);
  va_copy (param, local);
  if (va_arg (local, int) != 1)
    abort();
  va_end (local);
  if (va_arg (global, int) != 1)
    abort();
  va_end (global);
  if (va_arg (param, int) != 1)
    abort();
  va_end (param);

  va_start (param, param);
  va_start (global, param);
  va_copy (local, param);
  if (va_arg (local, int) != 1)
    abort();
  va_end (local);
  va_copy (local, global);
  if (va_arg (local, int) != 1)
    abort();
  va_end (local);
  if (va_arg (global, int) != 1)
    abort();
  va_end (global);
  if (va_arg (param, int) != 1)
    abort();
  va_end (param);
}

int main(void)
{
  va_list t;
  vat (t, 1);
  exit (0);
}
// source: va-arg-15.c
#include <stdarg.h>

void vafunction (char *dummy, ...)
{
  double darg;
  int iarg;
  int flag = 0;
  int i;
  va_list ap;

  va_start(ap, dummy);
  for (i = 1; i <= 18; i++, flag++)
    {
      if (flag & 1)
	{
	  darg = va_arg (ap, double);
	  if (darg != (double)i)
	    abort();
	}
      else
	{
	  iarg = va_arg (ap, int);
	  if (iarg != i)
	    abort();
	}
    }
    va_end(ap);
}

int main (void)
{
  vafunction( "",
	1, 2.,
	3, 4.,
	5, 6.,
	7, 8.,
	9, 10.,
	11, 12.,
	13, 14.,
	15, 16.,
	17, 18. );
  exit(0);
  return 0;
}
// source: va-arg-16.c
#include <stdarg.h>

typedef double TYPE;

void vafunction (TYPE dummy1, TYPE dummy2, ...)
{
  va_list ap;

  va_start(ap, dummy2);
  if (dummy1 != 888.)
    abort();
  if (dummy2 != 999.)
    abort();
  if (va_arg (ap, TYPE) != 1.)
    abort();
  if (va_arg (ap, TYPE) != 2.)
    abort();
  if (va_arg (ap, TYPE) != 3.)
    abort();
  if (va_arg (ap, TYPE) != 4.)
    abort();
  if (va_arg (ap, TYPE) != 5.)
    abort();
  if (va_arg (ap, TYPE) != 6.)
    abort();
  if (va_arg (ap, TYPE) != 7.)
    abort();
  if (va_arg (ap, TYPE) != 8.)
    abort();
  if (va_arg (ap, TYPE) != 9.)
    abort();
  va_end(ap);
}


int main (void)
{
  vafunction( 888., 999., 1., 2., 3., 4., 5., 6., 7., 8., 9. );
  exit(0);
  return 0;
}
// source: va-arg-17.c
#include <stdarg.h>

typedef double TYPE;

void vafunction (char *dummy, ...)
{
  va_list ap;

  va_start(ap, dummy);
  if (va_arg (ap, TYPE) != 1.)
    abort();
  if (va_arg (ap, TYPE) != 2.)
    abort();
  if (va_arg (ap, TYPE) != 3.)
    abort();
  if (va_arg (ap, TYPE) != 4.)
    abort();
  if (va_arg (ap, TYPE) != 5.)
    abort();
  if (va_arg (ap, TYPE) != 6.)
    abort();
  if (va_arg (ap, TYPE) != 7.)
    abort();
  if (va_arg (ap, TYPE) != 8.)
    abort();
  if (va_arg (ap, TYPE) != 9.)
    abort();
  va_end(ap);
}


int main (void)
{
  vafunction( "", 1., 2., 3., 4., 5., 6., 7., 8., 9. );
  exit(0);
  return 0;
}
// source: va-arg-18.c
#include <stdarg.h>

typedef double L;
void f (L p0, L p1, L p2, L p3, L p4, L p5, L p6, L p7, L p8, ...)
{
  va_list select;

  va_start (select, p8);

  if (va_arg (select, int) != 10)
    abort ();
  if (va_arg (select, int) != 11)
    abort ();
  if (va_arg (select, int) != 12)
    abort ();

  va_end (select);
}

int main ()
{
  f (1., 2., 3., 4., 5., 6., 7., 8., 9., 10, 11, 12);
  exit (0);
}
// source: va-arg-19.c
#include <stdarg.h>

typedef int TYPE;

void vafunction (char *dummy, ...)
{
  va_list ap;

  va_start(ap, dummy);
  if (va_arg (ap, TYPE) != 1)
    abort();
  if (va_arg (ap, TYPE) != 2)
    abort();
  if (va_arg (ap, TYPE) != 3)
    abort();
  if (va_arg (ap, TYPE) != 4)
    abort();
  if (va_arg (ap, TYPE) != 5)
    abort();
  if (va_arg (ap, TYPE) != 6)
    abort();
  if (va_arg (ap, TYPE) != 7)
    abort();
  if (va_arg (ap, TYPE) != 8)
    abort();
  if (va_arg (ap, TYPE) != 9)
    abort();
  va_end(ap);
}


int main (void)
{
  vafunction( "", 1, 2, 3, 4, 5, 6, 7, 8, 9 );
  exit(0);
  return 0;
}
// source: va-arg-2.c
/* The purpose of this test is to catch edge cases when arguments are passed
   in regs and on the stack.  We test 16 cases, trying to catch multiple
   targets (some use 3 regs for argument passing, some use 12, etc.).
   We test both the arguments and the `lastarg' (the argument to va_start).  */

#include <stdarg.h>

extern __SIZE_TYPE__ strlen ();

int
to_hex (unsigned int a)
{
  static char hex[] = "0123456789abcdef";

  if (a > 15)
    abort ();
  return hex[a];
}

void
f0 (char* format, ...)
{
  va_list ap;

  va_start (ap, format);
  if (strlen (format) != 16 - 0)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f1 (int a1, char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 1)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f2 (int a1, int a2, char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 2)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f3 (int a1, int a2, int a3, char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 3)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f4 (int a1, int a2, int a3, int a4, char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 4)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f5 (int a1, int a2, int a3, int a4, int a5,
    char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 5)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f6 (int a1, int a2, int a3, int a4, int a5,
    int a6,
    char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 6)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f7 (int a1, int a2, int a3, int a4, int a5,
    int a6, int a7,
    char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 7)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f8 (int a1, int a2, int a3, int a4, int a5,
    int a6, int a7, int a8,
    char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 8)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f9 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 9)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f10 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 10)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f11 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 11)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f12 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11, int a12,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 12)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f13 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11, int a12, int a13,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 13)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f14 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11, int a12, int a13, int a14,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 14)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

void
f15 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11, int a12, int a13, int a14, int a15,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  if (strlen (format) != 16 - 15)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
  va_end(ap);
}

main ()
{
  char *f = "0123456789abcdef";

  f0 (f+0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f1 (0, f+1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f2 (0, 1, f+2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f3 (0, 1, 2, f+3, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f4 (0, 1, 2, 3, f+4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f5 (0, 1, 2, 3, 4, f+5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f6 (0, 1, 2, 3, 4, 5, f+6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f7 (0, 1, 2, 3, 4, 5, 6, f+7, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f8 (0, 1, 2, 3, 4, 5, 6, 7, f+8, 8, 9, 10, 11, 12, 13, 14, 15);
  f9 (0, 1, 2, 3, 4, 5, 6, 7, 8, f+9, 9, 10, 11, 12, 13, 14, 15);
  f10 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, f+10, 10, 11, 12, 13, 14, 15);
  f11 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, f+11, 11, 12, 13, 14, 15);
  f12 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, f+12, 12, 13, 14, 15);
  f13 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, f+13, 13, 14, 15);
  f14 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, f+14, 14, 15);
  f15 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, f+15, 15);

  exit (0);
}
// source: va-arg-20.c
#include <stdarg.h>

void foo(va_list v)
{
    unsigned long long x = va_arg (v, unsigned long long);
    if (x != 16LL)
	abort();
}

void bar(char c, char d, ...)
{
    va_list v;
    va_start(v, d);
    foo(v);
    va_end(v);
}

int main(void)
{
    bar(0, 0, 16LL);
    exit(0);
}
// source: va-arg-21.c
/* Copyright (C) 2000  Free Software Foundation.

   If the argument to va_end() has side effects, test whether side
   effects from that argument are honored.

   Written by Kaveh R. Ghazi, 10/31/2000.  */

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef __GNUC__
#define __attribute__(x)
#endif

static void __attribute__ ((__format__ (__printf__, 1, 2)))
doit (const char *s, ...)
{
  va_list *ap_array[3], **ap_ptr = ap_array;

  ap_array[0] = malloc (sizeof(va_list));
  ap_array[1] = NULL;
  ap_array[2] = malloc (sizeof(va_list));

  va_start (*ap_array[0], s);
  vprintf (s, **ap_ptr);
  /* Increment the va_list pointer once.  */
  va_end (**ap_ptr++);

  /* Increment the va_list pointer a second time.  */
  ap_ptr++;

  va_start (*ap_array[2], s);
  /* If we failed to increment ap_ptr twice, then the parameter passed
     in here will dereference NULL and should cause a crash.  */
  vprintf (s, **ap_ptr);
  va_end (**ap_ptr);

  /* Just in case, If *ap_ptr is NULL abort anyway.  */
  if (*ap_ptr == 0)
    abort();
}

int main()
{
  doit ("%s", "hello world\n");
  exit (0);
}
// source: va-arg-22.c
#include <stdarg.h>

extern void abort (void);
extern void exit (int);

void bar (int n, int c)
{
  static int lastn = -1, lastc = -1;

  if (lastn != n)
    {
      if (lastc != lastn)
	abort ();
      lastc = 0;
      lastn = n;
    }

  if (c != (char) (lastc ^ (n << 3)))
    abort ();
  lastc++;
}

#define D(N) typedef struct { char x[N]; } A##N;
D(0) D(1) D(2) D(3) D(4) D(5) D(6) D(7)
D(8) D(9) D(10) D(11) D(12) D(13) D(14) D(15)
D(16) D(31) D(32) D(35) D(72)
#undef D

void foo (int size, ...)
{
#define D(N) A##N a##N;
D(0) D(1) D(2) D(3) D(4) D(5) D(6) D(7)
D(8) D(9) D(10) D(11) D(12) D(13) D(14) D(15)
D(16) D(31) D(32) D(35) D(72)
#undef D
  va_list ap;
  int i;

  if (size != 21)
    abort ();
  va_start (ap, size);
#define D(N)					\
  a##N = va_arg (ap, typeof (a##N));		\
  for (i = 0; i < N; i++)			\
    bar (N, a##N.x[i]);
D(0) D(1) D(2) D(3) D(4) D(5) D(6) D(7)
D(8) D(9) D(10) D(11) D(12) D(13) D(14) D(15)
D(16) D(31) D(32) D(35) D(72)
#undef D
  va_end (ap);
}

int main (void)
{
#define D(N) A##N a##N;
D(0) D(1) D(2) D(3) D(4) D(5) D(6) D(7)
D(8) D(9) D(10) D(11) D(12) D(13) D(14) D(15)
D(16) D(31) D(32) D(35) D(72)
#undef D
  int i;

#define D(N)					\
  for (i = 0; i < N; i++)			\
    a##N.x[i] = i ^ (N << 3);
D(0) D(1) D(2) D(3) D(4) D(5) D(6) D(7)
D(8) D(9) D(10) D(11) D(12) D(13) D(14) D(15)
D(16) D(31) D(32) D(35) D(72)
#undef D

  foo (21
#define D(N) , a##N
D(0) D(1) D(2) D(3) D(4) D(5) D(6) D(7)
D(8) D(9) D(10) D(11) D(12) D(13) D(14) D(15)
D(16) D(31) D(32) D(35) D(72)
#undef D
      );
  exit (0);
}
// source: va-arg-23.c
/* PR 9700 */
/* Alpha got the base address for the va_list incorrect when there was
   a structure that was passed partially in registers and partially on
   the stack.  */

#include <stdarg.h>

struct two { long x, y; };

void foo(int a, int b, int c, int d, int e, struct two f, int g, ...)
{
  va_list args;
  int h;

  va_start(args, g);
  h = va_arg(args, int);
  if (g != 1 || h != 2)
    abort ();
}

int main()
{
  struct two t = { 0, 0 };
  foo(0, 0, 0, 0, 0, t, 1, 2);
  return 0;
}
// source: va-arg-24.c
/* The purpose of this code is to test argument passing of a tuple of
   11 integers, with the break point between named and unnamed arguments
   at every possible position.	*/

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

static int errors = 0;

static void
verify (const char *tcase, int n[11])
{
  int i;
  for (i = 0; i <= 10; i++)
    if (n[i] != i)
      {
	printf (" %s: n[%d] = %d expected %d\n", tcase, i, n[i], i);
	errors++;
      }
}

#define STR(x) #x

#define p(i) int q##i,
#define P(i) n[i] = q##i;

#define p0 p(0)
#define p1 p(1)
#define p2 p(2)
#define p3 p(3)
#define p4 p(4)
#define p5 p(5)
#define p6 p(6)
#define p7 p(7)
#define p8 p(8)
#define p9 p(9)

#define P0 P(0)
#define P1 P(1)
#define P2 P(2)
#define P3 P(3)
#define P4 P(4)
#define P5 P(5)
#define P6 P(6)
#define P7 P(7)
#define P8 P(8)
#define P9 P(9)

#define TCASE(x, params, vecinit)		\
static void					\
varargs##x (params ...)				\
{						\
  va_list ap;					\
  int n[11];					\
  int i;					\
						\
  va_start (ap, q##x);				\
  vecinit					\
  for (i = x + 1; i <= 10; i++)			\
    n[i] = va_arg (ap, int);			\
  va_end (ap);					\
						\
  verify (STR(varargs##x), n);			\
}

#define TEST(x) varargs##x (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

TCASE(0, p0			      , P0			     )
TCASE(1, p0 p1			      , P0 P1			     )
TCASE(2, p0 p1 p2		      , P0 P1 P2		     )
TCASE(3, p0 p1 p2 p3		      , P0 P1 P2 P3		     )
TCASE(4, p0 p1 p2 p3 p4		      , P0 P1 P2 P3 P4		     )
TCASE(5, p0 p1 p2 p3 p4 p5	      , P0 P1 P2 P3 P4 P5	     )
TCASE(6, p0 p1 p2 p3 p4 p5 p6	      , P0 P1 P2 P3 P4 P5 P6	     )
TCASE(7, p0 p1 p2 p3 p4 p5 p6 p7      , P0 P1 P2 P3 P4 P5 P6 P7	     )
TCASE(8, p0 p1 p2 p3 p4 p5 p6 p7 p8   , P0 P1 P2 P3 P4 P5 P6 P7 P8   )
TCASE(9, p0 p1 p2 p3 p4 p5 p6 p7 p8 p9, P0 P1 P2 P3 P4 P5 P6 P7 P8 P9)

int main(void)
{
  TEST(0);
  TEST(1);
  TEST(2);
  TEST(3);
  TEST(4);
  TEST(5);
  TEST(6);
  TEST(7);
  TEST(8);
  TEST(9);

  if (errors)
    abort ();
  exit (0);
}
// source: va-arg-26.c
#include <stdarg.h>

double f (float f1, float f2, float f3, float f4,
	  float f5, float f6, ...)
{
  va_list ap;
  double d;

  va_start (ap, f6);
  d = va_arg (ap, double);
  va_end (ap);
  return d;
}

int main ()
{
  if (f (1, 2, 3, 4, 5, 6, 7.0) != 7.0)
    abort ();
  exit (0);
}
// source: va-arg-4.c
/* On the i960 any arg bigger than 16 bytes causes all subsequent args
   to be passed on the stack.  We test this.  */

#include <stdarg.h>

typedef struct {
  char a[32];
} big;

void
f (big x, char *s, ...)
{
  va_list ap;

  if (x.a[0] != 'a' || x.a[1] != 'b' || x.a[2] != 'c')
    abort ();
  va_start (ap, s);
  if (va_arg (ap, int) != 42)
    abort ();
  if (va_arg (ap, int) != 'x')
    abort ();
  if (va_arg (ap, int) != 0)
    abort ();
  va_end (ap);
}

main ()
{
  static big x = { "abc" };

  f (x, "", 42, 'x', 0);
  exit (0);
}
// source: va-arg-5.c
#include <stdarg.h>

va_double (int n, ...)
{
  va_list args;

  va_start (args, n);

  if (va_arg (args, double) != 3.141592)
    abort ();
  if (va_arg (args, double) != 2.71827)
    abort ();
  if (va_arg (args, double) != 2.2360679)
    abort ();
  if (va_arg (args, double) != 2.1474836)
    abort ();

  va_end (args);
}

va_long_double (int n, ...)
{
  va_list args;

  va_start (args, n);

  if (va_arg (args, long double) != 3.141592L)
    abort ();
  if (va_arg (args, long double) != 2.71827L)
    abort ();
  if (va_arg (args, long double) != 2.2360679L)
    abort ();
  if (va_arg (args, long double) != 2.1474836L)
    abort ();

  va_end (args);
}

main ()
{
  va_double (4, 3.141592, 2.71827, 2.2360679, 2.1474836);
  va_long_double (4, 3.141592L, 2.71827L, 2.2360679L, 2.1474836L);
  exit (0);
}
// source: va-arg-6.c
#include <stdarg.h>

f (int n, ...)
{
  va_list args;

  va_start (args, n);

  if (va_arg (args, int) != 10)
    abort ();
  if (va_arg (args, long long) != 10000000000LL)
    abort ();
  if (va_arg (args, int) != 11)
    abort ();
  if (va_arg (args, long double) != 3.14L)
    abort ();
  if (va_arg (args, int) != 12)
    abort ();
  if (va_arg (args, int) != 13)
    abort ();
  if (va_arg (args, long long) != 20000000000LL)
    abort ();
  if (va_arg (args, int) != 14)
    abort ();
  if (va_arg (args, double) != 2.72)
    abort ();

  va_end(args);
}

main ()
{
  f (4, 10, 10000000000LL, 11, 3.14L, 12, 13, 20000000000LL, 14, 2.72);
  exit (0);
}
// source: va-arg-7.c
/* Origin: Franz Sirl <Franz.Sirl-kernel@lauterbach.com> */
/* { dg-options "-fgnu89-inline" } */

extern void abort (void);
extern void exit (int);

#include <stdarg.h>

inline void
debug(int i1, int i2, int i3, int i4, int i5, int i6, int i7,
      double f1, double f2, double f3, double f4, double f5,
      double f6, double f7, double f8, double f9, ...)
{
  va_list ap;

  va_start (ap, f9);

  if (va_arg (ap,int) != 8)
    abort ();
  if (va_arg (ap,int) != 9)
    abort ();
  if (va_arg (ap,int) != 10)
    abort ();

  va_end (ap);
}

int
main(void)
{
  debug (1, 2, 3, 4, 5, 6, 7,
	 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0,
	 8, 9, 10);
  exit (0);
}
// source: va-arg-8.c
/* Origin: Franz Sirl <Franz.Sirl-kernel@lauterbach.com> */
/* { dg-options "-fgnu89-inline" } */

extern void abort (void);
extern void exit (int);

#include <stdarg.h>
#include <limits.h>

#if __LONG_LONG_MAX__ == 9223372036854775807LL

typedef long long int INT64;

inline void
debug(int i1, int i2, int i3, int i4, int i5,
      int i6, int i7, int i8, int i9, ...)
{
  va_list ap;

  va_start (ap, i9);

  if (va_arg (ap,int) != 10)
    abort ();
  if (va_arg (ap,INT64) != 0x123400005678LL)
    abort ();

  va_end (ap);
}

int
main(void)
{
  debug(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0x123400005678LL);
  exit(0);
}

#else

int
main(void)
{
  exit(0);
}

#endif /* long long 64 bits */
// source: va-arg-9.c
/* This is a modfied version of va-arg-2.c to test passing a va_list as
   a parameter to another function.  */

#include <stdarg.h>

extern __SIZE_TYPE__ strlen (const char *);

int
to_hex (unsigned int a)
{
  static char hex[] = "0123456789abcdef";

  if (a > 15)
    abort ();
  return hex[a];
}

void
fap (int i, char* format, va_list ap)
{
  if (strlen (format) != 16 - i)
    abort ();
  while (*format)
    if (*format++ != to_hex (va_arg (ap, int)))
      abort ();
}

void
f0 (char* format, ...)
{
  va_list ap;

  va_start (ap, format);
  fap(0, format, ap);
  va_end(ap);
}

void
f1 (int a1, char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(1, format, ap);
  va_end(ap);
}

void
f2 (int a1, int a2, char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(2, format, ap);
  va_end(ap);
}

void
f3 (int a1, int a2, int a3, char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(3, format, ap);
  va_end(ap);
}

void
f4 (int a1, int a2, int a3, int a4, char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(4, format, ap);
  va_end(ap);
}

void
f5 (int a1, int a2, int a3, int a4, int a5,
    char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(5, format, ap);
  va_end(ap);
}

void
f6 (int a1, int a2, int a3, int a4, int a5,
    int a6,
    char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(6, format, ap);
  va_end(ap);
}

void
f7 (int a1, int a2, int a3, int a4, int a5,
    int a6, int a7,
    char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(7, format, ap);
  va_end(ap);
}

void
f8 (int a1, int a2, int a3, int a4, int a5,
    int a6, int a7, int a8,
    char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(8, format, ap);
  va_end(ap);
}

void
f9 (int a1, int a2, int a3, int a4, int a5,
    int a6, int a7, int a8, int a9,
    char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(9, format, ap);
  va_end(ap);
}

void
f10 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(10, format, ap);
  va_end(ap);
}

void
f11 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(11, format, ap);
  va_end(ap);
}

void
f12 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11, int a12,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(12, format, ap);
  va_end(ap);
}

void
f13 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11, int a12, int a13,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(13, format, ap);
  va_end(ap);
}

void
f14 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11, int a12, int a13, int a14,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(14, format, ap);
  va_end(ap);
}

void
f15 (int a1, int a2, int a3, int a4, int a5,
     int a6, int a7, int a8, int a9, int a10,
     int a11, int a12, int a13, int a14, int a15,
     char* format, ...)
{
  va_list ap;

  va_start(ap, format);
  fap(15, format, ap);
  va_end(ap);
}

main ()
{
  char *f = "0123456789abcdef";

  f0 (f+0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f1 (0, f+1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f2 (0, 1, f+2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f3 (0, 1, 2, f+3, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f4 (0, 1, 2, 3, f+4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f5 (0, 1, 2, 3, 4, f+5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f6 (0, 1, 2, 3, 4, 5, f+6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f7 (0, 1, 2, 3, 4, 5, 6, f+7, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  f8 (0, 1, 2, 3, 4, 5, 6, 7, f+8, 8, 9, 10, 11, 12, 13, 14, 15);
  f9 (0, 1, 2, 3, 4, 5, 6, 7, 8, f+9, 9, 10, 11, 12, 13, 14, 15);
  f10 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, f+10, 10, 11, 12, 13, 14, 15);
  f11 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, f+11, 11, 12, 13, 14, 15);
  f12 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, f+12, 12, 13, 14, 15);
  f13 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, f+13, 13, 14, 15);
  f14 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, f+14, 14, 15);
  f15 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, f+15, 15);

  exit (0);
}
// source: va-arg-pack-1.c
/* __builtin_va_arg_pack () builtin tests.  */

#include <stdarg.h>

extern void abort (void);

int v1 = 8;
long int v2 = 3;
void *v3 = (void *) &v2;
struct A { char c[16]; } v4 = { "foo" };
long double v5 = 40;
char seen[20];
int cnt;

__attribute__ ((noinline)) int
foo1 (int x, int y, ...)
{
  int i;
  long int l;
  void *v;
  struct A a;
  long double ld;
  va_list ap;

  va_start (ap, y);
  if (x < 0 || x >= 20 || seen[x])
    abort ();
  seen[x] = ++cnt;
  if (y != 6)
    abort ();
  i = va_arg (ap, int);
  if (i != 5)
    abort ();
  switch (x)
    {
    case 0:
      i = va_arg (ap, int);
      if (i != 9 || v1 != 9)
	abort ();
      a = va_arg (ap, struct A);
      if (__builtin_memcmp (a.c, v4.c, sizeof (a.c)) != 0)
	abort ();
      v = (void *) va_arg (ap, struct A *);
      if (v != (void *) &v4)
	abort ();
      l = va_arg (ap, long int);
      if (l != 3 || v2 != 4)
	abort ();
      break;
    case 1:
      ld = va_arg (ap, long double);
      if (ld != 41 || v5 != ld)
	abort ();
      i = va_arg (ap, int);
      if (i != 8)
	abort ();
      v = va_arg (ap, void *);
      if (v != &v2)
	abort ();
      break;
    case 2:
      break;
    default:
      abort ();
    }
  va_end (ap);
  return x;
}

__attribute__ ((noinline)) int
foo2 (int x, int y, ...)
{
  long long int ll;
  void *v;
  struct A a, b;
  long double ld;
  va_list ap;

  va_start (ap, y);
  if (x < 0 || x >= 20 || seen[x])
    abort ();
  seen[x] = ++cnt | 64;
  if (y != 10)
    abort ();
  switch (x)
    {
    case 11:
      break;
    case 12:
      ld = va_arg (ap, long double);
      if (ld != 41 || v5 != 40)
	abort ();
      a = va_arg (ap, struct A);
      if (__builtin_memcmp (a.c, v4.c, sizeof (a.c)) != 0)
	abort ();
      b = va_arg (ap, struct A);
      if (__builtin_memcmp (b.c, v4.c, sizeof (b.c)) != 0)
	abort ();
      v = va_arg (ap, void *);
      if (v != &v2)
	abort ();
      ll = va_arg (ap, long long int);
      if (ll != 16LL)
	abort ();
      break;
    case 2:
      break;
    default:
      abort ();
    }
  va_end (ap);
  return x + 8;
}

__attribute__ ((noinline)) int
foo3 (void)
{
  return 6;
}

extern inline __attribute__ ((always_inline, gnu_inline)) int
bar (int x, ...)
{
  if (x < 10)
    return foo1 (x, foo3 (), 5, __builtin_va_arg_pack ());
  return foo2 (x, foo3 () + 4, __builtin_va_arg_pack ());
}

int
main (void)
{
  if (bar (0, ++v1, v4, &v4, v2++) != 0)
    abort ();
  if (bar (1, ++v5, 8, v3) != 1)
    abort ();
  if (bar (2) != 2)
    abort ();
  if (bar (v1 + 2) != 19)
    abort ();
  if (bar (v1 + 3, v5--, v4, v4, v3, 16LL) != 20)
    abort ();
  return 0;
}
// source: va-arg-trap-1.c
/* Undefined behavior from a call to va_arg with a type other than
   that of the argument passed (in particular, with a type such as
   "float" that can never be the type of an argument passed through
   "...") does not appear until after the va_list expression is
   evaluated.  PR 38483.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */

#include <stdarg.h>

extern void exit (int);
extern void abort (void);

va_list ap;
float f;

va_list *
foo (void)
{
  exit (0);
  return &ap;
}

void
bar (int i, ...)
{
  va_start (ap, i);
  f = va_arg (*foo (), float);
  va_end (ap);
}

int
main (void)
{
  bar (1, 0);
  abort ();
}
// source: vfprintf-1.c
/* { dg-skip-if "requires io" { freestanding } }  */

#ifndef test
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

void
inner (int x, ...)
{
  va_list ap, ap2;
  va_start (ap, x);
  va_start (ap2, x);

  switch (x)
    {
#define test(n, ret, fmt, args) \
    case n:					\
      vfprintf (stdout, fmt, ap);		\
      if (vfprintf (stdout, fmt, ap2) != ret)	\
	abort ();				\
      break;
#include "vfprintf-1.c"
#undef test
    default:
      abort ();
    }

  va_end (ap);
  va_end (ap2);
}

int
main (void)
{
#define test(n, ret, fmt, args) \
  inner args;
#include "vfprintf-1.c"
#undef test
  return 0;
}

#else
  test (0, 5, "hello", (0));
  test (1, 6, "hello\n", (1));
  test (2, 1, "a", (2));
  test (3, 0, "", (3));
  test (4, 5, "%s", (4, "hello"));
  test (5, 6, "%s", (5, "hello\n"));
  test (6, 1, "%s", (6, "a"));
  test (7, 0, "%s", (7, ""));
  test (8, 1, "%c", (8, 'x'));
  test (9, 7, "%s\n", (9, "hello\n"));
  test (10, 2, "%d\n", (10, 0));
#endif
// source: vfprintf-chk-1.c
/* { dg-skip-if "requires io" { freestanding } }  */

#ifndef test
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

volatile int should_optimize;

int
__attribute__((noinline))
__vfprintf_chk (FILE *f, int flag, const char *fmt, va_list ap)
{
#ifdef __OPTIMIZE__
  if (should_optimize)
    abort ();
#endif
  should_optimize = 1;
  return vfprintf (f, fmt, ap);
}

void
inner (int x, ...)
{
  va_list ap, ap2;
  va_start (ap, x);
  va_start (ap2, x);

  switch (x)
    {
#define test(n, ret, opt, fmt, args) \
    case n:						\
      should_optimize = opt;				\
      __vfprintf_chk (stdout, 1, fmt, ap);		\
      if (! should_optimize)				\
	abort ();					\
      should_optimize = 0;				\
      if (__vfprintf_chk (stdout, 1, fmt, ap2) != ret)	\
	abort ();					\
      if (! should_optimize)				\
	abort ();					\
      break;
#include "vfprintf-chk-1.c"
#undef test
    default:
      abort ();
    }

  va_end (ap);
  va_end (ap2);
}

int
main (void)
{
#define test(n, ret, opt, fmt, args) \
  inner args;
#include "vfprintf-chk-1.c"
#undef test
  return 0;
}

#else
  test (0, 5, 1, "hello", (0));
  test (1, 6, 1, "hello\n", (1));
  test (2, 1, 1, "a", (2));
  test (3, 0, 1, "", (3));
  test (4, 5, 0, "%s", (4, "hello"));
  test (5, 6, 0, "%s", (5, "hello\n"));
  test (6, 1, 0, "%s", (6, "a"));
  test (7, 0, 0, "%s", (7, ""));
  test (8, 1, 0, "%c", (8, 'x'));
  test (9, 7, 0, "%s\n", (9, "hello\n"));
  test (10, 2, 0, "%d\n", (10, 0));
#endif
// source: vla-dealloc-1.c
/* VLAs should be deallocated on a jump to before their definition,
   including a jump to a label in an inner scope.  PR 19771.  */
/* { dg-require-effective-target alloca } */

#if (__SIZEOF_INT__ <= 2)
#define LIMIT 10000
#else
#define LIMIT 1000000
#endif

void *volatile p;

int
main (void)
{
  int n = 0;
  if (0)
    {
    lab:;
    }
  int x[n % 1000 + 1];
  x[0] = 1;
  x[n % 1000] = 2;
  p = x;
  n++;
  if (n < LIMIT)
    goto lab;
  return 0;
}
// source: vprintf-1.c
/* { dg-skip-if "requires io" { freestanding } }  */

#ifndef test
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

void
inner (int x, ...)
{
  va_list ap, ap2;
  va_start (ap, x);
  va_start (ap2, x);

  switch (x)
    {
#define test(n, ret, fmt, args) \
    case n:				\
      vprintf (fmt, ap);		\
      if (vprintf (fmt, ap2) != ret)	\
	abort ();			\
      break;
#include "vprintf-1.c"
#undef test
    default:
      abort ();
    }

  va_end (ap);
  va_end (ap2);
}

int
main (void)
{
#define test(n, ret, fmt, args) \
  inner args;
#include "vprintf-1.c"
#undef test
  return 0;
}

#else
  test (0, 5, "hello", (0));
  test (1, 6, "hello\n", (1));
  test (2, 1, "a", (2));
  test (3, 0, "", (3));
  test (4, 5, "%s", (4, "hello"));
  test (5, 6, "%s", (5, "hello\n"));
  test (6, 1, "%s", (6, "a"));
  test (7, 0, "%s", (7, ""));
  test (8, 1, "%c", (8, 'x'));
  test (9, 7, "%s\n", (9, "hello\n"));
  test (10, 2, "%d\n", (10, 0));
#endif
// source: vprintf-chk-1.c
/* { dg-skip-if "requires io" { freestanding } }  */

#ifndef test
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

volatile int should_optimize;

int
__attribute__((noinline))
__vprintf_chk (int flag, const char *fmt, va_list ap)
{
#ifdef __OPTIMIZE__
  if (should_optimize)
    abort ();
#endif
  should_optimize = 1;
  return vprintf (fmt, ap);
}

void
inner (int x, ...)
{
  va_list ap, ap2;
  va_start (ap, x);
  va_start (ap2, x);

  switch (x)
    {
#define test(n, ret, opt, fmt, args) \
    case n:					\
      should_optimize = opt;			\
      __vprintf_chk (1, fmt, ap);		\
      if (! should_optimize)			\
	abort ();				\
      should_optimize = 0;			\
      if (__vprintf_chk (1, fmt, ap2) != ret)	\
	abort ();				\
      if (! should_optimize)			\
	abort ();				\
      break;
#include "vprintf-chk-1.c"
#undef test
    default:
      abort ();
    }

  va_end (ap);
  va_end (ap2);
}

int
main (void)
{
#define test(n, ret, opt, fmt, args) \
  inner args;
#include "vprintf-chk-1.c"
#undef test
  return 0;
}

#else
  test (0, 5, 0, "hello", (0));
  test (1, 6, 1, "hello\n", (1));
  test (2, 1, 1, "a", (2));
  test (3, 0, 1, "", (3));
  test (4, 5, 0, "%s", (4, "hello"));
  test (5, 6, 0, "%s", (5, "hello\n"));
  test (6, 1, 0, "%s", (6, "a"));
  test (7, 0, 0, "%s", (7, ""));
  test (8, 1, 0, "%c", (8, 'x'));
  test (9, 7, 0, "%s\n", (9, "hello\n"));
  test (10, 2, 0, "%d\n", (10, 0));
#endif
// source: vrp-1.c

extern void abort ();
extern void exit (int);

int f (int a) {
	if (a != 2) {
		a = -a;
		if (a == 2)
		  return 0;
		return 1;
	}
	return 1;
}

int main (int argc, char *argv[]) {
	if (f (-2))
		abort ();
	exit (0);
}
// source: vrp-2.c
extern void abort ();
extern void exit (int);

int f (int a) {
	if (a != 2) {
		a = a > 0 ? a : -a;
		if (a == 2)
		  return 0;
		return 1;
	}
	return 1;
}

int main (int argc, char *argv[]) {
	if (f (-2))
		abort ();
	exit (0);
}
// source: vrp-3.c
extern void abort ();
extern void exit (int);

int f (int a) {
	if (a < 12) {
	  if (a > -15) {
		a = a > 0 ? a : -a;
		if (a == 2)
		  return 0;
		return 1;
	  }
	}
	return 1;
}

int main (int argc, char *argv[]) {
	if (f (-2))
		abort ();
	exit (0);
}
// source: vrp-4.c
extern void exit (int);
extern void abort ();

void test(int x, int y)
{
	int c;

	if (x == 1) abort();
	if (y == 1) abort();

	c = x / y;

	if (c != 1) abort();
}

int main()
{
	test(2, 2);
	exit (0);
}
// source: vrp-5.c
/* { dg-require-effective-target int32plus } */
extern void exit (int);
extern void abort ();

void test(unsigned int a, unsigned int b)
{
  if (a < 5)
    abort();
  if (b < 5)
    abort();
  if (a + b != 0U)
    abort();
}

int main(int argc, char *argv[])
{
  unsigned int x = 0x80000000;
  test(x, x);
  exit (0);
}
// source: vrp-6.c
/* { dg-require-effective-target int32plus } */
#include <limits.h>

extern void exit (int);
extern void abort ();

void test01(unsigned int a, unsigned int b)
{
  if (a < 5)
    abort();
  if (b < 5)
    abort();
  if (a - b != 5)
    abort();
}

void test02(unsigned int a, unsigned int b)
{
  if (a >= 12)
    if (b > 15)
      if (a - b < UINT_MAX - 15U)
	abort ();
}

int main(int argc, char *argv[])
{
  unsigned x = 0x80000000;
  test01(x + 5, x);
  test02(14, 16);
  exit (0);
}
// source: vrp-7.c

void abort (void);

struct T
{
  int b : 1;
} t;

void __attribute__((noinline)) foo (int f)
{
  t.b = (f & 0x10) ? 1 : 0;
}

int main (void)
{
  foo (0x10);
  if (!t.b)
    abort ();
  return 0;
}
// source: wchar_t-1.c
/* { dg-options "-finput-charset=utf-8" } */
typedef __WCHAR_TYPE__ wchar_t;
wchar_t x[] = L"âˆšÃ‘";
wchar_t y = L'âˆšÃ‘';
extern void abort (void);
extern void exit (int);

int main (void)
{
  if (sizeof (x) / sizeof (wchar_t) != 2)
    abort ();
  if (x[0] != L'âˆšÃ‘' || x[1] != L'\0')
    abort ();
  if (y != L'âˆšÃ‘')
    abort ();
  exit (0);
}
// source: widechar-1.c
#define C L'\400'

#if C
#define zero (!C)
#else
#define zero C
#endif

main()
{
  if (zero != 0)
    abort ();
  exit (0);
}
// source: widechar-2.c
#include <stddef.h>

const wchar_t ws[] = L"foo";

int
main (void)
{
  if (ws[0] != L'f' || ws[1] != L'o' || ws[2] != L'o' || ws[3] != L'\0')
    abort();
  exit(0);
}
// source: widechar-3.c
extern void abort (void);
extern void exit (int);

static int f(char *x)
{
   return __builtin_strlen(x);
}

int foo ()
{
   return f((char*)&L"abcdef"[0]);
}


int
main()
{
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
  if (foo () != 0)
    abort ();
#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  if (foo () != 1)
    abort ();
#endif
  exit (0);
}
// source: zero-struct-1.c
struct g{};
char y[3];
char *f = &y[0];
char *ff = &y[0];
void h(void)
{
  struct g t;
  *((struct g*)(f++)) = *((struct g*)(ff++));
  *((struct g*)(f++)) = (struct g){};
  t = *((struct g*)(ff++));
}

void abort (void);

int main(void)
{
  h();
  if (f != &y[2])
    abort();
  if (ff != &y[2])
    abort();
  return 0;
}
// source: zero-struct-2.c
void abort (void);
int ii;
typedef struct {} raw_spinlock_t;
typedef struct {
  raw_spinlock_t raw_lock;
} spinlock_t;
raw_spinlock_t one_raw_spinlock (void)
{
  raw_spinlock_t raw_lock;
  ii++;
  return raw_lock;
}
int main(void)
{
  spinlock_t lock = (spinlock_t) { .raw_lock = one_raw_spinlock() };
  if (ii != 1)
    abort ();
  return 0;
}
// source: zerolen-1.c
extern void abort (void);
extern void exit (int);

union iso_directory_record {
   char carr[4];
   struct {
           unsigned char name_len [1];
           char name [0];
   } u;
} entry;

void set(union iso_directory_record *);

int main (void)
{
   union iso_directory_record *de;

   de = &entry;
   set(de);

   if (de->u.name_len[0] == 1 && de->u.name[0] == 0)
     exit (0);
   else
     abort ();
}

void set (union iso_directory_record *p)
{
   p->carr[0] = 1;
   p->carr[1] = 0;
   return;
}
// source: zerolen-2.c
/* { dg-skip-if "assumes absence of larger-than-word padding" { epiphany-*-* } } */
extern void abort(void);

typedef int word __attribute__((mode(word)));

struct foo
{
  word x;
  word y[0];
};

int main()
{
  if (sizeof(word) != sizeof(struct foo))
    abort();
  if (__alignof__(word) != __alignof__(struct foo))
    abort();
  return 0;
}
